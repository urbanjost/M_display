var tipuesearch = {"pages":[{"title":" M_display ","text":"M_display Name M_display(3f) - a Fortran 95 module for pretty-printing matrices\n   (LICENSE:FREE) Build and Test with FPM Download the github repository and build it with\n   fpm ( as described at Fortran Package Manager ) bash\n        git clone https://github.com/urbanjost/M_display.git\n        cd M_display\n        fpm run \"*\"\n        fpm run --example \"*\"\n        fpm test or just list it as a dependency in your fpm.toml project file. [dependencies] M_display = { git = \"https://github.com/urbanjost/M_display.git\" } Documentation User Note in this version the module “dispmodule” has been named “M_display” … Original report Original User Manual a simple index to the man-pages in HTML form for the routines and programs A single page that uses javascript to combine all the HTML\n    descriptions of the man-pages BOOK_M_display . There are man-pages in the repository download in the docs/ directory\n    that may be installed on ULS (Unix-Like Systems) – manpages.zip or manpages.tgz CHANGELOG provides a history of significant changes Developer ford(1) output . doxygen(1) output . github action status Pedigree Copyright (c) 2008, Kristján Jónasson, Dept. of Computer Science, University of\nIceland (jonasson@hi.is). This software is free. For details see the file LICENSE. References ACM Algorithm 892: DISPMODULE a Fortran 95 module for pretty-printing matrices ACM Journals: ACM Transactions on Mathematical Software Vol. 36, No. 1 \n   Article No.:  6pp 1–7https://doi.org/10.1145/1486525.1486531\n   Author:       Kristjan Jonasson\n   Published:    16 March 2009 Additional References sited by the author Chambers, J. M. 2007. Software for Data Analysis: Programming with\n    R. Springer-Verlag, New York, NY. Google ScholarDigital Library Eaton, J. W. 2002. GNU Octave Manual. Network Theory Limited, Bristol, U.K.Google Scholar ISO/IEC. 1997. Information technology—programming\n    languages—Fortran-part 1: Base language. ISO/IEC Tech. rep. 1539-1:1997. \n    ISO, Geneva, Switzerland.Google Scholar Developer Info John S. Urban","tags":"home","url":"index.html"},{"title":"boxlist – M_display ","text":"type, public :: boxlist Components Type Visibility Attributes Name Initial type( boxnode ), public, pointer :: firstbox => null() type( boxnode ), public, pointer :: lastbox => null() type( boxlist ), public, pointer :: nextboxlist => null() integer, public :: unit = 1 Source Code type boxlist ! There is one list of boxes associated with each logical unit integer :: unit = 1 type ( boxnode ), pointer :: firstbox => null () type ( boxnode ), pointer :: lastbox => null () type ( boxlist ), pointer :: nextboxlist => null () end type boxlist","tags":"","url":"type/boxlist.html"},{"title":"boxnode – M_display ","text":"type, public :: boxnode Components Type Visibility Attributes Name Initial character(len=1), public, pointer :: box (:,:) type( boxnode ), public, pointer :: nextbox => null() Source Code type boxnode ! A box is the character representation of a printed item character , pointer :: box (:,:) type ( boxnode ), pointer :: nextbox => null () end type boxnode","tags":"","url":"type/boxnode.html"},{"title":"disp_settings – M_display ","text":"type, public :: disp_settings Components Type Visibility Attributes Name Initial character(len=6), public :: advance = 'YES' integer, public :: digmax = 6 character(len=9), public :: matsep = '   ' integer, public :: matseplen = 3 character(len=3), public :: orient = 'COL' character(len=9), public :: sep = '  ' integer, public :: seplen = 2 character(len=20), public :: style = 'LEFT' character(len=4), public :: trim = 'AUTO' integer, public :: unit = DEFAULT_UNIT integer, public :: zaslen = 0 character(len=9), public :: zeroas = '' Source Code type disp_settings ! Settings used by subroutine disp and the utility procedures. character ( 6 ) :: advance = 'YES' character ( 9 ) :: matsep = '   ' character ( 3 ) :: orient = 'COL' character ( 9 ) :: sep = '  ' character ( 20 ) :: style = 'LEFT' character ( 4 ) :: trim = 'AUTO' character ( 9 ) :: zeroas = '' integer :: digmax = 6 integer :: matseplen = 3 integer :: seplen = 2 integer :: unit = DEFAULT_UNIT integer :: zaslen = 0 end type disp_settings","tags":"","url":"type/disp_settings.html"},{"title":"settings – M_display ","text":"type, public :: settings Components Type Visibility Attributes Name Initial integer, public :: adv integer, public :: d integer, public :: dmx character(len=22), public :: ed logical, public :: gedit integer, public :: lsep integer, public :: lun integer, public :: lzas integer, public :: m1 integer, public :: n1 logical, public :: number logical, public :: row character(len=9), public :: sep character(len=1), public :: tch logical, public :: trm character(len=9), public :: tsty logical, public :: vec integer, public :: w character(len=9), public :: zas Source Code type settings ! Settings used (privately) by disp and the utility procedures, in the variable SE. character ( 22 ) ed character ( 9 ) sep , tsty , zas character ( 1 ) tch integer lun , dmx , w , d , lsep , lzas , m1 , n1 , adv logical trm , number , vec , row , gedit end type settings","tags":"","url":"type/settings.html"},{"title":"tostring_settings – M_display ","text":"type, public :: tostring_settings Components Type Visibility Attributes Name Initial character(len=10), public :: ifmt = 'I0' character(len=16), public :: rfmt = '1PG12.5' character(len=9), public :: sep = ', ' integer, public :: seplen = 2 character(len=3), public :: trimb = 'YES' character(len=4), public :: trimz = 'G' Source Code type tostring_settings ! Settings used by function tostring. character ( 10 ) :: ifmt = 'I0' character ( 16 ) :: rfmt = '1PG12.5' ! 'SP,1P,G20.11E3' has length 14 and is about max character ( 9 ) :: sep = ', ' integer :: seplen = 2 character ( 3 ) :: trimb = 'YES' character ( 4 ) :: trimz = 'G' end type tostring_settings","tags":"","url":"type/tostring_settings.html"},{"title":"putnl – M_display","text":"public  subroutine putnl() Arguments None Source Code subroutine putnl () end subroutine putnl","tags":"","url":"proc/putnl.html"},{"title":"putstr – M_display","text":"public  subroutine putstr(s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Variables Type Visibility Attributes Name Initial integer, public :: ldummy integer, public :: ldummy1 Source Code subroutine putstr ( s ) character ( * ), intent ( in ) :: s integer ldummy , ldummy1 ! these variables exist to avoid unused variable warnings ldummy = len ( s ) ldummy1 = ldummy ldummy = ldummy1 end subroutine putstr","tags":"","url":"proc/putstr.html"},{"title":"nnblk – M_display","text":"public pure function nnblk(s) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value integer Source Code pure function nnblk ( s ) result ( n ) ! count nonblanks in s character ( * ), intent ( in ) :: s integer i , n n = 0 do i = 1 , len ( s ) if ( s ( i : i ) /= ' ' ) n = n + 1 enddo end function nnblk","tags":"","url":"proc/nnblk.html"},{"title":"upper – M_display","text":"public pure function upper(s) result(su) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value character(len=len(s)) Source Code pure function upper ( s ) result ( su ) ! Change string to upper case character ( * ), intent ( in ) :: s character ( len ( s )) su character ( 26 ), parameter :: ll = 'abcdefghijklmnopqrstuvwxyz' , ul = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' integer i , k su = s do i = 1 , len ( s ) k = index ( ll , s ( i : i )) if ( k > 0 ) su ( i : i ) = ul ( k : k ) enddo end function upper","tags":"","url":"proc/upper.html"},{"title":"check_settings – M_display","text":"public  subroutine check_settings() Arguments None Source Code subroutine check_settings () ! Sanity check of display settings character ( 9 ) :: tsty character tch logical number , ok , dmxerr , orierr , styerr , adverr character ( 6 ), parameter :: ADVOK ( 3 ) = [ 'NO    ' , 'YES   ' , 'DOUBLE' ] type ( disp_settings ) ds ds = DEFSET call getstyles ( ds % style , tsty , tch , number , ok ) styerr = . not . ok dmxerr = ds % digmax < 1 . or . ds % digmax > 89 orierr = all ( ds % orient /= [ 'ROW' , 'COL' ]) adverr = all ( ds % advance /= ADVOK ) if ( dmxerr ) DEFSET % digmax = 6 if ( orierr ) DEFSET % orient = 'COL' if ( styerr ) DEFSET % style = 'LEFT' if ( adverr ) DEFSET % advance = 'YES' ! if ( dmxerr ) call disp_errmsg ( 'DISP_SET: error, illegal digmax (must be 1-89), set to 6' ) if ( orierr ) call disp_errmsg ( 'DISP_SET: error, illegal orient: ' // trim ( ds % orient ) // ', set to \"COL\"' ) if ( styerr ) call disp_errmsg ( 'DISP_SET: error, illegal style: ' // trim ( ds % style ) // ', set to \"LEFT\"' ) if ( adverr ) call disp_errmsg ( 'DISP_SET: error, illegal advance: ' // trim ( ds % advance ) // ', set to \"YES\"' ) end subroutine check_settings","tags":"","url":"proc/check_settings.html"},{"title":"copyseptobox – M_display","text":"public  subroutine copyseptobox(sep, m, lin1, boxp, wleft) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: sep integer, intent(in) :: m integer, intent(in) :: lin1 character(len=1), intent(inout) :: boxp (:,:) integer, intent(inout) :: wleft Source Code subroutine copyseptobox ( sep , m , lin1 , boxp , wleft ) ! Copy column separator to boxp; update wleft character ( * ), intent ( in ) :: sep integer , intent ( in ) :: m , lin1 character , intent ( inout ) :: boxp (:,:) integer , intent ( inout ) :: wleft integer i , j forall ( i = 1 : len ( sep ), j = 1 : m ) boxp ( wleft + i , j + lin1 - 1 ) = sep ( i : i ) wleft = wleft + len ( sep ) end subroutine copyseptobox","tags":"","url":"proc/copyseptobox.html"},{"title":"copytobox – M_display","text":"public  subroutine copytobox(s, lin1, widj, widpj, nblj, boxp, wleft) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (:) integer, intent(in) :: lin1 integer, intent(in) :: widj integer, intent(in) :: widpj integer, intent(in) :: nblj character(len=1), intent(inout) :: boxp (:,:) integer, intent(inout) :: wleft Source Code subroutine copytobox ( s , lin1 , widj , widpj , nblj , boxp , wleft ) ! Copy strings to column in boxp; update wleft to current char column in boxp character ( * ), intent ( in ) :: s (:) ! the strings to copy integer , intent ( in ) :: lin1 , widj ! first line in box to copy to, width of column integer , intent ( in ) :: nblj , widpj ! number of blank characters to trim from left of s, offset to next col character , intent ( inout ) :: boxp (:,:) ! the box to accept the column integer , intent ( inout ) :: wleft ! number of char-columns in box already written to integer i , j wleft = wleft + widpj - widj forall ( i = 1 : widj , j = 1 : size ( s )) boxp ( wleft + i , j + lin1 - 1 ) = s ( j )( i + nblj : i + nblj ) wleft = wleft + widj end subroutine copytobox","tags":"","url":"proc/copytobox.html"},{"title":"disp_errmsg – M_display","text":"public  subroutine disp_errmsg(s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Source Code subroutine disp_errmsg ( s ) character ( * ), intent ( in ) :: s integer wleft character ( 1 ), pointer :: boxp (:,:) wleft = 0 call newbox ( DEFAULT_UNIT , 1 , len ( s ), boxp ) call copytobox ([ s ], lin1 = 1 , widj = len ( s ), widpj = len ( s ), nblj = 0 , boxp = boxp , wleft = wleft ) call dispboxlist ( DEFAULT_UNIT , sep = '' ) end subroutine disp_errmsg","tags":"","url":"proc/disp_errmsg.html"},{"title":"find_editdesc_real – M_display","text":"public  subroutine find_editdesc_real(exp, expm, dmx, edesc, flen, ndec, posit) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: exp integer, intent(in) :: expm integer, intent(in) :: dmx character(len=14), intent(out) :: edesc integer, intent(out) :: flen integer, intent(out) :: ndec logical, intent(in) :: posit Source Code subroutine find_editdesc_real ( exp , expm , dmx , edesc , flen , ndec , posit ) ! Subroutine of find_editdesc_sngl and find_editdesc_dble integer , intent ( in ) :: expm , dmx integer , intent ( inout ) :: exp character ( 14 ), intent ( out ) :: edesc integer , intent ( out ) :: flen , ndec logical , intent ( in ) :: posit integer :: neg , nxp exp = max ( exp , expm ) neg = 1 if ( exp < dmx . and . exp >= - 1 ) then if ( posit . or . exp > max ( 0 , expm )) neg = 0 edesc = '(SS,Fxx.yy)' ndec = max ( 0 , dmx - exp - 1 ) flen = neg + 2 + ndec + max ( 0 , exp ) ! -X.YYYYY (2 covers X and .) write ( edesc ( 6 : 10 ), '(SS,I2,\".\",I2)' ) flen , ndec else if ( posit ) neg = 0 if ( abs ( exp ) > 999 ) then ; nxp = 4 elseif ( abs ( exp ) > 99 ) then ; nxp = 3 elseif ( abs ( exp ) > 9 ) then ; nxp = 2 else ; nxp = 1 endif flen = neg + 3 + dmx + nxp edesc = '(SS,ESxx.yyEz)' write ( edesc ( 7 : 13 ), '(SS,I2,\".\",I2,\"E\",I1)' ) flen , dmx - 1 , nxp ndec = dmx - 1 endif end subroutine find_editdesc_real","tags":"","url":"proc/find_editdesc_real.html"},{"title":"finishbox – M_display","text":"public  subroutine finishbox(title, SE, boxp) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title type( settings ), intent(in) :: SE character(len=1), intent(inout) :: boxp (:,:) Source Code subroutine finishbox ( title , SE , boxp ) ! Finish creating a box and display it if advancing is turned on character ( * ), intent ( in ) :: title ! The title to use for the matrix type ( settings ), intent ( in ) :: SE ! Settings character , intent ( inout ) :: boxp (:,:) ! The box ! integer i , wt , w , wpadright , wpadleft ! index, width of title, width of box and spacing on either side of it integer lin1 ! line to put left title ! wt = len ( title ) w = size ( boxp , 1 ) if ( upper ( SE % tsty ) == 'LEFT' ) then lin1 = 1 if ( number_cols ( SE )) lin1 = min ( 2 , size ( boxp , 2 )) forall ( i = 1 : wt ) boxp ( i , lin1 ) = title ( i : i ) else wpadright = ( w - wt ) / 2 wpadleft = w - wpadright - wt forall ( i = 1 : wt ) boxp ( wpadleft + i , 1 ) = title ( i : i ) if ( upper ( SE % tsty ) == 'PAD' ) then boxp ( 1 : wpadleft , 1 ) = SE % tch boxp ( w - wpadright + 1 : w , 1 ) = SE % tch else ! tsty == 'UNDERLINE' boxp (:, 2 ) = SE % tch endif endif if ( SE % adv >= 1 ) call dispboxlist ( SE % lun , DEFSET % matsep ( 1 : DEFSET % matseplen )) if ( SE % adv >= 2 ) call dispnewline ( SE % lun ) end subroutine finishbox","tags":"","url":"proc/finishbox.html"},{"title":"get_SE – M_display","text":"public  subroutine get_SE(SE, title, shapex, fmt, advance, lbound, separator, style, trim, unit, orient, zeroas, digmax) Arguments Type Intent Optional Attributes Name type( settings ), intent(out) :: SE character(len=*), intent(in) :: title integer, intent(in) :: shapex (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: separator character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient character(len=*), intent(in), optional :: zeroas integer, intent(in), optional :: digmax Source Code subroutine get_SE ( SE , title , shapex , fmt , advance , lbound , separator , style , trim , unit , orient , zeroas , digmax ) ! Get the settings from the optional parameters fmt...zeroas in to the structure SE. ! Replace absent arguments with corresponding values from the structure DEFSET. type ( settings ), intent ( out ) :: SE character ( * ), intent ( in ) :: title integer , intent ( in ) :: shapex (:) character ( * ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: unit , digmax , lbound (:) character ( * ), intent ( in ), optional :: advance , separator , style , zeroas , trim , orient logical ok ! character ( 22 ) ed character ( 9 ) sep , tsty , zas character ( 1 ) tch character ( 6 ) advchr integer lun , dmx , w , d , lsep , lzas , m1 , n1 , adv logical trm , number , vec , row , is_scalar , gedit ! vec = ( size ( shapex ) == 1 ) is_scalar = size ( shapex ) == 0 if ( vec . and . present ( orient )) then select case ( upper ( orient )) case ( 'ROW' ); row = . true . case ( 'COL' ); row = . false . case default ; ! do not use trim(3f), as using trim as an argument name call disp_errmsg ( 'DISP: error, wrong value of orient: ' // orient (: len_trim ( orient )) // ', using \"COL\"' ) row = . false . end select elseif ( vec ) then row = DEFSET % orient == 'ROW' else row = . false . endif if ( present ( fmt )) then call readfmt ( fmt , ed , w , d , gedit ) else ed = '()' w = - 1 ; d = 0 ; gedit = . false . endif if ( present ( unit )) then lun = unit else lun = DEFSET % unit endif if (. not . present ( digmax )) then dmx = DEFSET % digmax elseif ( present ( fmt )) then call disp_errmsg ( 'DISP: error, both FMT and DIGMAX present, ignoring DIGMAX' ) dmx = 1 elseif ( digmax < 1 . or . digmax > 89 ) then call disp_errmsg ( 'DISP: error, digmax must be >= 1 and < 90, using 6' ) dmx = 6 else dmx = digmax endif if ( present ( advance )) then advchr = upper ( advance ) else advchr = DEFSET % advance endif select case ( trims ( advchr )) case ( 'NO' ); adv = 0 case ( 'YES' ); adv = 1 case ( 'DOUBLE' ); adv = 2 case default call disp_errmsg ( 'DISP: error, illegal advance: ' // trims ( advance ) // ', using \"YES\"' ) adv = 1 end select if ( present ( trim )) then if ( upper ( trim ) /= 'YES' . and . upper ( trim ) /= 'NO' . and . upper ( trim ) /= 'AUTO' ) then call disp_errmsg ( 'DISP: error, illegal trim: ' // trims ( trim ) // ', using \"YES\"' ) trm = . true . else trm = upper ( trim ) == 'YES' . or . upper ( trim ) == 'AUTO' . and . . not . present ( FMT ) endif elseif ( w == 0 ) then trm = . true . else trm = DEFSET % trim == 'YES' . or . DEFSET % trim == 'AUTO' . and . . not . present ( FMT ) endif if ( present ( separator )) then sep = separator lsep = len ( separator ) else sep = DEFSET % sep lsep = DEFSET % seplen endif if ( present ( style )) then call getstyles ( style , tsty , tch , number , ok ) if (. not . ok ) call disp_errmsg ( 'DISP: error, illegal style: ' // style // '. Using default instead' ) else call getstyles ( DEFSET % style , tsty , tch , number , ok ) endif if ( title == '' ) tsty = 'LEFT' if ( is_scalar ) number = . false . if ( present ( zeroas )) then zas = zeroas lzas = len ( zeroas ) else zas = DEFSET % zeroas lzas = DEFSET % zaslen endif if ( w > 0 ) lzas = min ( w , lzas ) zas = zas ( 1 : lzas ) m1 = 1 n1 = 1 if ( present ( lbound )) then number = . true . if ( size ( lbound ) == 1 ) then if ( vec . and . row ) then n1 = lbound ( 1 ) else m1 = lbound ( 1 ) endif elseif ( size ( lbound ) >= 2 ) then m1 = lbound ( 1 ) n1 = lbound ( 2 ) endif endif SE = settings ( ed , sep , tsty , zas , tch , lun , dmx , w , d , lsep , lzas , m1 , n1 , adv , trm , number , vec , row , gedit ) contains function trims ( s ) result ( t ) character ( * ), intent ( in ) :: s character ( len_trim ( s )) :: t intrinsic trim t = trim ( s ) end function trims end subroutine get_SE","tags":"","url":"proc/get_se.html"},{"title":"preparebox – M_display","text":"public  subroutine preparebox(title, SE, m, n, wid, widp, lin1, wleft, boxp) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title type( settings ), intent(in) :: SE integer, intent(in) :: m integer, intent(in) :: n integer, intent(inout) :: wid (:) integer, intent(out) :: widp (:) integer, intent(out) :: lin1 integer, intent(out) :: wleft character(len=1), pointer :: boxp (:,:) Source Code subroutine preparebox ( title , SE , m , n , wid , widp , lin1 , wleft , boxp ) ! Determine format to use to write matrix to box and row where matrix begins, copy character ( * ), intent ( in ) :: title ! The title to use for the matrix type ( settings ), intent ( in ) :: SE ! Settings integer , intent ( in ) :: m ! Row count of matrix integer , intent ( in ) :: n ! Column count of matrix integer , intent ( inout ) :: wid (:) ! widths of columns in matrix integer , intent ( out ) :: widp (:) ! widths of columns in box (max(wid, width of col nums)) integer , intent ( out ) :: lin1 ! Row number where matrix begins (tsty='left' 0, 'pad' 1, 'underline' 2) integer , intent ( out ) :: wleft ! Number of spaces on left of matrix (when tsty is left or title long) character , pointer :: boxp (:,:) ! The box integer wt , wa ! Char count of title, idth of matrix in characters (wbox = lm + wa + rm) integer wbox , wrow ! Width of box in characters, width of row numbers in characters integer lm ! Left margin integer h , ws ! Height of box in characters, length of column separator integer m1 , n1 , i ! lower bounds (for numbering), index character ( range ( 0 ) + 2 ) sn ( 2 ), row_nums ( m ), col_nums ( n ) character ( 10 ) fmt ! ----------wbox---------    -----------wbox----------     -----wbox------ ! ---lm---                   --wleft-                             --wt- ! ----wleft---                lm wrow    wa       rm       wrow    wa !    wt   wrow    wa         ----====-----------======     ----=========== ! --------====-----------    THIS-IS-A-VERY-LONG-TITLE            TITLE !               1     2                1     2                   1     2 ! MATRIX = 1   4.50  6.80         1   4.50  6.80            1   4.50  6.80 !          2   6.88  9.22         2   6.88  9.22            2   6.88  9.22 !          3  19.44  0.08         3  19.44  0.08            3  19.44  0.08 !          ...                    ...                       ... !         10   6.18  4.22        10   6.18  4.22           10   6.18  4.22 ! rm = 0                     wt = wbox                     lm = rm = 0, wleft = wrow m1 = SE % m1 n1 = SE % n1 ws = SE % lsep wt = len ( title ) wrow = 0 widp = wid if ( SE % number ) then fmt = '(SS,I0)' if ( number_cols ( SE )) then write ( col_nums , fmt ) [ ( i , i = n1 , n1 + n - 1 ) ] widp = max ( wid , len_trim ( col_nums )) endif if ( number_rows ( SE )) then write ( sn , fmt ) m1 , m1 + m - 1 wrow = maxval ( len_trim ( sn )) + ws ! determine max width of row numbers call replace_w ( fmt , wrow - ws ) ! to create e.g. 'I5' from 'I0' write ( row_nums , fmt ) [ ( i , i = m1 , m1 + m - 1 ) ] endif endif wa = max ( 0 , n - 1 ) * ws + sum ( widp ) select case ( upper ( SE % tsty )) case ( 'LEFT' ); lin1 = 1 ; wbox = wt + wrow + wa ; h = max ( 1 , m ); lm = wt case ( 'PAD' ); lin1 = 2 ; wbox = max ( wt , wa + wrow ); h = m + 1 ; lm = max ( 0 , ( wt - wa - wrow ) / 2 ) case ( 'UNDERLINE' ); lin1 = 3 ; wbox = max ( wt , wa + wrow ); h = m + 2 ; lm = max ( 0 , ( wt - wa - wrow ) / 2 ) case default ; lin1 = 1 ; wbox = 0 ; h = 0 ; lm = 0 ! should not happen end select wleft = lm if ( number_cols ( SE )) h = h + 1 call newbox ( SE % lun , h , wbox , boxp ) if ( number_cols ( SE )) then call copycolumnnumberstobox ( col_nums , wleft + wrow , wid , widp , ws , boxp , lin1 ) endif if ( number_rows ( SE )) then call copytobox ( row_nums , lin1 , wrow - ws , wrow - ws , nblj = 0 , boxp = boxp , wleft = wleft ) call copyseptobox ( SE % sep ( 1 : SE % lsep ), m , lin1 , boxp , wleft ) endif end subroutine preparebox","tags":"","url":"proc/preparebox.html"},{"title":"readfmt – M_display","text":"public pure subroutine readfmt(fmt, fmt1, w, d, gedit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fmt character(len=*), intent(out) :: fmt1 integer, intent(out) :: w integer, intent(out) :: d logical, intent(out) :: gedit Source Code pure subroutine readfmt ( fmt , fmt1 , w , d , gedit ) ! Returns w and d when fmt is (Xw.d) or (Xw) (then d = 0), X = edit descriptor letter ! (I, F, etc). X can also be ES, DS, 1PG or 1PF. Returns w = -1 for illegal fmt. ! Returns gedit = .true. if fmt is Gw.d. How about SS,1PES4.3? character ( * ), intent ( in ) :: fmt ! e.g. fmt = F 8.2 character ( * ), intent ( out ) :: fmt1 ! returns '(SS,F8.2)' character ch integer , intent ( out ) :: w , d logical , intent ( out ) :: gedit integer :: k0 , k1 , k2 , k3 , k4 call sszipfmt ( fmt , fmt1 ) w = - 1 ; d = 0 ; gedit = . false . k1 = verify ( fmt1 ( 2 :), '0123456789' ) + 1 if ( k1 == 0 ) return ! only digits k2 = verify ( fmt1 ( k1 :), 'ABDEFGILNOPSZabdefgilnopsz,' ) + k1 - 1 ! , for \"1P,G12.3\" if ( k2 <= k1 ) return ! no letter or only letters ch = upper ( fmt1 ( k2 - 1 : k2 - 1 )) if ( ch == ',' ) then ! deal with SS,1PG13.5 k0 = k2 k1 = verify ( fmt1 ( k0 :), '0123456789' ) + k0 - 1 if ( k1 == 0 ) return k2 = verify ( fmt1 ( k1 :), 'ABDEFGILNOPSZabdefgilnopsz,' ) + k1 - 1 if ( k2 <= k1 ) return ch = upper ( fmt1 ( k2 - 1 : k2 - 1 )) endif gedit = ch == 'G' . or . ch == 'g' k3 = verify ( fmt1 ( k2 :), '0123456789' ) + k2 - 1 if ( k3 == k2 ) return ! no digits read ( fmt1 ( k2 : k3 - 1 ), * ) w if ( k3 > len ( fmt1 )) return if ( fmt1 ( k3 : k3 ) /= '.' ) return ! not . after w k4 = verify ( fmt1 ( k3 + 1 :), '0123456789' ) + k3 if ( k4 == k3 + 1 ) return ! no digits read ( fmt1 ( k3 + 1 : k4 - 1 ), * ) d end subroutine readfmt","tags":"","url":"proc/readfmt.html"},{"title":"replace_w – M_display","text":"public pure subroutine replace_w(fmt, wnew) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: fmt integer, intent(in) :: wnew Source Code pure subroutine replace_w ( fmt , wnew ) ! Change e.g. '(F0.3)' to '(F5.3)'. Works also for '(SS,I0)' to '(SS,I5)'. If wnew > 999, set it to 999 character ( * ), intent ( inout ) :: fmt integer , intent ( in ) :: wnew integer :: k0 , k1 , k2 , k3 character ( 3 ) rw k1 = verify ( fmt ( 2 :), '0123456789' ) + 1 k2 = verify ( fmt ( k1 :), 'ABDEFGILNOPSZabdefgilnopsz,' ) + k1 - 1 if ( k2 == k1 ) return ! no letter if ( fmt ( k2 - 1 : k2 - 1 ) == ',' ) then ! Handle (SS,1PF10.3) k0 = k2 k1 = verify ( fmt ( k0 :), '0123456789' ) + 1 if ( k1 == 0 ) return k2 = verify ( fmt ( k1 :), 'ABDEFGILNOPSZabdefgilnopsz,' ) + k1 - 1 if ( k2 <= k1 ) return endif k3 = verify ( fmt ( k2 :), '0123456789' ) + k2 - 1 if ( k3 == k2 ) return ! no digits write ( rw , '(SS,I0)' ) min ( 999 , wnew ) fmt = fmt ( 1 : k2 - 1 ) // trim ( rw ) // fmt ( k3 :) end subroutine replace_w","tags":"","url":"proc/replace_w.html"},{"title":"replace_zeronaninf – M_display","text":"public  subroutine replace_zeronaninf(s, zas, maskz, masknan, maskminf, maskinf) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: s (:) character(len=*), intent(in) :: zas logical, intent(in) :: maskz (:) logical, intent(in), optional :: masknan (:) logical, intent(in), optional :: maskminf (:) logical, intent(in), optional :: maskinf (:) Source Code subroutine replace_zeronaninf ( s , zas , maskz , masknan , maskminf , maskinf ) ! replace zeros in s (where maskz is true) with zas (i.e. zero-as string) also replace nans with 'NaN', ! infinities with '+Inf' and minus infinities with '-Inf'. Zeros are aligned with . if zas contains . ! otherwise right-adjusted. Nans, and infs are right adjusted. ! NOTE: There are compiler bugs in current versions of both the Absoft and the Pathscale compilers ! so the merge calls (commented out below) had to be replaced with do loops. character ( * ), intent ( inout ) :: s (:) logical , intent ( in ) :: maskz (:), masknan (:), maskinf (:), maskminf (:) character ( * ), intent ( in ) :: zas optional :: masknan , maskminf , maskinf character ( len ( s )) z , nan , minf , inf integer w , wz , n , i , k , zasdot w = len ( s ) wz = len ( zas ) n = size ( maskz ) if ( wz /= 0 . and . wz <= w ) then ! zas not empty and not too wide zasdot = index ( zas , '.' ) z = '' if ( zasdot > 0 ) then do i = 1 , n if ( maskz ( i )) exit enddo if ( i <= n ) then ! some zeros k = index ( s ( i ), '.' ) if ( k == 0 . or . zasdot > k . or . wz - zasdot > w - k ) then ! cannot align .'s z ( w - wz + 1 :) = zas ! align right else z ( k - zasdot + 1 : k - zasdot + wz ) = zas endif endif else z ( w - wz + 1 :) = zas endif ! s = merge(z, s, maskz) do i = 1 , n if ( maskz ( i )) s ( i ) = z enddo endif if ( present ( masknan )) then if ( w >= 4 ) then nan = repeat ( ' ' , w - 4 ) // ' NaN' minf = repeat ( ' ' , w - 4 ) // '-Inf' inf = repeat ( ' ' , w - 4 ) // '+Inf' elseif ( w == 3 ) then nan = 'NaN' minf = '***' inf = 'Inf' else nan = repeat ( '*' , w ) minf = nan inf = nan endif ! s = merge(nan, s, masknan) ! s = merge(minf, s, maskminf) ! s = merge(inf, s, maskinf) do i = 1 , n if ( masknan ( i )) s ( i ) = nan if ( maskminf ( i )) s ( i ) = minf if ( maskinf ( i )) s ( i ) = inf enddo endif end subroutine replace_zeronaninf","tags":"","url":"proc/replace_zeronaninf.html"},{"title":"tostring_check_settings – M_display","text":"public  subroutine tostring_check_settings() Arguments None Source Code subroutine tostring_check_settings ! Sanity check of tostring settings type ( tostring_settings ) ts integer wi , wr , d character ( max ( len ( tosset % rfmt ), len ( tosset % ifmt )) + 5 ) fmt1 logical gedit ts = tosset if ( all ( ts % trimb /= [ 'YES' , 'NO ' ])) tosset % trimb = tosfac % trimb if ( all ( ts % trimz /= [ 'NONE' , 'ALL ' , 'G   ' ])) tosset % trimz = tosfac % trimz call readfmt ( tosset % rfmt , fmt1 , wr , d , gedit ) call readfmt ( tosset % ifmt , fmt1 , wi , d , gedit ) if ( wr < 0 ) tosset % rfmt = tosfac % rfmt if ( wi < 0 ) tosset % ifmt = tosfac % ifmt if ( all ( ts % trimb /= [ 'YES ' , 'NO  ' , 'AUTO' ])) call disp_errmsg ( & 'TOSTRING_SET: error, illegal trimb: ' // trim ( ts % trimb ) // ', set to ' // trim ( tosfac % trimb )) if ( all ( ts % trimz /= [ 'NONE' , 'ALL ' , 'G   ' ])) call disp_errmsg ( & 'TOSTRING_SET: error, illegal trimz: ' // trim ( ts % trimz ) // ', set to ' // trim ( tosfac % trimz )) if ( wr < 0 ) call disp_errmsg ( & 'TOSTRING_SET: error, illegal rfmt: ' // trim ( ts % rfmt ) // ', set to ' // trim ( tosfac % rfmt )) if ( wi < 0 ) call disp_errmsg ( & 'TOSTRING_SET: error, illegal ifmt: ' // trim ( ts % ifmt ) // ', set to ' // trim ( tosfac % ifmt )) end subroutine tostring_check_settings","tags":"","url":"proc/tostring_check_settings.html"},{"title":"tostring_get – M_display","text":"public pure subroutine tostring_get(sa, st) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: sa (:) character(len=*), intent(out) :: st Source Code pure subroutine tostring_get ( sa , st ) ! Copy trimmed elements of sa (containing individual elements as strings) to the final ! tostring result st, separated by tosset % sep strings. character ( * ), intent ( in ) :: sa (:) character ( * ), intent ( out ) :: st integer :: i , k , n , sepl sepl = tosset % seplen k = 0 do i = 1 , size ( sa ) if ( k > 0 ) st ( k + 1 : k + sepl ) = tosset % sep ( 1 : sepl ) if ( k > 0 ) k = k + sepl n = len_trim ( sa ( i )) st ( k + 1 : k + n ) = trim ( sa ( i )) k = k + n enddo end subroutine tostring_get","tags":"","url":"proc/tostring_get.html"},{"title":"tostring_get_complex – M_display","text":"public pure subroutine tostring_get_complex(sar, sgn, sai, st) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: sar (:) character(len=*), intent(in) :: sgn (*) character(len=*), intent(in) :: sai (:) character(len=*), intent(out) :: st Source Code pure subroutine tostring_get_complex ( sar , sgn , sai , st ) ! Version of tostring_get for complex numbers character ( * ), intent ( in ) :: sar (:), sai (:), sgn ( * ) character ( * ), intent ( out ) :: st integer :: i , k , n , sepl sepl = tosset % seplen k = 0 do i = 1 , size ( sar ) if ( k > 0 ) st ( k + 1 : k + sepl ) = tosset % sep ( 1 : sepl ) if ( k > 0 ) k = k + sepl n = len_trim ( sar ( i )) st ( k + 1 : k + n ) = trim ( sar ( i )) st ( k + n + 1 : k + n + 3 ) = ' ' // sgn ( i ) // ' ' k = k + n + 3 n = len_trim ( sai ( i )) st ( k + 1 : k + n ) = trim ( sai ( i )) st ( k + n + 1 : k + n + 1 ) = 'i' k = k + n + 1 enddo end subroutine tostring_get_complex","tags":"","url":"proc/tostring_get_complex.html"},{"title":"trim_real – M_display","text":"public pure subroutine trim_real(sa, gedit, w) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: sa (:) logical, intent(in) :: gedit integer, intent(in) :: w Source Code pure subroutine trim_real ( sa , gedit , w ) ! Trim trailing zeros and possibly decimal point from fractional part. ! If sa = '52.2000E12' on entry then it is returned as '52.2E12   '. ! Whether trimming is actually done depends on tosset, gedit and w. character ( * ), intent ( inout ) :: sa (:) logical , intent ( in ) :: gedit integer , intent ( in ) :: w integer i if ( tosset % trimb == 'YES' . or . w == 0 ) sa = adjustl ( sa ) if ( tosset % trimz == 'ALL' . or . tosset % trimz == 'G' . and . gedit ) then do i = 1 , size ( sa ) ! trim trailing zeros from fractional part call trim_s_real ( sa ( i ), gedit , w ) enddo endif end subroutine trim_real","tags":"","url":"proc/trim_real.html"},{"title":"trim_s_real – M_display","text":"public pure subroutine trim_s_real(sa, gedit, w) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: sa logical, intent(in) :: gedit integer, intent(in) :: w Source Code pure subroutine trim_s_real ( sa , gedit , w ) ! Trim trailing zeros and possibly decimal point from fractional part. ! If sa = '52.2000E12' on entry then it is returned as '52.2E12   '. ! Whether trimming is actually done depends on tosset, gedit and w. character ( * ), intent ( inout ) :: sa logical , intent ( in ) :: gedit integer , intent ( in ) :: w integer k , k2 , k3 if ( tosset % trimb == 'YES' . or . w == 0 ) sa = adjustl ( sa ) if ( tosset % trimz == 'ALL' . or . tosset % trimz == 'G' . and . gedit ) then k = scan ( sa , '.' ) if ( k > 0 ) then k2 = verify ( sa ( k + 1 :), '0123456789' ) + k if ( k2 == k ) k2 = len ( sa ) + 1 k3 = verify ( sa ( k : k2 - 1 ), '0.' , back = . true .) + k - 1 sa ( k3 + 1 :) = sa ( k2 :) endif endif end subroutine trim_s_real","tags":"","url":"proc/trim_s_real.html"},{"title":"disp_get – M_display","text":"public  function disp_get() result(defs) NAME disp_get(3f) - [M_display] return default settings in a structure of\n                DISP(3f) settings DESCRIPTION The argumentless function DISP_GET returns the current default settings\n in a structure of type DISP_SETTINGS. If a subroutine changes the default\n settings with DISP_SET it is possible to save the settings that are in\n effect when the routine is entered, and restore these settings before\n returning from the routine. EXAMPLE An example is: program demo_disp_get real :: xx ( 2 , 3 ), yy ( 2 , 3 ) xx ( 1 ,:)=[ 1.0 , 6.0 , 5.0 ] xx ( 2 ,:)=[ 2.4 , 4.0 , 6.0 ] yy ( 1 ,:)=[ 0.0 , 3.5 , 2.0 ] yy ( 2 ,:)=[ 7.0 , 4.0 , 8.22 ] call disp_xy ( xx , yy ) contains subroutine disp_xy ( x , y ) use M_display real x (:,:), y (:,:) type ( disp_settings ) ds ds = disp_get () call disp_set ( digmax = 4 , sep = ',' ) call disp ( ' x = ' , x ) write ( * , * ) call disp ( ' y = ' , y ) call disp_set ( ds ) end subroutine disp_xy end program demo_disp_get Expected: x=1.000,6.000,5.000\n  2.400,4.000,6.000\n\ny=0.000,3.500,2.000\n  7.000,4.000,8.220 AUTHOR Based on dispmodule ( 3 f ), \"A Fortran 95 module for pretty-printing matrices\" . Version number 1.02 6 - Sept - 2008 , Kristjan Jonasson , Dept . of Computer Science , University of Iceland ( jonasson @hi . is ). Arguments None Return Value type( disp_settings ) Source Code function disp_get () result ( defs ) ! Return current display settings type ( disp_settings ) :: defs defs = DEFSET end function disp_get","tags":"","url":"proc/disp_get.html"},{"title":"disp_set – M_display","text":"public  subroutine disp_set(advance, digmax, matsep, orient, sep, style, unit, zeroas) NAME disp_set ( 3 f ) - [ M_display ] set default options for disp ( 3 f ) DESCRIPTION The subroutine DISP_SET may be used to change default values of all\n the arguments of DISP except TITLE, X, FMT and LBOUND. In addition the\n default separator between items that are displayed side-by-side (using\n ADVANCE=’no’) may be changed with the MATSEP argument. THE DERIVED TYPE DISP_SETTINGS M_display contains the following definition of the data type DISP_SETTINGS. type disp_settings character ( 3 ) :: advance = ' YES ' character ( 9 ) :: matsep = ' ' character ( 3 ) :: orient = ' COL ' character ( 9 ) :: sep = ' ' character ( 19 ) :: style = ' LEFT ' character ( 4 ) :: trim = ' AUTO ' character ( 9 ) :: zeroas = '' integer :: digmax = 6 integer :: matseplen = 3 integer :: seplen = 2 integer :: unit = - 3 integer :: zaslen = 0 end type disp_settings Structures of type DISP_SETTINGS may be used to save and later restore\n format control settings of DISP. As shown, new variables of this type\n will automatically have default values for all components. CALLING SYNTAX FOR DISP_SET There are two ways to call DISP_SET: call disp_set(settings)\n   call disp_set(advance, digmax, matsep, orient, sep, style, unit, zeroas) Both calls change the default format control used in subsequent calls\n to DISP. In the first call, SETTINGS is of type DISP_SETTINGS and the\n default values for all arguments is changed. In the second call all\n the arguments are optional. If an argument is absent the corresponding\n default setting is not changed. An example call is call disp_set(style = 'pad', sep = ' '). The effect is that titles will be written padded above matrices, and\n matrix column will be separated by one blank. The type and purpose of\n all the arguments except MATSEP has been described in section 3.2. MATSEP = ms  Specifies a character string of length <= 9 that is written\n              out between items (matrices) when they are displayed\n              side-by-side. An example is: call disp(x, advance='no')\n               call disp(y, advance='no')\n               call disp_set(matsep=' | ')\n               call disp(z, advance='yes')\n\n          The output from these calls might be:\n\n               12.2 |  1.3 | 1\n                9.6 | 13.0 | 3\n               -2.0 |  4.0 | 4\n\n          Note that MATSEP affects the separation of all items that\n          have been placed in the output queue of the unit being\n          displayed on. AUTHOR Based on dispmodule(3f),\n   “A Fortran 95 module for pretty-printing matrices”.\n   Version number 1.02 6-Sept-2008,\n   Kristjan Jonasson, Dept. of Computer Science,\n   University of Iceland (jonasson@hi.is). Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: matsep character(len=*), intent(in), optional :: orient character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas Source Code subroutine disp_set ( advance , digmax , matsep , orient , sep , style , unit , zeroas ) ! Change display settings according to individual parameters character ( * ), optional , intent ( in ) :: advance , sep , matsep , orient , style , zeroas integer , optional , intent ( in ) :: digmax , unit if ( present ( advance )) DEFSET % advance = upper ( advance ) if ( present ( sep )) DEFSET % sep = sep if ( present ( sep )) DEFSET % seplen = min ( 9 , len ( sep )) if ( present ( zeroas )) DEFSET % zeroas = zeroas if ( present ( zeroas )) DEFSET % zaslen = min ( 9 , len ( zeroas )) if ( present ( matsep )) DEFSET % matsep = matsep if ( present ( matsep )) DEFSET % matseplen = min ( 9 , len ( matsep )) if ( present ( orient )) DEFSET % orient = upper ( orient ) if ( present ( style )) DEFSET % style = style if ( present ( digmax )) DEFSET % digmax = digmax if ( present ( unit )) DEFSET % unit = unit call check_settings end subroutine disp_set","tags":"","url":"proc/disp_set.html"},{"title":"disp_set_factory – M_display","text":"public  subroutine disp_set_factory() NAME disp_set_factory ( 3 f ) - [ M_display ] set DISP ( 3 f ) output back to original defaults DESCRIPTION The subroutine disp_set_factory (which has no arguments) may be called\nto restore all settings of DISP(3f) to the original default values. AUTHOR Based on dispmodule(3f),\n   “A Fortran 95 module for pretty-printing matrices”.\n   Version number 1.02 6-Sept-2008,\n   Kristjan Jonasson,\n   Dept. of Computer Science, University of Iceland (jonasson@hi.is). Arguments None Source Code subroutine disp_set_factory () ! Change display settings to the original default DEFSET = FACTORY_SETTINGS end subroutine disp_set_factory","tags":"","url":"proc/disp_set_factory.html"},{"title":"tostring_set – M_display","text":"public  subroutine tostring_set(sep, rfmt, ifmt, trimb, trimz) NAME tostring_set ( 3 f ) - [ M_display ] set modes for TOSTRING ( 3 f ) DESCRIPTION The subroutine TOSTRING_SET has five arguments, all of which are\n optional. Argument association will normally be realized using argument\n keywords, e.g. CALL TOSTRING_SET(SEP=’; ‘). The examples in section 5.4\n clarify how to use this subroutine. The five arguments are: SEP     Character string used to separate elements of displayed\n         vectors. Original default value is ‘, ‘. RFMT    Character string containing default edit descriptor to use to\n         display real items. The original default value is ‘1PG12.5’ IFMT    Character string containing default edit descriptor to use to\n         display integer items. The original default value is ‘I0’. TRIMB   Controls whether leading and trailing blanks are trimmed from\n         individual displayed elements. Possible values are ‘YES’\n         (to trim blanks) and ‘NO’ (for no trimming). Default is ‘YES’. TRIMZ   Controls whether trailing zeros are trimmed from the fractional\n         part of displayed items. Possible values are ‘NONE’ (for no\n         zero trimming), ‘G’ (to trim fractional trailing zeros only when\n         G editing is used), and ‘ALL’ (to trim zeros with all types\n         of editing). Trailing decimal points are also removed when\n         zero-trimming is active. Default value is ‘G’. EXAMPLES When the original (factory) defaults are in effect, the result of invoking\n TOSTRING will usually be as follows. Invocation                             Returned String\n ----------                             ---------------\n tostring(atan(1.0))                    '0.785398'\n tostring(exp([-3.,-1.,0.,1.]))         '4.97871E-02, 0.36788, 1, 2.7183'\n tostring(real([(i,i=1,5)])**8)         '1, 256, 6561, 65536, 3.90625E+05'\n tostring([1.23456,1.2300,1.23456e6])   '1.2346, 1.23, 1.23456E+06'\n tostring(real([(i,i=1,5)])**8,'f0.1')  '1.0, 256.0, 6561.0, 65536.0, 390625.0'\n tostring(real([(i,i=1,5)])**8,'f6.1')  '1.0, 256.0, 6561.0, ******, ******'\n tostring([1200000.,-1.2e-9])           '1.2E+06, -1.2E-09'\n !\n tostring(1.200d103)                    '1.2+103'\n tostring([1.1d0,2.2d10,3.3d20])        '1.1E+00, 2.2E+10, 3.3E+20'\n !\n tostring(-77)                          '-77'\n tostring([(i,i=-3,3)]**11)             '-177147, -2048, -1, 0, 1, 2048, 177147'\n tostring([(i,i=-3,3)]**11, 'i7')       '-177147, -2048, -1, 0, 1, 2048, 177147'\n tostring([(i,i=-3,3)]**11, 'i4')       '****, ****, -1, 0, 1, 2048, ****'\n !\n tostring((1,3)/(4,2))                  '0.5 + 0.5i'\n tostring(cmplx([-1,-2])**0.25)       '0.70711 + 0.70711i, 0.8409 + 0.8409i'\n !\n tostring([.true., .false., .false.])   'T, F, F'\n tostring(.true., 'L2')                 'T' The returned strings may be slightly different from the ones shown,\n because some compilers (at least some versions of g95) will produce one\n more decimal place in a few cases, and because the Fortran standard allows\n G editing to give exponent fields in the form 0dd instead of Edd. The\n examples make use of brackets to construct vector constants (a Fortran\n 2003 feature). If the compiler being used does not support this, [ and\n ] must be used instead. Notice that trimming is on by default so there\n is not much purpose in specifying the format for integers and logicals.\n Notice also that (usually) 5 significant digits are displayed when the\n default G editing results in F edited output, but 6 digits for the numbers\n of small or large magnitude, displayed with E editing. This discrepancy\n is present in the Fortran standard; the presence of the scale factor 1P in\n the edit descriptor increases the number of displayed significant digits. Examples of using TOSTRING_SET follow (again the returned string may be\n slightly different). Invocation                              Returned String\n   ----------                              ---------------\n   call tostring_set(sep=';')\n   tostring([1,2,30])                      '1;2;30'\n   !\n   call tostring_set(trimb='NO')\n   tostring(real([(i,i=1,5)])**8,'f6.1')   '   1.0; 256.0;6561.0;******;******'\n   tostring([1,2,30],'i3')                 '  1;  2; 30'\n   tostring([(i,i=-3,3)]**11, 'i4')        '****;****;  -1;   0;   1;2048;****'\n   tostring([1,2,30],'i0')                 '1;2;30'\n   tostring(.true.,'L3')                   '  T'\n   !\n   call tostring_set(trimz='NONE',sep=', ',trimb='YES')\n   tostring(real([(i,i=1,4)])**8)          '1.0000, 256.00, 6561.0, 65536.'\n   tostring([1.23456,1.2300,1.23456e6])    '1.2346, 1.2300, 1.23456E+06'\n   tostring(1.200d103)                     '1.20000+103'\n   !\n   call tostring_set(trimz='ALL')\n   tostring(real([(i,i=1,5)])**8,'f0.1')   '1, 256, 6561, 65536, 390625'\n   !\n   call tostring_set(rfmt='G12.4')\n   tostring(real([(i,i=0,5)])**8)          '1, 256, 6561, 0.6554E+05, 0.3906E+06'\n   tostring([1200000.,-1.2e-9])            '0.12E+07, -0.12E-08'\n   !\n   call tostring_set_factory() AUTHOR Based on dispmodule(3f),\n   “A Fortran 95 module for pretty-printing matrices”.\n   Version number 1.02 6-Sept-2008,\n   Kristjan Jonasson, Dept. of Computer Science,\n   University of Iceland (jonasson@hi.is). Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: rfmt character(len=*), intent(in), optional :: ifmt character(len=*), intent(in), optional :: trimb character(len=*), intent(in), optional :: trimz Source Code subroutine tostring_set ( sep , rfmt , ifmt , trimb , trimz ) character ( * ), optional , intent ( in ) :: sep , rfmt , ifmt , trimb , trimz if ( present ( sep )) tosset % sep = upper ( sep ) if ( present ( sep )) tosset % seplen = min ( 9 , len ( sep )) if ( present ( rfmt )) tosset % rfmt = upper ( rfmt ) if ( present ( ifmt )) tosset % ifmt = upper ( ifmt ) if ( present ( trimb )) tosset % trimb = upper ( trimb ) if ( present ( trimz )) tosset % trimz = upper ( trimz ) call tostring_check_settings end subroutine tostring_set","tags":"","url":"proc/tostring_set.html"},{"title":"tostring_set_factory – M_display","text":"public  subroutine tostring_set_factory() NAME tostring_set_factory ( 3 f ) - [ M_display ] set TOSTRING ( 3 f ) output back to original defaults DESCRIPTION The subroutine TOSTRING_SET_FACTORY (which has no arguments) may be\n called to restore all settings of TOSTRING(3f) to the original default\n values (the factory defaults): SEP=’,’, RFMT = ‘1PG12.5’, IFMT= ‘I0’,\n TRIMB=’YES’ and TRIMZ=’G’. AUTHOR Based on dispmodule(3f),\n   “A Fortran 95 module for pretty-printing matrices”.\n   Version number 1.02 6-Sept-2008,\n   Kristjan Jonasson, Dept. of Computer Science,\n   University of Iceland (jonasson@hi.is). Arguments None Source Code subroutine tostring_set_factory () logical dummy dummy = . false . if ( dummy ) call avoid_compiler_warnings tosset = tosfac end subroutine tostring_set_factory","tags":"","url":"proc/tostring_set_factory.html"},{"title":"disp – M_display","text":"public interface disp NAME disp ( 3 f ) - [ M_display ] pretty - print a matrix DESCRIPTION This is the principal subroutine of the package. It has various control\n arguments that specify the exact format of the output. Most of these\n may also be used as arguments of the subroutine DISP_SET. When used\n with DISP, a control argument affects only the item being displayed with\n the current call, but when used with DISP_SET, the default settings for\n subsequent DISP calls are affected. The default values for individual\n arguments given below are used unless they have been changed by a call\n to DISP_SET. All character arguments should be of type default character. Simple Calls: call disp\n   call disp(x)\n   call disp(title, x)\n   call disp(x, fmt)\n   call disp(title, x, fmt) The first call advances to the next line, and the other calls display X\n on the default unit (the unit may be changed with the UNIT argument). The\n default putstrmodule (see section 2) sets the asterisk unit (usually the\n screen) to be default. The purpose of individual arguments is as follows: X      The item to be displayed. X may be scalar, vector or matrix\n        (i.e. of rank <= 2) and the following kinds of data are supported: default integer\n       default real (or single precision, real(kind(1.0)))\n       double precision real (or real(kind(1d0)))\n       default complex (or complex(kind(1.0)))\n       double precision complex (or complex(kind(1d0)))\n       default logical\n       default character\n\n    With the add-on modules described in section 2.3 other kinds may\n    be displayed. Matrices are displayed in traditional mathematical\n    order, so the rows displayed are X(1,:), X(2,:) etc. Vectors are\n    by default displayed as column vectors (but a row orientation may\n    be specified with the ORIENT argument). An SS edit descriptor is\n    applied automatically so positive elements are not prefixed with\n    a + sign (the Fortran standard makes outputting a + sign optional). TITLE  Provides a label for X. The label prefixes X by default but this\n        may be changed with the STYLE argument (see examples in section\n        3.2). When X is absent TITLE must also be absent. FMT    When present, FMT should contain an edit descriptor that will be\n        used to format each element of X (or the real parts of X in case\n        X is complex and FMT_IMAG is present; see below). The possible\n        edit descriptors are: Fw . d , Dw . d , Ew . dEe , ENw . dEe , ESw . dEe : real data ( the Ee suffixes are optional ) Iw , Bw , Ow , Zw : integer data ( all may be suffixed with . m ) Lw : logical data A , Aw : character data Gw . d , Gw . dEe : any data Example calls for numeric X are CALL DISP ( X , ' ES11 .4 ' ) and CALL DISP ( ' X = ' , X , ' F8 .4 ' ). If X is a scalar string ( i . e . of rank 0 ) and TITLE is absent FMT must be specified with a keyword ( otherwise the call is taken to have TITLE and X ): CALL DISP ( ' str ' , FMT = ' A4 ' ) displays \"str\" but CALL DISP ( ' str ',' A4 ' ) displays \"strA4\" ). If FMT is absent , each element of X is formatted with a default edit descriptor . When X is of type logical the default is L1 and when it is of type character the default is A ( which is equivalent to Aw where w = LEN ( X )). For integer data the default is Iw where w is exactly big enough to accommodate both the largest positive and the largest negative values in X . For real and complex data the default also depends on the largest absolute values in X , as detailed in the DIGMAX - paragraph in section 3.2 . The format used for complex numbers is demonstrated in the introduction above . CALL WITH COMPLETE LIST OF ARGUMENTS CALL DISP(TITLE, X, FMT, FMT_IMAG, ADVANCE, DIGMAX, LBOUND, ORIENT,\n   SEP, STYLE, TRIM, UNIT, ZEROAS) All dummy arguments are optional and some of them are incompatible\n with some data types of X. The arguments control how X is displayed,\n as described in section 3.1 and below. For the character arguments\n ADVANCE and ORIENT the case of letters is ignored (so e.g. ADVANCE =\n ‘yes’ and ADVANCE = ‘YES’ are equivalent). Normally argument association\n for arguments after FMT (or FMT_IMAG) will be realized with argument\n keywords, e.g. CALL DISP(‘X=’, X, DIGMAX=3, ORIENT=’ROW’). When X is a\n scalar string FMT must also be associated with keyword, as mentioned in\n section 3.1. The most useful application of calling DISP with X absent is\n to advance to the next line or display an empty line. For this purpose,\n the only relevant arguments are UNIT, and ADVANCE with the value ‘YES’\n or ‘DOUBLE’. FMT_IMAG = edit-descriptor-imag  An edit descriptor for imaginary parts\n        of complex X. The statement CALL DISP((1.31,2.47),’F0.1’,’F0.2’)\n        will display “1.3 + 2.47i”. If FMT_IMAG is absent and FMT\n        is present then both real and imaginary parts are edited with\n        FMT. If both are absent, separate defaults are used, as explained\n        in the DIGMAX-paragraph below. FMT_IMAG must be absent if X is\n        not complex. ADVANCE = adv  The value for ADVANCE may be ‘yes’, ‘no’ or ‘double’. If\n       the value is ‘yes’ then X is written out immediately, if it is\n       ‘double’ then X is written out followed by an empty line (thus\n       giving double spacing), and if it is ‘no’ then X is not written\n       out until the next DISP call on the same unit with advancing turned\n       on (either by default, via a call to DISP_SET, or via the ADVANCE\n       keyword). When this occurs, all the items displayed with DISP since\n       the last output occurred on the unit are written out side by side,\n       separated by three spaces unless a different separation has been\n       specified via the MATSEP argument of DISP_SET. Default value of\n       ADVANCE is ‘yes’. DIGMAX = n  Controls the format used for real and complex data in the\n       absence of FMT. For real items the format is chosen so that the\n       displayed number of largest absolute magnitude (say xmax) has n\n       significant decimal digits. If 0.1 <= |xmax| < 10**n an F edit\n       descriptor is used, otherwise an E edit descriptor. For complex\n       items these rules are applied separately to the real parts and\n       imaginary parts, and thus two different formats are used. When X\n       is not of real or complex type the argument DIGMAX is ignored. When\n       DIGMAX is present FMT should be absent. The default is n = 6. LBOUND = lbound  This argument is a default integer vector with the\n       numbers of the first row / column to show when displaying with\n       numbered style. When calling subroutines in Fortran, only the\n       shape of matrix arguments is passed with the arguments, but matrix\n       lower bounds are assumed to be 1 unless declared explicitly in\n       the routine. To compensate for this deficiency LBOUND may be\n       set to the declared lower bound(s) of X. To take an example, let\n       aij = exp(i + j - 1) as in section 1, but let A be declared with\n       REAL::A(0:3,0:3). Then CALL DISP(A, STYLE = ‘NUMBER’, LBOUND =\n       LBOUND(A)) will display: >        0       1        2        3\n     >  0   1.000   2.718    7.389   20.086\n     >  1   2.718   7.389   20.086   54.598\n     >  2   7.389  20.086   54.598  148.413\n     >  3  20.086  54.598  148.413  403.429.\n\n   In fact the call may be shortened to CALL DISP(A, LBOUND =\n   LBOUND(A)) because numbering is default when LBOUND is present. ORIENT = ori  This argument can only be used when X is a vector (i.e. has\n       rank 1). If ORIENT is ‘col’ (the default) a column vector is\n       displayed, and if ORIENT is ‘row’ a row vector results. SEP = sep  Specifies a string which is written out between columns of\n       displayed matrices. If X has rows (-1, 3) and (5, 10) and SEP is ‘,\n       ’ then the output will be: >  -1,  5\n     >   5, 10\n\n   The length of the string must be at most 9. Default is '  '\n   (character string with two spaces). STYLE = style  There are five possible styles: 'left'       Title is immediately to the left of the first line\n                of the displayed item.\n   'above'      Title is centered immediately above the item.\n   'pad'        Title is centered above the item, padded with hyphens (-).\n   'underline'  Title is centered above the item, underlined with hyphens.\n   'number'     Each matrix or vector row and / or column is numbered.\n\n   Any of the four title position styles can also be combined with the\n   number style by specifying for example STYLE = 'pad & number'. Any\n   character except space may be used instead of hyphen by prefixing\n   it to the style. STYLE = '*underline' will thus underline the title\n   with asterisks. Both row and column numbers appear for numbered\n   matrices, but for vectors only row numbers appear (or column numbers\n   when ORIENT is 'col'). The five styles are illustrated below,\n   accompanied by an example of combined padded title and numbering. > Matr = 1.2   4.2       Matr      ---Matr--       Matr          1     2     ____Matr____ > 5.6  18.3    1.2   4.2    1.2   4.2    ---------    1  1.2   4.2        1     2 > 5.6  18.3    5.6  18.3    1.2   4.2    2  5.6  18.3    1  1.2   4.2 > 5.6  18.3                    2  5.6  18.3 The default value of STYLE is 'left' if LBOUND is absent, 'number'\n   if it is present, and 'left & number' if both TITLE and LBOUND\n   are present. TRIM = trim  This argument can take three values, ‘YES’, ‘NO’ and\n       ‘AUTO’. When YES is specified, each column of displayed items is\n       trimmed from the left, with ‘NO’ the items are not trimmed and if\n       TRIM is ‘AUTO’ the items are trimmed when FMT is absent but not when\n       it is present. In the following example, X and U are displayed\n       with TRIM = ‘yes’, but Y and V with TRIM = ‘no’. In all cases the\n       edit descriptor is the default (I4). The default is TRIM = ‘AUTO’. > ---- X ---- ------- Y ------ ----- U ----- ------- V ------ > 1 2 4 1 2 3 333 22 4444 333 22 4444 > 2 22 34 2 22 34 > 3 32 1234 3 32 1234 One application of trimming is to display matrices with a fixed number of fractional digits but variable effective field width . Then Fw . d editing with w big enough is accompanied by TRIM = 'yes' . An example is the following display of a matrix with ( i , k ) element exp ( k ** i ) using F20 . 2 and 'yes' : > power exponentials > 2.72 7.39 20.09 > 2.72 54.60 8103.08 Similar output may be obtained using I and F edit descriptors with w = 0 as discussed in section 3.5 . Apart from I and F edited displays , it is possible to trim A - edited displays as well as E - edited displays with some negative elements , but the first column all positive : With TRIM = 'yes' : X = 1.2e+5 - 4.1e-2 With TRIM = 'no' : X = 1.2e+5 - 4.1e-2 2.3e-3 8.6e+1 2.3e-3 8.6e+1 UNIT = external-file-unit  The unit which the output is sent to. There\n       are three special units, which may be referred to either with\n       constants or parameters (named constants) as follows: Constant Parameter Preconnected unit - 3 ASTERISK_UNIT The asterisk unit ( often the screen ) - 2 PUTSTR_UNIT The subroutines PUTSTR and PUTNL - 1 NULL_UNIT Null device ( all output to this is discarded ) These units are further described in sections 3.3 and 3.4 . Other unit numbers correspond to external files that should have been connected with open - statements . The default unit depends on the named constant DEFAULT_UNIT , defined in PUTSTRMODULE . The default PUTSTRMODULE sets it to - 3 ( see sections 2 and 3.4 ) . ZEROAS = zerostring  Supported for integer and real X (not complex)\n       Any element that compares equal to 0 will be displayed as\n       zerostring. If, for example, A is a 4 by 4 upper triangular\n       matrix with aij = 1/max(0,j - i + 1) then CALL DISP(‘A = ‘, A,\n       ‘F0.3’, ZEROAS = ‘0’, ADVANCE = ‘NO’) and CALL DISP(‘B = ‘, A,\n       ‘F0.3’, ZEROAS = ‘.’) will display: A = 1.000  0.500  0.333  0.250   B = 1.000  0.500  0.333  0.250\n               0  1.000  0.500  0.333        .     1.000  0.500  0.333\n               0      0  1.000  0.500        .      .     1.000  0.500\n               0      0      0  1.000        .      .      .     1.000\n\n   Notice that when zerostring contains a decimal point it is lined\n   up with other decimal points in the column. If zerostring has\n   length 0, the default behavior of not treating zeros specially is\n   re-established, in case an earlier DISP_SET call has been used to\n   set ZEROAS. ASTERISK_UNIT AND NULL_UNIT As already mentioned in section 3.2 there are three special units,\n ASTERISK_UNIT = -3, PUTSTR_UNIT = -2 and NULL_UNIT = -1. These public\n named constants (parameters) are defined by M_display. Selecting ASTERISK_UNIT channels all output to the unit that\n WRITE(*,…) statements use. The ISO_FORTRAN_ENV intrinsic module of\n Fortran 2003 defines the named constant OUTPUT_UNIT and this may be\n used instead, unless its value is set to -2 by the compiler (which would\n clash with PUTSTR_UNIT). Selecting NULL_UNIT causes all output via DISP to be discarded. This\n feature makes it simple to turn the output on and off, which may be\n useful for debugging and testing purposes. If UNIT = U is specified\n in all DISP-calls, it is enough to change the value of U to -1 to turn\n off output. PUTSTR_UNIT: Output with user written subroutines One of the purposes of the PUTSTR_UNIT is to make displaying possible in\n situations where ordinary print- and write-statements do not work. This\n is for example the case in Matlab mex-files (in fact the execution\n of a write statement on the asterisk unit crashes Matlab). To use the\n PUTSTR_UNIT it is necessary to write two subroutines with interfaces: SUBROUTINE PUTSTR(S)\n   CHARACTER(*), INTENT(IN) :: S\n\n   SUBROUTINE PUTNL() The first of these should output the string S, and the second one should\n advance output to the next line. These subroutines should be placed\n in a module PUTSTRMODULE as explained in section 2. The module should\n also define a named constant DEFAULT_UNIT, which could be set to -2 to\n make the PUTSTR_UNIT default. An example that works with g95 and Matlab\n mex-files is: module M_display__putstrmodule integer , parameter :: default_unit = - 2 contains subroutine putstr ( s ) character (*), intent ( in ) :: s call mexprintf ( s // char ( 0 )) end subroutine putstr subroutine putnl () call mexprintf ( char ( 10 )// char ( 0 )) end subroutine putnl end module M_display__putstrmodule At the beginning of the file M_display.f90 there is a slightly longer\n version which works with both g95 and gfortran. Testing this module is\n discussed in section 6.2 below. USING W=0 EDITING The Fortran standard stipulates that writing a single element with\n I0 editing results in the smallest field width that accommodates the\n value, and the same applies to B0, O0, Z0 and F0.d editing. With DISP,\n the width of a displayed column will be the width of the widest field\n in the column, and each element is right-adjusted in the column. This\n gives exactly the same output as using TRIM=’yes’ and a specified field\n width bigger than the largest occurring. Note that with F0.d editing,\n there is no limit on the width of a column, but with Fw.d and TRIM=’yes’\n any element wider than w will be displayed as w asterisks: ------------------F0.2------------------    -----F13.2, TRIM='yes'----\n   14.28  142857142857142857142857.14  0.47    14.28  *************  0.47\n    1.42                1414213562.37  0.69     1.42  1414213562.37  0.69 NOT-A-NUMBER AND INFINITE VALUES If the compiler supports not-a-number and infinite values as defined by\n the IEEE exceptional values of Fortran 2003, these are displayed as NaN,\n +Inf or Inf. A not-a-number value X is identified as being not equal to\n itself, and an infinite value is either greater than HUGE(X) or smaller\n than -HUGE(X). On all the compilers tried the sequence BIG=1E20; CALL\n DISP(EXP(BIG)) displays +Inf, and the program segment: > real :: z = 0, big = 1e20\n > call disp([z, z/z, big, -exp(big)]) displays\n     >  0.00000E+00\n     >          NaN\n     >  1.00000E+20\n     >         -Inf AUTHOR Based on dispmodule(3f),\n   “A Fortran 95 module for pretty-printing matrices”.\n   Version number 1.02 6-Sept-2008,\n   Kristjan Jonasson,\n   Dept. of Computer Science,\n   University of Iceland (jonasson@hi.is). Module Procedures private  subroutine disp_scalar_int(x, fmt, advance, sep, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name integer(kind=dint), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_title_scalar_int(title, x, fmt, advance, sep, style, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title integer(kind=dint), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_vector_int(x, fmt, advance, lbound, sep, style, trim, unit, orient, zeroas) Arguments Type Intent Optional Attributes Name integer(kind=dint), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient character(len=*), intent(in), optional :: zeroas private  subroutine disp_title_vector_int(title, x, fmt, advance, lbound, sep, style, trim, unit, orient, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title integer(kind=dint), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient character(len=*), intent(in), optional :: zeroas private  subroutine disp_matrix_int(x, fmt, advance, lbound, sep, style, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name integer(kind=dint), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_title_matrix_int(title, x, fmt, advance, lbound, sep, style, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title integer(kind=dint), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_s_sngl(x, fmt, advance, digmax, sep, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name real(kind=sngl), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_ts_sngl(title, x, fmt, advance, digmax, sep, style, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title real(kind=sngl), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_v_sngl(x, fmt, advance, digmax, lbound, sep, style, trim, unit, orient, zeroas) Arguments Type Intent Optional Attributes Name real(kind=sngl), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient character(len=*), intent(in), optional :: zeroas private  subroutine disp_tv_sngl(title, x, fmt, advance, digmax, lbound, sep, style, trim, unit, orient, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title real(kind=sngl), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient character(len=*), intent(in), optional :: zeroas private  subroutine disp_m_sngl(x, fmt, advance, lbound, sep, style, trim, unit, digmax, zeroas) Arguments Type Intent Optional Attributes Name real(kind=sngl), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: zeroas private  subroutine disp_tm_sngl(title, x, fmt, advance, digmax, lbound, sep, style, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title real(kind=sngl), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_s_dble(x, fmt, advance, digmax, sep, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name real(kind=dble), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_ts_dble(title, x, fmt, advance, digmax, sep, style, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title real(kind=dble), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_v_dble(x, fmt, advance, digmax, lbound, sep, style, trim, unit, orient, zeroas) Arguments Type Intent Optional Attributes Name real(kind=dble), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient character(len=*), intent(in), optional :: zeroas private  subroutine disp_tv_dble(title, x, fmt, advance, digmax, lbound, sep, style, trim, unit, orient, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title real(kind=dble), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient character(len=*), intent(in), optional :: zeroas private  subroutine disp_m_dble(x, fmt, advance, lbound, sep, style, trim, unit, digmax, zeroas) Arguments Type Intent Optional Attributes Name real(kind=dble), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: zeroas private  subroutine disp_tm_dble(title, x, fmt, advance, digmax, lbound, sep, style, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title real(kind=dble), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_s_cplx(x, fmt, fmt_imag, advance, digmax, sep, trim, unit) Arguments Type Intent Optional Attributes Name complex(kind=sngl), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_ts_cplx(title, x, fmt, fmt_imag, advance, digmax, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title complex(kind=sngl), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_v_cplx(x, fmt, fmt_imag, advance, digmax, lbound, sep, style, trim, unit, orient) Arguments Type Intent Optional Attributes Name complex(kind=sngl), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient private  subroutine disp_tv_cplx(title, x, fmt, fmt_imag, advance, digmax, lbound, sep, style, trim, unit, orient) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title complex(kind=sngl), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient private  subroutine disp_m_cplx(x, fmt, fmt_imag, advance, digmax, lbound, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name complex(kind=sngl), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_tm_cplx(title, x, fmt, fmt_imag, advance, digmax, lbound, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title complex(kind=sngl), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_s_cpld(x, fmt, fmt_imag, advance, digmax, sep, trim, unit) Arguments Type Intent Optional Attributes Name complex(kind=dble), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_ts_cpld(title, x, fmt, fmt_imag, advance, digmax, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title complex(kind=dble), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_v_cpld(x, fmt, fmt_imag, advance, digmax, lbound, sep, style, trim, unit, orient) Arguments Type Intent Optional Attributes Name complex(kind=dble), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient private  subroutine disp_tv_cpld(title, x, fmt, fmt_imag, advance, digmax, lbound, sep, style, trim, unit, orient) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title complex(kind=dble), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient private  subroutine disp_m_cpld(x, fmt, fmt_imag, advance, digmax, lbound, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name complex(kind=dble), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_tm_cpld(title, x, fmt, fmt_imag, advance, digmax, lbound, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title complex(kind=dble), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_s_dlog(x, fmt, advance, sep, trim, unit) Arguments Type Intent Optional Attributes Name logical(kind=dlog), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_ts_dlog(title, x, fmt, advance, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title logical(kind=dlog), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_v_dlog(x, fmt, advance, lbound, sep, style, trim, unit, orient) Arguments Type Intent Optional Attributes Name logical(kind=dlog), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient private  subroutine disp_tv_dlog(title, x, fmt, advance, lbound, sep, style, trim, unit, orient) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title logical(kind=dlog), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient private  subroutine disp_m_dlog(x, fmt, advance, lbound, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name logical(kind=dlog), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_tm_dlog(title, x, fmt, advance, lbound, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title logical(kind=dlog), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_ts_dchr(title, x, fmt, advance, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title character(len=*), intent(in), optional :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_v_dchr(x, fmt, advance, lbound, sep, style, trim, unit, orient) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient private  subroutine disp_tv_dchr(title, x, fmt, advance, lbound, sep, style, trim, unit, orient) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title character(len=*), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient private  subroutine disp_m_dchr(x, fmt, advance, lbound, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_tm_dchr(title, x, fmt, advance, lbound, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title character(len=*), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit","tags":"","url":"interface/disp.html"},{"title":"tostring – M_display","text":"public interface tostring Module Procedures private  function tostring_dint(x) result(st) Arguments Type Intent Optional Attributes Name integer(kind=dint), intent(in) :: x (:) Return Value character(kind=tosset%ifmt), len=len_f_dint(x) private  function tostring_f_dint(x, fmt) result(st) Arguments Type Intent Optional Attributes Name integer(kind=dint), intent(in) :: x (:) character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_dint(x) private  function tostring_s_dint(x) result(st) Arguments Type Intent Optional Attributes Name integer(kind=dint), intent(in) :: x Return Value character(kind=tosset%ifmt), len=len_f_dint([x]) private  function tostring_sf_dint(x, fmt) result(st) Arguments Type Intent Optional Attributes Name integer(kind=dint), intent(in) :: x character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_dint([x]) private  function tostring_dlog(x) result(st) Arguments Type Intent Optional Attributes Name logical(kind=dlog), intent(in) :: x (:) Return Value character(len=1) private  function tostring_f_dlog(x, fmt) result(st) Arguments Type Intent Optional Attributes Name logical(kind=dlog), intent(in) :: x (:) character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_dlog(x) private  function tostring_s_dlog(x) result(st) Arguments Type Intent Optional Attributes Name logical(kind=dlog), intent(in) :: x Return Value character(len=1) private  function tostring_sf_dlog(x, fmt) result(st) Arguments Type Intent Optional Attributes Name logical(kind=dlog), intent(in) :: x character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_dlog([x]) private  function tostring_sngl(x) result(st) Arguments Type Intent Optional Attributes Name real(kind=sngl), intent(in) :: x (:) Return Value character(kind=tosset%rfmt), len=len_f_sngl(x) private  function tostring_f_sngl(x, fmt) result(st) Arguments Type Intent Optional Attributes Name real(kind=sngl), intent(in) :: x (:) character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_sngl(x) private  function tostring_s_sngl(x) result(st) Arguments Type Intent Optional Attributes Name real(kind=sngl), intent(in) :: x Return Value character(kind=tosset%rfmt), len=len_f_sngl([x]) private  function tostring_sf_sngl(x, fmt) result(st) Arguments Type Intent Optional Attributes Name real(kind=sngl), intent(in) :: x character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_sngl([x]) private  function tostring_dble(x) result(st) Arguments Type Intent Optional Attributes Name real(kind=dble), intent(in) :: x (:) Return Value character(kind=tosset%rfmt), len=len_f_dble(x) private  function tostring_f_dble(x, fmt) result(st) Arguments Type Intent Optional Attributes Name real(kind=dble), intent(in) :: x (:) character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_dble(x) private  function tostring_s_dble(x) result(st) Arguments Type Intent Optional Attributes Name real(kind=dble), intent(in) :: x Return Value character(kind=tosset%rfmt), len=len_f_dble([x]) private  function tostring_sf_dble(x, fmt) result(st) Arguments Type Intent Optional Attributes Name real(kind=dble), intent(in) :: x character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_dble([x]) private  function tostring_cplx(x) result(st) Arguments Type Intent Optional Attributes Name complex(kind=sngl), intent(in) :: x (:) Return Value character(kind=tosset%rfmt), len=len_f_cplx(x) private  function tostring_f_cplx(x, fmt) result(st) Arguments Type Intent Optional Attributes Name complex(kind=sngl), intent(in) :: x (:) character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_cplx(x) private  function tostring_s_cplx(x) result(st) Arguments Type Intent Optional Attributes Name complex(kind=sngl), intent(in) :: x Return Value character(kind=tosset%rfmt), len=len_s_cplx(x) private  function tostring_sf_cplx(x, fmt) result(st) Arguments Type Intent Optional Attributes Name complex(kind=sngl), intent(in) :: x character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_s_cplx(x) private  function tostring_cpld(x) result(st) Arguments Type Intent Optional Attributes Name complex(kind=dble), intent(in) :: x (:) Return Value character(kind=tosset%rfmt), len=len_f_cpld(x) private  function tostring_f_cpld(x, fmt) result(st) Arguments Type Intent Optional Attributes Name complex(kind=dble), intent(in) :: x (:) character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_cpld(x) private  function tostring_s_cpld(x) result(st) Arguments Type Intent Optional Attributes Name complex(kind=dble), intent(in) :: x Return Value character(kind=tosset%rfmt), len=len_s_cpld(x) private  function tostring_sf_cpld(x, fmt) result(st) Arguments Type Intent Optional Attributes Name complex(kind=dble), intent(in) :: x character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_s_cpld(x)","tags":"","url":"interface/tostring.html"},{"title":"assert – M_display","text":"public  subroutine assert(s, msg) Arguments Type Intent Optional Attributes Name logical :: s character(len=*), optional :: msg Source Code subroutine assert ( s , msg ) ! Assert that s is true. If not print \"assertion failed\" and msg if it is present logical s character ( * ), optional :: msg if (. not . s ) then if ( present ( msg )) then print '(a, \": assertion failed\")' , trim ( msg ) else print '(\"assertion failed\")' end if stop endif end subroutine assert","tags":"","url":"proc/assert.html"},{"title":"assert_init – M_display","text":"public  subroutine assert_init(st) Arguments Type Intent Optional Attributes Name character(len=*), optional :: st Source Code subroutine assert_init ( st ) ! Set assert-string (used by subroutine compare) to st, compare_no to zero and display st ! if verbose is true. If st is absent, set assert_string to '' character ( * ), optional :: st if ( present ( st )) then assert_string = st call msg2 ( '' ) call msg1 ( st ) else assert_string = '' endif compare_no = 0 end subroutine assert_init","tags":"","url":"proc/assert_init.html"},{"title":"close_8 – M_display","text":"public  subroutine close_8() Arguments None Source Code subroutine close_8 close ( 8 ) end subroutine close_8","tags":"","url":"proc/close_8.html"},{"title":"compare – M_display","text":"public  subroutine compare(sok, message, sok1) Arguments Type Intent Optional Attributes Name character(len=*) :: sok (:) character(len=*), optional :: message character(len=*), optional :: sok1 (:) Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ios1 character(len=100), public :: mess character(len=100), public :: s Source Code subroutine compare ( sok , message , sok1 ) ! Utility for all the test routines. Print to the screen what the last disp calls ! displayed, and assert that what was displayed matches either sok or sok1. character ( * ) :: sok (:), sok1 (:), message optional :: message , sok1 character ( 100 ) :: s , mess integer ios1 , i rewind ( 8 ) compare_no = compare_no + 1 if ( present ( message )) then mess = message else write ( mess , '(a,\"-\",i0)' ) trim ( assert_string ), compare_no endif do i = 1 , 9999 read ( 8 , 1 , iostat = ios1 ) s if ( ios1 < 0 ) exit call msg2 ( s ) call assert ( i <= size ( sok ), message ) if ( present ( sok1 )) call assert ( sok ( i ) == s . or . sok1 ( i ) == s , mess ) if (. not . present ( sok1 )) call assert ( sok ( i ) == s , mess ) enddo call assert ( i == size ( sok ) + 1 , mess ) call reopen_8 1 format ( A ) end subroutine compare","tags":"","url":"proc/compare.html"},{"title":"msg1 – M_display","text":"public  subroutine msg1(st) Arguments Type Intent Optional Attributes Name character(len=*) :: st Source Code subroutine msg1 ( st ) ! Print st if verbose is >= 1 character ( * ) st if ( verbose >= 1 ) write ( * , '(2x,a)' ) trim ( st ) end subroutine msg1","tags":"","url":"proc/msg1.html"},{"title":"msg2 – M_display","text":"public  subroutine msg2(st) Arguments Type Intent Optional Attributes Name character(len=*) :: st Source Code subroutine msg2 ( st ) ! Print st if verbose is >= 2 character ( * ) st if ( verbose >= 2 ) write ( * , '(4x,a)' ) trim ( st ) end subroutine msg2","tags":"","url":"proc/msg2.html"},{"title":"open_8 – M_display","text":"public  subroutine open_8() Arguments None Source Code subroutine open_8 open ( 8 , file = 'testtmp.dat' , status = 'replace' ) end subroutine open_8","tags":"","url":"proc/open_8.html"},{"title":"reopen_8 – M_display","text":"public  subroutine reopen_8() Arguments None Source Code subroutine reopen_8 call close_8 call open_8 end subroutine reopen_8","tags":"","url":"proc/reopen_8.html"},{"title":"test_ni – M_display","text":"public  subroutine test_ni(nan, inf, minf) Uses M_display Arguments Type Intent Optional Attributes Name real(kind=srk), intent(in) :: nan real(kind=srk), intent(in) :: inf real(kind=srk), intent(in) :: minf Variables Type Visibility Attributes Name Initial real(kind=srk), public :: d1 (3,2) = reshape((/-2.146_srk, 0._srk, 1._srk, 0._srk, 20.33_srk, 0._srk/), (/3, 2/)) real(kind=srk), public :: d2 (2) = (/0._srk, 0._srk/) real(kind=srk), public :: d3 (2) = (/12e20_srk, 0._srk/) real(kind=srk), public :: d4 = 0._srk logical, public :: mask1 (3,2) logical, public :: mask2 (2) logical, public :: mask3 (2) character(len=12), public :: s1 (3) character(len=9), public :: s2 (1) character(len=16), public :: s3 (2) character(len=9), public :: s4 (2) real(kind=srk), public :: zero = 0._srk Source Code subroutine test_ni ( nan , inf , minf ) USE M_display !use, intrinsic :: ieee_arithmetic real ( srk ), intent ( in ) :: nan , inf , minf real ( srk ) :: & zero = 0._srk , & d1 ( 3 , 2 ) = reshape (( /- 2.146_srk , 0._srk , 1._srk , 0._srk , 2 0.33_srk , 0._srk / ), ( / 3 , 2 / )), & d2 ( 2 ) = ( / 0._srk , 0._srk / ), & d3 ( 2 ) = ( / 1 2e20_srk , 0._srk / ), & d4 = 0._srk logical :: mask1 ( 3 , 2 ), mask2 ( 2 ), mask3 ( 2 ) character ( 12 ) :: s1 ( 3 ) character ( 9 ) :: s2 ( 1 ) character ( 16 ) :: s3 ( 2 ) character ( 9 ) :: s4 ( 2 ) ! call open_8 if ( verbose > 0 ) adv = 'yes' write ( * , fmt , advance = adv ) srk mask1 = d1 == zero mask2 = d2 == zero mask3 = d3 == zero d1 = merge ( nan , d1 , mask1 ) d2 = merge ( nan , d2 , mask2 ) d3 = merge ( nan , d3 , mask3 ) d4 = nan ! s1 = ( / '-2.15    NaN' ,& & '  NaN  20.33' ,& & ' 1.00    NaN' / ) ! s2 = ' NaN, NaN' ! s3 ( 1 ) = 'A = 1.20000E+21' s3 ( 2 ) = '            NaN' ! s4 ( 1 ) = 'Longtitle' s4 ( 2 ) = '   NaN   ' ! call assert_init ( 'TEST_NAN' ) call disp_set ( unit = 8 , style = 'PAD' ) call disp ( d1 , digmax = 4 ); call compare ( s1 , 'NaN-1' ) call disp ( d1 , digmax = 4 , zeroas = '0.' ); call compare ( s1 , 'NaN-1' ) call disp ( d2 , sep = ',' , orient = 'row' ); call compare ( s2 , 'NaN-2' ) call disp ( 'A = ' , d3 , style = 'left' ); call compare ( s3 , 'NaN-3' ) call disp ( 'Longtitle' , d4 ); call compare ( s4 , 'NaN-4' ) d1 = merge ( inf , d1 , mask1 ) d2 = merge ( inf , d2 , mask2 ) d3 = merge ( inf , d3 , mask3 ) d4 = inf s1 ( 1 ) = '-2.15   +Inf' s1 ( 2 ) = ' +Inf  20.33' s1 ( 3 ) = ' 1.00   +Inf' s2 = '+Inf,+Inf' s3 ( 2 ) = '           +Inf' s4 ( 2 ) = '  +Inf   ' call disp ( d1 , digmax = 4 ); call compare ( s1 , 'Inf-1' ) call disp ( d1 , digmax = 4 , zeroas = '0.' ); call compare ( s1 , 'Inf-1' ) call disp ( d2 , sep = ',' , orient = 'row' ); call compare ( s2 , 'Inf-2' ) call disp ( 'A = ' , d3 , style = 'left' ); call compare ( s3 , 'Inf-3' ) call disp ( 'Longtitle' , d4 ); call compare ( s4 , 'Inf-4' ) d1 ( 1 ,:) = merge ( minf , d1 ( 1 ,:), mask1 ( 1 ,:)) d1 ( 2 ,:) = merge ( nan , d1 ( 2 ,:), mask1 ( 2 ,:)) d1 ( 3 ,:) = merge ( inf , d1 ( 3 ,:), mask1 ( 3 ,:)) d2 = merge ( minf , d2 , mask2 ) d3 = merge ( minf , d3 , mask3 ) d4 = minf s1 ( 1 ) = '-2.15   -Inf' s1 ( 2 ) = '  NaN  20.33' s1 ( 3 ) = ' 1.00   +Inf' s2 = '-Inf,-Inf' s3 ( 2 ) = '           -Inf' s4 ( 2 ) = '  -Inf   ' call disp ( d1 , digmax = 4 ); call compare ( s1 , '-Inf-1' ) call disp ( d2 , sep = ',' , orient = 'row' ); call compare ( s2 , '-Inf-2' ) call disp ( 'A = ' , d3 , style = 'left' ); call compare ( s3 , '-Inf-3' ) call disp ( 'Longtitle' , d4 ); call compare ( s4 , '-Inf-4' ) s1 ( 1 ) = ' -2.  -Inf' s1 ( 2 ) = ' NaN   20.' s1 ( 3 ) = '  1.  +Inf' call disp ( d1 , digmax = 2 ); call compare ( s1 , 'Mixed-1' ) call disp ( d1 , 'F4.0' ); call compare ( s1 , 'Mixed-2' ) call disp ( d1 , 'F4.0' , trim = 'yes' ); call compare ( s1 , 'Mixed-3' ) s1 ( 1 ) = '-2.  ***' s1 ( 2 ) = 'NaN  20.' s1 ( 3 ) = ' 1.  Inf' call disp ( d1 , 'F3.0' ); call compare ( s1 , 'Field-overflow-1' ) call disp ( d2 , 'F2.0' ); call compare (( / '**' , '**' / ), 'Field-overflow-2' ) call disp_set_factory write ( * , '(\"  OK\")' ) call close_8 end subroutine test_ni","tags":"","url":"proc/test_ni.html"},{"title":"disp_xy – M_display","text":"subroutine disp_xy(x, y) Uses M_display Arguments Type Intent Optional Attributes Name real :: x (:,:) real :: y (:,:) Variables Type Visibility Attributes Name Initial type( disp_settings ), public :: ds Source Code subroutine disp_xy ( x , y ) use M_display real x (:,:), y (:,:) type ( disp_settings ) ds ds = disp_get () call disp_set ( digmax = 4 , sep = ',' ) call disp ( 'x=' , x ) write ( * , * ) call disp ( 'y=' , y ) call disp_set ( ds ) end subroutine disp_xy","tags":"","url":"proc/disp_xy.html"},{"title":"assert – M_display","text":"subroutine assert(s, msg) Arguments Type Intent Optional Attributes Name logical, intent(in) :: s character(len=*), intent(in), optional :: msg Source Code subroutine assert ( s , msg ) ! Assert that s is true. If not print \"assertion failed\" and msg if it is present logical , intent ( in ) :: s character ( * ), optional , intent ( in ) :: msg if (. not . s ) then if ( present ( msg )) then print '(a, \": assertion failed\")' , trim ( msg ) else print '(\"assertion failed\")' endif stop 2 endif end subroutine assert","tags":"","url":"proc/assert~2.html"},{"title":"assert_init – M_display","text":"subroutine assert_init(st) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: st Source Code subroutine assert_init ( st ) ! Set assert-string (used by subroutine compare) to st, compare_no to zero and display st ! if verbose is true. If st is absent, set assert_string to '' character ( * ), optional , intent ( in ) :: st if ( present ( st )) then assert_string = st call msg2 ( '' ) call msg1 ( st ) else assert_string = '' endif compare_no = 0 end subroutine assert_init","tags":"","url":"proc/assert_init~2.html"},{"title":"close_8 – M_display","text":"subroutine close_8() Arguments None Source Code subroutine close_8 close ( 8 ) end subroutine close_8","tags":"","url":"proc/close_8~2.html"},{"title":"compare – M_display","text":"subroutine compare(sok, message, sok1) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: sok (:) character(len=*), intent(in), optional :: message character(len=*), intent(in), optional :: sok1 (:) Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ios1 character(len=100), public :: mess character(len=100), public :: s Source Code subroutine compare ( sok , message , sok1 ) ! Utility for all the test routines. Print to the screen what the last disp calls ! displayed, and assert that what was displayed matches either sok or sok1. character ( * ), intent ( in ) :: sok (:), sok1 (:), message optional :: message , sok1 character ( 100 ) :: s , mess integer ios1 , i rewind ( 8 ) compare_no = compare_no + 1 if ( present ( message )) then mess = message else write ( mess , '(a,\"-\",i0)' ) trim ( assert_string ), compare_no endif do i = 1 , 9999 read ( 8 , 1 , iostat = ios1 ) s if ( ios1 < 0 ) exit call msg2 ( s ) call assert ( i <= size ( sok ), message ) if ( present ( sok1 )) call assert ( sok ( i ) == s . or . sok1 ( i ) == s , mess ) if (. not . present ( sok1 )) call assert ( sok ( i ) == s , mess ) enddo call assert ( i == size ( sok ) + 1 , mess ) call reopen_8 1 format ( A ) end subroutine compare","tags":"","url":"proc/compare~2.html"},{"title":"disp_xy – M_display","text":"subroutine disp_xy(x, y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x (:,:) real, intent(in) :: y (:,:) Variables Type Visibility Attributes Name Initial type( disp_settings ), public :: ds Source Code subroutine disp_xy ( x , y ) ! Utility for tests_from_manual_4 ! use M_display (already \"used\" here, but explicit in manual) real , intent ( in ) :: x (:,:), y (:,:) type ( disp_settings ) ds ds = disp_get () call disp_set ( digmax = 4 , sep = ',' ) call disp ( 'x=' , x ) call disp ( 'y=' , y ) call disp_set ( ds ) end subroutine disp_xy","tags":"","url":"proc/disp_xy~2.html"},{"title":"msg1 – M_display","text":"subroutine msg1(st) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: st Source Code subroutine msg1 ( st ) ! Print st if verbose is >= 1 character ( * ), intent ( in ) :: st if ( verbose >= 1 ) write ( * , '(2x,a)' ) trim ( st ) end subroutine msg1","tags":"","url":"proc/msg1~2.html"},{"title":"msg2 – M_display","text":"subroutine msg2(st) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: st Source Code subroutine msg2 ( st ) ! Print st if verbose is >= 2 character ( * ), intent ( in ) :: st if ( verbose >= 2 ) write ( * , '(4x,a)' ) trim ( st ) end subroutine msg2","tags":"","url":"proc/msg2~2.html"},{"title":"open_8 – M_display","text":"subroutine open_8() Arguments None Source Code subroutine open_8 open ( 8 , file = 'testtmp.dat' , status = 'replace' ) end subroutine open_8","tags":"","url":"proc/open_8~2.html"},{"title":"reopen_8 – M_display","text":"subroutine reopen_8() Arguments None Source Code subroutine reopen_8 call close_8 call open_8 end subroutine reopen_8","tags":"","url":"proc/reopen_8~2.html"},{"title":"scompare – M_display","text":"subroutine scompare(s, shouldbe, sb1, sb2, sb3) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s character(len=*), intent(in) :: shouldbe character(len=*), intent(in), optional :: sb1 character(len=*), intent(in), optional :: sb2 character(len=*), intent(in), optional :: sb3 Source Code subroutine scompare ( s , shouldbe , sb1 , sb2 , sb3 ) ! Utility for test_tostring. Print s to the screen and assert that it is ! matches either shouldbe, sb1, sb2 or sb3. character ( * ), intent ( in ) :: s , shouldbe , sb1 , sb2 , sb3 optional sb1 , sb2 , sb3 call msg2 ( '\"' // trim ( s ) // '\" should be \"' // trim ( shouldbe ) // '\"' ) if ( present ( sb3 )) call assert ( s == shouldbe . or . s == sb1 . or . s == sb2 . or . s == sb3 ) if ( present ( sb2 )) call assert ( s == shouldbe . or . s == sb1 . or . s == sb2 ) if ( present ( sb1 )) call assert ( s == shouldbe . or . s == sb1 ) if (. not . present ( sb1 )) call assert ( s == shouldbe ) end subroutine scompare","tags":"","url":"proc/scompare.html"},{"title":"test_advance_double – M_display","text":"subroutine test_advance_double() Arguments None Source Code subroutine test_advance_double call assert_init ( 'TEST_ADVANCE_DOUBLE' ) call disp_set ( unit = 8 ) call disp ( 5 , advance = 'double' ) call disp ( 6 ) call compare (( / '5' , ' ' , '6' / )) call disp_set ( advance = 'double' ) call disp ( 7 , advance = 'no' ) call disp ( 8 ) call disp ( 9 ) call compare (( / '7   8' , '     ' , '9    ' , '     ' / )) call disp_set_factory end subroutine test_advance_double","tags":"","url":"proc/test_advance_double.html"},{"title":"test_advance_no – M_display","text":"subroutine test_advance_no() Arguments None Source Code subroutine test_advance_no call assert_init ( 'TEST_ADVANCE_NO' ) call disp_set ( unit = 8 ) call disp ( 1 , advance = 'no' ) call disp (( / 2 , 3 / ), advance = 'yes' ) call compare (( / '1   2' , '    3' / )) call disp_set_factory end subroutine test_advance_no","tags":"","url":"proc/test_advance_no.html"},{"title":"test_char – M_display","text":"subroutine test_char() Arguments None Variables Type Visibility Attributes Name Initial character(len=3), public :: c1 (2,2) = reshape((/'ABC', '   ', 'A  ', '  B'/), (/2, 2/)) character(len=3), public :: c2 (1,2) = reshape((/'ABC', 'AB '/), (/1, 2/)) character(len=1), public :: c3 (2,1) = reshape((/'X', 'Y'/), (/2, 1/)) character(len=3), public :: c4 (1,1) = reshape((/'ABC'/), (/1, 1/)) character(len=8), public :: s1 (2) character(len=9), public :: s2 (2) character(len=5), public :: s3 (2) character(len=9), public :: s4 (3) Source Code subroutine test_char ! Check that disp works for outputting character strings with explicit or default format character ( 3 ) :: c1 ( 2 , 2 ) = reshape (( / 'ABC' , '   ' , 'A  ' , '  B' / ), ( / 2 , 2 / )) character ( 3 ) :: c2 ( 1 , 2 ) = reshape (( / 'ABC' , 'AB ' / ), ( / 1 , 2 / )) character ( 1 ) :: c3 ( 2 , 1 ) = reshape (( / 'X' , 'Y' / ), ( / 2 , 1 / )) character ( 3 ) :: c4 ( 1 , 1 ) = reshape (( / 'ABC' / ), ( / 1 , 1 / )) character ( 8 ) :: s1 ( 2 ) character ( 9 ) :: s2 ( 2 ) character ( 5 ) :: s3 ( 2 ) character ( 9 ) :: s4 ( 3 ) ! call assert_init ( 'TEST_CHAR' ) s1 = ( / 'ABC  A  ' ,& & '       B' / ) s2 = ( / '--title--' ,& & ' ABC, AB ' / ) s3 = ( / 'A = X' ,& & '    Y' / ) s4 = ( / 'Longtitle' ,& & '*********' ,& & '   ABC   ' / ) call disp_set ( unit = 8 , style = 'PAD' ) ! SPECIFIED FORMAT: call disp ( c1 , 'A' , style = 'left' ); call compare ( s1 ) call disp ( 'title' , c2 , 'A4' , sep = ',' ); call compare ( s2 ) call disp ( 'A = ' , c3 , 'a1' , style = 'left' ); call compare ( s3 ) call disp ( 'Longtitle' , c4 , 'A' , style = '*underline' ); call compare ( s4 ) ! DEFAULT FORMAT: call disp ( c1 , style = 'left' ); call compare ( s1 ) call disp ( 'A = ' , c3 , style = 'left' ); call compare ( s3 ) call disp ( 'Longtitle' , c4 , style = '*underline' ); call compare ( s4 ) call disp_set_factory end subroutine test_char","tags":"","url":"proc/test_char.html"},{"title":"test_complex – M_display","text":"subroutine test_complex() Arguments None Variables Type Visibility Attributes Name Initial complex(kind=srk), public :: c1 (2,2) complex(kind=srk), public :: c2 (2) complex(kind=srk), public :: c3 real(kind=srk), public :: r1 (2,2) = reshape((/2.146_srk, -1.231_srk, 0.008_srk, 20.33_srk/), (/2, 2/)) real(kind=srk), public :: r2 (2) = (/12.0_srk, -1234.5678_srk/) character(len=29), public :: s1 (2) character(len=31), public :: s1a (2) character(len=31), public :: s1b (2) character(len=36), public :: s2 (2) character(len=16), public :: s3 (1) Source Code subroutine test_complex ! Test disp with complex data real ( srk ) :: r1 ( 2 , 2 ) = reshape (( / 2.146_srk , - 1.231_srk , 0.008_srk , 2 0.33_srk / ), ( / 2 , 2 / )) real ( srk ) :: r2 ( 2 ) = ( / 1 2.0_srk , - 123 4.5678_srk / ) complex ( srk ) :: c1 ( 2 , 2 ), c2 ( 2 ), c3 character ( 29 ) :: s1 ( 2 ) character ( 31 ) :: s1a ( 2 ), s1b ( 2 ) character ( 36 ) :: s2 ( 2 ) character ( 16 ) :: s3 ( 1 ) ! call assert_init ( 'TEST_COMPLEX' ) s1 ( 1 ) = ' 2.15 + 4.29i   0.01 +  0.02i' s1 ( 2 ) = '-1.23 - 2.46i  20.33 + 40.66i' ! s1a ( 1 ) = ' 2.1460 + 4.3i   0.0080 +  0.0i' s1a ( 2 ) = '-1.2310 - 2.5i  20.3300 + 40.7i' ! s1b ( 1 ) = ' 2.1 + 4.2920i   0.0 +  0.0160i' s1b ( 2 ) = '-1.2 - 2.4620i  20.3 + 40.6600i' ! s2 ( 1 ) = '---------------AB--------------' s2 ( 2 ) = '12.0 + 12.0i, -1234.6 - 1234.6i' ! s3 ( 1 ) = '1.2345 - 2.3457i' ! c1 = cmplx ( r1 , 2 * r1 ) c2 = cmplx ( r2 , r2 ) c3 = ( 1.2345_srk , - 2.34567_srk ) ! call disp_set ( unit = 8 ) call disp ( c1 , 'F0.2' ); call compare ( s1 ) call disp ( c1 , 'F0.4' , fmt_imag = 'F0.1' ); call compare ( s1a ) call disp ( c1 , 'F0.1' , fmt_imag = 'F0.4' ); call compare ( s1b ) call disp_set ( style = 'PAD' , digmax = 5 , sep = ', ' ); call disp ( 'AB' , c2 , orient = 'row' ); call compare ( s2 ) call disp ( c3 ); call compare ( s3 ) call disp_set_factory end subroutine test_complex","tags":"","url":"proc/test_complex.html"},{"title":"test_disp_set1 – M_display","text":"subroutine test_disp_set1() Arguments None Variables Type Visibility Attributes Name Initial type( disp_settings ), public :: ds Source Code subroutine test_disp_set1 ! Check default values of disp_settings type ( disp_settings ) ds ds = disp_get () call assert ( ds % advance == 'YES' , '1A' ) call assert ( ds % trim == 'AUTO' , '1B' ) call assert ( ds % sep == '  ' , '1C' ) call assert ( ds % matsep == '   ' , '1D' ) call assert ( ds % orient == 'COL' , '1E' ) call assert ( ds % style == 'LEFT' , '1F' ) call assert ( ds % seplen == 2 , '1H' ) call assert ( ds % matseplen == 3 , '1I' ) call assert ( ds % digmax == 6 , '1J' ) call assert ( ds % zeroas == '' , '1K' ) call assert ( ds % zaslen == 0 , '1L' ) call assert ( ds % unit == - 3 , '1M' ) call assert ( ds % unit == ASTERISK_UNIT , '1M' ) end subroutine test_disp_set1","tags":"","url":"proc/test_disp_set1.html"},{"title":"test_disp_set2 – M_display","text":"subroutine test_disp_set2() Arguments None Variables Type Visibility Attributes Name Initial type( disp_settings ), public :: ds Source Code subroutine test_disp_set2 ! Set, retrieve settings with disp_get and check contents of retrieved settings type ( disp_settings ) ds call disp_set ( advance = 'yes' ) call disp_set ( matsep = 'ss' ) call disp_set ( sep = 'cc' ) call disp_set ( orient = 'row' ) call disp_set ( style = 'xpad' ) call disp_set ( unit = 7 ) call disp_set ( digmax = 13 ) call disp_set ( zeroas = '**' ) ds = disp_get () call assert ( ds % advance == 'YES' , '2A' ) call assert ( ds % matsep == 'ss' , '2B' ) call assert ( ds % sep == 'cc' , '2C' ) call assert ( ds % orient == 'ROW' , '2D' ) call assert ( ds % style == 'xpad' , '2E' ) call assert ( ds % unit == 7 , '2G' ) call assert ( ds % digmax == 13 , '2H' ) call assert ( ds % zeroas == '**' , '2I' ) call assert ( ds % zaslen == 2 , '2J' ) call disp_set ( orient = 'col' ) call disp_set ( style = 'UNDERLINE' ) ds = disp_get () call assert ( ds % orient == 'COL' , '2K' ) call assert ( ds % style == 'UNDERLINE' , '2L' ) call disp_set_factory end subroutine test_disp_set2","tags":"","url":"proc/test_disp_set2.html"},{"title":"test_empty – M_display","text":"subroutine test_empty() Arguments None Variables Type Visibility Attributes Name Initial character(len=16), public :: shouldbe (14) character(len=20), public :: shouldbe_char (14) Source Code subroutine test_empty ! Test display of empty vectors / matrices of various dimensions (0 by 0, 0 by 1, 1 by 0, 0 by 2 etc.) character ( 16 ) shouldbe ( 14 ) character ( 20 ) shouldbe_char ( 14 ) call assert_init ( 'TEST_EMPTY' ) shouldbe = ( / & 'v=,v=   ,v,-v-,*' , & 'v,*             ' , & ' ,*             ' , & ' v              ' , & '---             ' , & 'M02= ,M02=   ,* ' , & 'M02,  M02 ,*    ' , & '---,------,     ' , & 'M20=,M20=,*     ' , & '    ,    ,      ' , & 'M20,M20,*       ' , & '---,---,        ' , & '   ,   ,        ' , & '   ,   ,        ' / ) shouldbe_char = ( / & 'v=  ,v=   ,-v,-v-,* ' , & 'v,*                 ' , & ' ,*                 ' , & ' v                  ' , & '---                 ' , & 'M02=     ,M02=   ,* ' , & '  M02 , M02,*       ' , & '------,----,        ' , & 'M20=,M20=,*         ' , & '    ,    ,          ' , & 'M20,M20,*           ' , & '---,---,            ' , & '   ,   ,            ' , & '   ,   ,            ' / ) call disp_set ( unit = 8 , advance = 'no' , matsep = ',' ) call test_empty_int ; call compare ( shouldbe , 'int' ) call test_empty_real ; call compare ( shouldbe , 'real' ) call test_empty_logical ; call compare ( shouldbe , 'logical' ) call test_empty_char ; call compare ( shouldbe_char , 'char' ) call disp_set_factory call assert_init () end subroutine test_empty","tags":"","url":"proc/test_empty.html"},{"title":"test_empty_char – M_display","text":"subroutine test_empty_char() Arguments None Variables Type Visibility Attributes Name Initial character(len=2), public :: c02mat (0,2) character(len=2), public :: c20mat (2,0) character(len=2), public :: cvec (0) Source Code subroutine test_empty_char character ( 2 ) :: cvec ( 0 ), c02mat ( 0 , 2 ), c20mat ( 2 , 0 ) cvec = '' ; c02mat = '' ; c20mat = '' ; call assert_init ( '...empty char' ) call disp ( 'v=' , cvec ) call disp ( 'v=' , cvec , 'A3' ) call disp ( 'v' , cvec , style = 'pad' ) call disp ( 'v' , cvec , 'A3' , style = 'pad' ) call disp ( '*' , advance = 'yes' ) call disp ( 'v' , cvec , style = 'pad' , orient = 'row' ) call disp (( / '*' , '*' / ), advance = 'yes' ) call disp ( 'v' , cvec , 'A3' , style = 'underline' , advance = 'yes' ) call disp ( 'M02=' , c02mat , sep = ':' ) call disp ( 'M02=' , c02mat , 'A1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M02' , c02mat , style = 'underline' ) call disp ( 'M02' , c02mat , 'A1' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20=' , c20mat , sep = ':' ) call disp ( 'M20=' , c20mat , 'A1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20' , c20mat , style = 'underline' ) call disp ( 'M20' , c20mat , 'A2' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) end subroutine test_empty_char","tags":"","url":"proc/test_empty_char.html"},{"title":"test_empty_int – M_display","text":"subroutine test_empty_int() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i02mat (0,2) integer, public :: i20mat (2,0) integer, public :: ivec (0) Source Code subroutine test_empty_int integer :: ivec ( 0 ), i02mat ( 0 , 2 ), i20mat ( 2 , 0 ) ivec = 0 ; i02mat = 0 ; i20mat = 0 call msg2 ( '...empty integer' ) call disp ( 'v=' , ivec ) call disp ( 'v=' , ivec , 'I3' ) call disp ( 'v' , ivec , style = 'pad' ) call disp ( 'v' , ivec , 'I3' , style = 'pad' ) call disp ( '*' , advance = 'yes' ) call disp ( 'v' , ivec , style = 'pad' , orient = 'row' ) call disp (( / '*' , '*' / ), advance = 'yes' ) call disp ( 'v' , ivec , 'I3' , style = 'underline' , advance = 'yes' ) call disp ( 'M02=' , i02mat , sep = ':' ) call disp ( 'M02=' , i02mat , 'I1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M02' , i02mat , style = 'underline' ) call disp ( 'M02' , i02mat , 'I2' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20=' , i20mat , sep = ':' ) call disp ( 'M20=' , i20mat , 'I1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20' , i20mat , style = 'underline' ) call disp ( 'M20' , i20mat , 'I2' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) end subroutine test_empty_int","tags":"","url":"proc/test_empty_int.html"},{"title":"test_empty_logical – M_display","text":"subroutine test_empty_logical() Arguments None Variables Type Visibility Attributes Name Initial logical(kind=logikind), public :: l02mat (0,2) logical(kind=logikind), public :: l20mat (2,0) logical(kind=logikind), public :: lvec (0) Source Code subroutine test_empty_logical logical ( logikind ) :: lvec ( 0 ), l02mat ( 0 , 2 ), l20mat ( 2 , 0 ) lvec = . false .; l02mat = . false .; l20mat = . false . call assert_init ( '...empty logical' ) call disp ( 'v=' , lvec ) call disp ( 'v=' , lvec , 'L3' ) call disp ( 'v' , lvec , style = 'pad' ) call disp ( 'v' , lvec , 'L3' , style = 'pad' ) call disp ( '*' , advance = 'yes' ) call disp ( 'v' , lvec , style = 'pad' , orient = 'row' ) call disp (( / '*' , '*' / ), advance = 'yes' ) call disp ( 'v' , lvec , 'L3' , style = 'underline' , advance = 'yes' ) call disp ( 'M02=' , l02mat , sep = ':' ) call disp ( 'M02=' , l02mat , 'L1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M02' , l02mat , style = 'underline' ) call disp ( 'M02' , l02mat , 'L2' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20=' , l20mat , sep = ':' ) call disp ( 'M20=' , l20mat , 'L1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20' , l20mat , style = 'underline' ) call disp ( 'M20' , l20mat , 'L2' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) end subroutine test_empty_logical","tags":"","url":"proc/test_empty_logical.html"},{"title":"test_empty_real – M_display","text":"subroutine test_empty_real() Arguments None Variables Type Visibility Attributes Name Initial real, public :: r02mat (0,2) real, public :: r20mat (2,0) real, public :: rvec (0) Source Code subroutine test_empty_real real :: rvec ( 0 ), r02mat ( 0 , 2 ), r20mat ( 2 , 0 ) rvec = 0.0 ; r02mat = 0.0 ; r20mat = 0.0 call assert_init ( '...empty real' ) call disp ( 'v=' , rvec ) call disp ( 'v=' , rvec , 'F3.0' ) call disp ( 'v' , rvec , style = 'pad' ) call disp ( 'v' , rvec , 'F3.0' , style = 'pad' ) call disp ( '*' , advance = 'yes' ) call disp ( 'v' , rvec , style = 'pad' , orient = 'row' ) call disp (( / '*' , '*' / ), advance = 'yes' ) call disp ( 'v' , rvec , 'F3.0' , style = 'underline' , advance = 'yes' ) call disp ( 'M02=' , r02mat , sep = ':' ) call disp ( 'M02=' , r02mat , 'F1.0' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M02' , r02mat , style = 'underline' ) call disp ( 'M02' , r02mat , 'F2.0' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20=' , r20mat , sep = ':' ) call disp ( 'M20=' , r20mat , 'F1.0' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20' , r20mat , style = 'underline' ) call disp ( 'M20' , r20mat , 'F2.0' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) end subroutine test_empty_real","tags":"","url":"proc/test_empty_real.html"},{"title":"test_error_messages – M_display","text":"subroutine test_error_messages() Arguments None Source Code subroutine test_error_messages if ( verbose < 1 ) return call msg2 ( '' ) call msg1 ( 'TEST_ERROR_MESSAGES' ) call msg1 ( '  (Following should print 17 error messages,' ) call msg1 ( '  5 for disp_set, 8 for disp and 4 for tostring_set)' ) call disp_set ( unit = NULL_UNIT ) call w4blnk ; call disp_set ( advance = 'abc' ) call w4blnk ; call disp_set ( style = 'xyz' ) call w4blnk ; call disp_set ( digmax = 0 ) call w4blnk ; call disp_set ( digmax = 90 ) call w4blnk ; call disp_set ( orient = 'xyz' ) call disp_set ( digmax = 1 ) ! should not give error call disp_set ( digmax = 89 ) ! should not give error call disp ( 0.17 , digmax = 89 ) ! should not give error call w4blnk ; call disp ( 0.17 , digmax = 0 ) call w4blnk ; call disp ( 0.17 , digmax = 90 ) call w4blnk ; call disp ( 0.17 , digmax = 2 , fmt = 'f0.1' ) call w4blnk ; call disp ( 0.17 , advance = 'xyz' ) call w4blnk ; call disp ( 0.17 , trim = 'xyz' ) call w4blnk ; call disp ( 'x=' , 0.17 , style = 'xyz' ) call w4blnk ; call disp (( / 0.17 / ), orient = 'xyz' ) call w4blnk ; call disp (( 1 , 1 ), fmt_imag = 'F10.2' ) call w4blnk ; call tostring_set ( trimb = 'xyz' ) call w4blnk ; call tostring_set ( trimz = 'xyz' ) call w4blnk ; call tostring_set ( rfmt = 'xyz' ) call w4blnk ; call tostring_set ( ifmt = 'xyz' ) call disp_set_factory end subroutine test_error_messages","tags":"","url":"proc/test_error_messages.html"},{"title":"test_integer – M_display","text":"subroutine test_integer() Arguments None Variables Type Visibility Attributes Name Initial character(len=3), public :: fmt integer(kind=sik), public :: i1 (1,2) = reshape((/-9_sik*10_sik**(irange-1)+1, 9_sik*10_sik**(irange-1)-1/), (/1, 2/)) integer(kind=sik), public :: i2 (2,2) = reshape((/100, -99, -99, 0/), (/2, 2/)) integer(kind=sik), public :: i3 (2,2) = reshape((/12, 1, -12, 0/), (/2, 2/)) integer(kind=sik), public :: i4 (2) = (/1, -2/) integer(kind=sik), public :: i5 (1) = (/0/) integer(kind=sik), public :: i6 (1,2) = reshape((/13, -12/), (/1, 2/)) integer(kind=sik), public :: i7 (2) integer(kind=sik), public :: i8 integer, public :: k500 integer, public :: k5000 character(len=2), public :: s1 (1) character(len=9), public :: s2 (3) character(len=9), public :: s3 (2) character(len=9), public :: s3a (2) character(len=9), public :: s4 (3) character(len=9), public :: s4a (2) character(len=2), public :: s5 (1) character(len=7), public :: s6 (3) character(len=10), public :: s7 (1) character(len=13), public :: s7a (1) character(len=3), public :: s8 (2) character(len=10), public :: st Source Code subroutine test_integer ! Check that disp works with integers integer ( sik ) :: i1 ( 1 , 2 ) = reshape (( /- 9_sik * 10_sik ** ( irange - 1 ) + 1 , 9_sik * 10_sik ** ( irange - 1 ) - 1 / ), ( / 1 , 2 / )) integer ( sik ) :: i2 ( 2 , 2 ) = reshape (( / 100 , - 99 , - 99 , 0 / ), ( / 2 , 2 / )) integer ( sik ) :: i3 ( 2 , 2 ) = reshape (( / 12 , 1 , - 12 , 0 / ), ( / 2 , 2 / )) integer ( sik ) :: i4 ( 2 ) = ( / 1 , - 2 / ) integer ( sik ) :: i5 ( 1 ) = ( / 0 / ) integer ( sik ) :: i6 ( 1 , 2 ) = reshape (( / 13 , - 12 / ), ( / 1 , 2 / )) integer ( sik ) :: i7 ( 2 ), i8 character ( 2 * irange + 3 ) :: s1 ( 1 ) character ( 9 ) :: s2 ( 3 ), s3 ( 2 ), s3a ( 2 ), s4 ( 3 ), s4a ( 2 ) character ( 2 ) :: s5 ( 1 ) character ( 7 ) :: s6 ( 3 ) character ( 10 ) :: s7 ( 1 ) character ( 13 ) :: s7a ( 1 ) character ( 3 ) :: fmt , s8 ( 2 ) character ( 10 ) :: st integer k500 , k5000 ! call assert_init ( 'TEST_INTEGER' ) st = '' if ( sik == kind ( 0 )) st = ' (default)' call msg1 ( '  (' // tostring ( bit_size ( i1 )) // ' bit' // trim ( st ) // ' integers)' ) s1 ( 1 ) = '-8' // repeat ( '9' , irange - 1 ) // ', 8' // repeat ( '9' , irange - 1 ) ! s2 ( 1 ) = '----AB---' s2 ( 2 ) = '100,  -99' s2 ( 3 ) = '-99,    0' ! s3 ( 1 ) = 'a=12::-12' s3 ( 2 ) = '   1::  0' s3a ( 1 ) = 'a= 12,-12' s3a ( 2 ) = '    1,  0' ! s4 ( 1 ) = 'Longtitle' s4 ( 2 ) = '    1    ' s4 ( 3 ) = '   -2    ' ! s4a ( 1 ) = 'Longtitle' s4a ( 2 ) = '   1;-2  ' ! s5 ( 1 ) = 'X0' ! s6 ( 1 ) = '  XY  ' s6 ( 2 ) = '======' s6 ( 3 ) = ' 13-12' ! s7 ( 1 ) = 'ab=5  5000' s7a ( 1 ) = 'ab=   5  5000' ! s8 ( 1 ) = 'abc' s8 ( 2 ) = '500' ! ! Tests with default format call disp_set ( unit = 8 ) call disp ( i1 , sep = ', ' ); call compare ( s1 ) call disp ( 'AB' , i2 , style = 'pad' , sep = ',  ' ); call compare ( s2 ) call disp ( 'a=' , i3 , sep = '::' ); call compare ( s3 ) call disp ( 'Longtitle' , i4 , style = 'pad' , orient = 'col' ); call compare ( s4 ) call disp ( 'X' , i5 ); call compare ( s5 ) call disp ( 'XY' , i6 , style = '=underline' , sep = '' , trim = 'no' ); call compare ( s6 ) ! ! Tests with specified format write ( fmt , '(\"i\",i2)' ) irange + 1 call disp ( i1 , fmt , sep = ',' ); call compare ( s1 ) call disp ( 'AB' , i2 , 'i3' , style = 'pad' , sep = ',  ' ); call compare ( s2 ) call disp ( 'a=' , i3 , 'i3' , sep = ',' ); call compare ( s3a ) call disp ( 'Longtitle' , i4 , 'i2' , style = 'above' ); call compare ( s4 ) call disp ( 'Longtitle' , i4 , 'i2' , style = 'above' , orient = 'col' ); call compare ( s4 ) call disp ( 'Longtitle' , i4 , 'i2' , style = 'pad' , orient = 'row' , sep = ';' ); call compare ( s4a ) call disp ( 'X' , i5 , 'i1' ); call compare ( s5 ) call disp ( 'XY' , i6 , 'i3' , style = '=underline' , sep = '' ); call compare ( s6 ) ! ! Test 4 byte numbers if ( irange >= 4 ) then k500 = 500 k5000 = 5000 i7 = ( / 5 , k5000 / ) i8 = k500 call disp_set ( orient = 'row' ) ! Without format: call disp ( 'ab=' , i7 ); call compare ( s7 ) call disp ( 'abc' , i8 , style = 'pad' ); call compare ( s8 ) ! With format: call disp ( 'ab=' , i7 , 'i4' ); call compare ( s7a ) call disp ( 'abc' , i8 , 'i0' , style = 'above' ); call compare ( s8 ) endif call disp_set_factory end subroutine test_integer","tags":"","url":"proc/test_integer.html"},{"title":"test_logical – M_display","text":"subroutine test_logical() Arguments None Variables Type Visibility Attributes Name Initial logical(kind=logikind), public :: l1 (2,2) logical(kind=logikind), public :: l2 (1,2) logical(kind=logikind), public :: l3 (2,1) logical(kind=logikind), public :: l4 integer(kind=selected_int_kind(2)), public :: nbytes = 0 character(len=5), public, dimension(2) :: s1 character(len=5), public, dimension(2) :: s2 character(len=5), public, dimension(2) :: s3 character(len=5), public, dimension(2) :: s4 character(len=1), public :: s5 (1) Source Code subroutine test_logical ! Check that disp works for outputting logicals with explicit or default format logical ( logikind ) :: l1 ( 2 , 2 ) logical ( logikind ) :: l2 ( 1 , 2 ) logical ( logikind ) :: l3 ( 2 , 1 ) logical ( logikind ) :: l4 character ( 5 ), dimension ( 2 ) :: s1 , s2 , s3 , s4 character :: s5 ( 1 ) integer ( selected_int_kind ( 2 )) :: nbytes = 0 l1 = reshape (( / . true ., . true ., . false ., . false . / ), ( / 2 , 2 / )) l2 = reshape (( / . false ., . true . / ), ( / 1 , 2 / )) l3 = reshape (( / . true ., . false . / ), ( / 2 , 1 / )) l4 = . true . nbytes = int ( size ( transfer ( l4 , ( / nbytes / ))), selected_int_kind ( 2 )) ! call assert_init ( 'TEST_LOGICAL' ) call msg1 ( '  (' // tostring ( int ( nbytes )) // ' byte logicals)' ) s1 = ( / ' T, F' ,& & ' T, F' / ) s2 = ( / 'T  F ' ,& & 'T  F ' / ) s3 = ( / 'title' ,& & 'F  T ' / ) s4 = ( / 'A = T' ,& & '    F' / ) s5 = ( / 'T' / ) ! call disp_set ( unit = 8 ) !SPECIFIED FORMAT: call disp ( l1 , 'L2' , sep = ',' ); call compare ( s1 ) call disp ( 'title' , l2 , 'L1' , style = 'pad' ); call compare ( s3 ) call disp ( 'A = ' , l3 , 'L1' ); call compare ( s4 ) !DEFAULT FORMAT: call disp ( l1 ); call compare ( s2 ) call disp ( 'title' , l2 , style = 'pad' ); call compare ( s3 ) call disp ( 'A = ' , l3 ); call compare ( s4 ) call disp ( l4 ); call compare ( s5 ) call disp_set_factory end subroutine test_logical","tags":"","url":"proc/test_logical.html"},{"title":"test_numbering – M_display","text":"subroutine test_numbering() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i integer(kind=sik), public :: i2 (2) = (/0, 0/) integer(kind=sik), public :: i3 (11) = (/(0, i=1, 11)/) integer(kind=sik), public :: i4 (1,2) = reshape((/0, 0/), (/1, 2/)) real(kind=srk), public :: r1 (2,2) = reshape((/2.146_srk, -1.231_srk, 0._srk, 0.33_srk/), (/2, 2/)) character(len=15), public :: s1a (3) character(len=15), public :: s1b (3) character(len=15), public :: s1c (3) character(len=15), public :: s1d (3) character(len=15), public :: s1e (3) character(len=15), public :: s1f (4) character(len=20), public :: s1g (3) character(len=9), public :: s2a (2) character(len=9), public :: s2b (2) character(len=9), public :: s2c (2) character(len=9), public :: s2d (2) character(len=9), public :: s2e (3) character(len=42), public :: s3c (2) character(len=9), public :: s4 (2) Source Code subroutine test_numbering integer :: i real ( srk ) :: r1 ( 2 , 2 ) = reshape (( / 2.146_srk , - 1.231_srk , 0._srk , 0.33_srk / ), ( / 2 , 2 / )) integer ( sik ) :: i2 ( 2 ) = ( / 0 , 0 / ), i3 ( 11 ) = ( / ( 0 , i = 1 , 11 ) / ), i4 ( 1 , 2 ) = reshape (( / 0 , 0 / ), ( / 1 , 2 / )) character ( 15 ) :: s1a ( 3 ), s1b ( 3 ), s1c ( 3 ), s1d ( 3 ), s1e ( 3 ), s1f ( 4 ) character ( 20 ) :: s1g ( 3 ) character ( 9 ) :: s2a ( 2 ), s2b ( 2 ), s2c ( 2 ), s2d ( 2 ), s2e ( 3 ), s4 ( 2 ) character ( 42 ) :: s3c ( 2 ) s1a = ( / '      1     2 ' ,& & '1   2.15  0.00' ,& & '2  -1.23  0.33' / ) s1b = ( / '     10    11 ' ,& & '1   2.15  0.00' ,& & '2  -1.23  0.33' / ) s1c = ( / '   10001  10002' ,& & '1    2.1    0.0' ,& & '2   -1.2    0.3' / ) s1d = ( / '    10   11 ' ,& & '1, 2.15,0.00' ,& & '2,-1.23,0.33' / ) s1e = ( / '    10    11 ' ,& & '1, 2.15, 0.00' ,& & '2,-1.23, 0.33' / ) s1f = ( / '------s1f-----' ,& & '      1     2 ' ,& & '1   2.15  0.00' ,& & '2  -1.23  0.33' / ) s1g = ( / '            1     2 ' ,& & 's1g = 1   2.15  0.00' ,& & '      2  -1.23  0.33' / ) ! s2a = ( / '1  2' ,& & '0  0' / ) s2b = ( / '-2  -1' ,& & ' 0   0' / ) s2c = ( / '1  0' ,& & '2  0' / ) s2d = ( / 'XX = 1  0' ,& & '     2  0' / ) s2e = ( / '-XX-' ,& & '1  0' ,& & '2  0' / ) s3c = ( / '-10  -9  -8  -7  -6  -5  -4  -3  -2  -1  0' ,& & '  0   0   0   0   0   0   0   0   0   0  0' / ) s4 = ( / '   1  2' ,& & '1  0  0' / ) ! call assert_init ( 'TEST_NUMBERING' ) call disp_set ( unit = 8 ) call disp ( r1 , 'F0.2' , style = 'number' ) ; call compare ( s1a ) call disp ( r1 , 'F0.2' , style = 'number' , lbound = ( / 1 , 10 / )) ; call compare ( s1b ) call disp ( r1 , 'F0.2' , lbound = ( / 1 , 10 / )) ; call compare ( s1b ) call disp ( r1 , 'F0.1' , lbound = ( / 1 , 10001 / )) ; call compare ( s1c ) call disp ( r1 , 'F0.2' , sep = ',' , lbound = ( / 1 , 10 / )) ; call compare ( s1d ) call disp ( r1 , 'F5.2' , sep = ',' , lbound = ( / 1 , 10 / )) ; call compare ( s1e ) call disp ( 's1f' , r1 , 'F0.2' , style = 'pad & number' ) ; call compare ( s1f ) call disp ( 's1g = ' , r1 , 'F0.2' , style = 'number' ) ; call compare ( s1g ) call disp ( i2 , style = 'number' , orient = 'row' ) ; call compare ( s2a ) call disp ( i2 , lbound = ( / 1 / ), orient = 'row' ) ; call compare ( s2a ) call disp ( i2 , lbound = ( /- 2 / ), orient = 'row' ) ; call compare ( s2b ) call disp ( i2 , style = 'number' ) ; call compare ( s2c ) call disp ( 'XX = ' , i2 , style = 'number' ) ; call compare ( s2d ) call disp ( 'XX' , i2 , style = 'pad & number' ) ; call compare ( s2e ) call disp ( i3 , lbound = ( /- 10 / ), orient = 'row' ) ; call compare ( s3c ) call disp ( i4 , style = 'number' ) ; call compare ( s4 ) end subroutine test_numbering","tags":"","url":"proc/test_numbering.html"},{"title":"test_real – M_display","text":"subroutine test_real() Arguments None Variables Type Visibility Attributes Name Initial character(len=12), public :: f1 (2) character(len=15), public :: f2 (2) character(len=13), public :: f3 (2) character(len=9), public :: f4 (3) character(len=18), public :: prc real(kind=srk), public :: r1 (2,2) = reshape((/2.146_srk, -1.231_srk, 0.008_srk, 20.33_srk/), (/2, 2/)) real(kind=srk), public :: r2 (1,2) = reshape((/12.0_srk, -1234.5678_srk/), (/1, 2/)) real(kind=srk), public :: r3 (2,1) character(len=6), public :: r3_2chr real(kind=srk), public :: r4 (1,1) = reshape((/0.0_srk/), (/1, 1/)) real(kind=srk), public :: r5 = 0.0_srk character(len=3), public :: rrangec integer, public :: rrng character(len=12), public :: s1 (2) character(len=17), public :: s2 (2) character(len=16), public :: s3 (2) character(len=17), public :: s3a (2) character(len=9), public :: s4 (3) Source Code subroutine test_real ! Check that disp works with reals real ( srk ) :: r1 ( 2 , 2 ) = reshape (( / 2.146_srk , - 1.231_srk , 0.008_srk , 2 0.33_srk / ), ( / 2 , 2 / )) real ( srk ) :: r2 ( 1 , 2 ) = reshape (( / 1 2.0_srk , - 123 4.5678_srk / ), ( / 1 , 2 / )) real ( srk ) :: r3 ( 2 , 1 ) real ( srk ) :: r4 ( 1 , 1 ) = reshape (( / 0.0_srk / ), ( / 1 , 1 / )) real ( srk ) :: r5 = 0.0_srk integer :: rrng ! character ( 3 ) rrangec character ( 6 ) r3_2chr ! character ( 12 ) :: s1 ( 2 ), f1 ( 2 ) character ( 13 ) :: f3 ( 2 ) character ( 15 ) :: f2 ( 2 ) character ( 16 ) :: s3 ( 2 ) character ( 17 ) :: s2 ( 2 ), s3a ( 2 ) character ( 9 ) :: s4 ( 3 ), f4 ( 3 ) character ( 18 ) :: prc ! call assert_init ( 'TEST_REAL' ) prc = '' if ( srk == kind ( 0.0 )) prc = ', single precision' if ( srk == kind ( 0 d0 )) prc = ', double precision' call msg1 ( '  (kind = ' // tostring ( srk ) // trim ( prc ) // ')' ) s1 ( 1 ) = ' 2.15   0.01' s1 ( 2 ) = '-1.23  20.33' f1 = s1 ! s2 ( 1 ) = '--------AB-------' s2 ( 2 ) = '   12.00,-1234.57' f2 ( 1 ) = '-------AB------' f2 ( 2 ) = '   12.0,-1234.6' ! ! A number close to the largest possible real ! (r3 could for example be [1.2e21, -2e37] for single precision and [1.2e21, -2e307] for double) rrng = min ( 999 , range ( 0.0_srk )) ! test not designed for numbers >= 10**1000. write ( rrangec , '(i3.3)' ) rrng s3 ( 1 ) = 'A =  1.20000E+21' s3a ( 1 ) = 'A =  1.20000E+021' s3 ( 2 ) = '    -2.00000E+' // rrangec ( 2 : 3 ) s3a ( 2 ) = '    -2.00000E+' // rrangec f3 ( 1 ) = 'A =  1.2E+021' f3 ( 2 ) = '    -2.0E+' // rrangec r3 ( 1 , 1 ) = 1.2e21 r3_2chr = '-2e' // rrangec read ( r3_2chr , * ) r3 ( 2 , 1 ) ! s4 ( 1 ) = 'Longtitle' s4 ( 2 ) = '---------' s4 ( 3 ) = ' 0.00000 ' f4 ( 1 ) = 'Longtitle' f4 ( 2 ) = '*********' f4 ( 3 ) = '   0.    ' ! ! Test calls without format (r2(1,:) tests vector): call disp_set ( unit = 8 , style = 'PAD' , sep = ',' ) call disp ( r1 , digmax = 4 , style = 'LEFT' , sep = '  ' ); call compare ( s1 , 'ok-1' ) call disp ( 'AB' , r2 , trim = 'no' ); call compare ( s2 , 'ok-2' ) call disp ( 'AB' , r2 ( 1 ,:), trim = 'no' , orient = 'row' ); call compare ( s2 , 'ok-3' ) call disp ( 'A = ' , r3 , style = 'left' ); if ( rrng <= 99 ) call compare ( s3 , 'ok-4' ) if ( rrng > 99 ) call compare ( s3a , 'ok-4' ) call disp ( 'Longtitle' , r4 , style = 'underline' ); call compare ( s4 , 'ok-6' ) call disp ( 'Longtitle' , r5 , style = 'underline' ); call compare ( s4 , 'ok-7' ) ! Test calls with format: call disp ( r1 , 'f5.2' , style = 'LEFT' , sep = '  ' ); call compare ( f1 , 'ok-8' ) call disp ( 'AB' , r2 , 'f7.1' ); call compare ( f2 , 'ok-9' ) call disp ( 'AB' , r2 ( 1 ,:), 'f7.1' , orient = 'row' ); call compare ( f2 , 'ok-10' ) call disp ( 'A = ' , r3 , 'es9.1e3' , style = 'left' ); call compare ( f3 , 'ok-11' ) call disp ( 'Longtitle' , r4 , 'f2.0' , style = '*underline' ); call compare ( f4 , 'ok-12' ) call disp_set_factory end subroutine test_real","tags":"","url":"proc/test_real.html"},{"title":"test_scalar_string – M_display","text":"subroutine test_scalar_string() Arguments None Variables Type Visibility Attributes Name Initial character(len=6), public :: shouldbe (7) Source Code subroutine test_scalar_string ! Test features with scalar-string (and missing item) character ( 6 ) shouldbe ( 7 ) ! call assert_init ( 'TEST_SCALAR_STRING' ) shouldbe = ( / & 'A     ' , & '      ' , & ' B   C' , & 'T     ' , & '-     ' , & 'D     ' , & 'E=E   ' / ) call disp_set ( unit = 8 ) call disp ( 'A' ) call disp () call disp ( 'B' , fmt = 'A2' , advance = 'no' ) call disp ( 'C' , advance = 'yes' ) call disp ( 'T' , 'D' , style = 'underline' ) call disp ( 'E=' , 'E' , advance = 'no' ) call disp ( advance = 'yes' ) call compare ( shouldbe , 'x' ) call disp_set_factory end subroutine test_scalar_string","tags":"","url":"proc/test_scalar_string.html"},{"title":"test_tostring – M_display","text":"subroutine test_tostring() Arguments None Variables Type Visibility Attributes Name Initial character(len=50), public :: s Source Code subroutine test_tostring character ( 50 ) s call assert_init ( 'TEST_TOSTRING' ) ! First test: call assert ( len ( tostring ( 1e23 , 'F0.2' )) == 26 . or . len ( tostring ( 1e23 , 'F0.2' )) == 27 ) s = tostring ( 1e23 , 'F0.2' ) call assert ( s ( 1 : 6 ) == '100000' . and . len_trim ( s ) == 27 . or . s ( 1 : 6 ) == '999999' . and . len_trim ( s ) == 26 ) ! Tests when factory defaults are in effect: call test_tostring_factory ! Tests of tostring when tostring_set is used to change defaults: call tostring_set ( sep = '::::' ) ; call scompare ( tostring (( / 1 , 2 , 3 / )), '1::::2::::3' ) call tostring_set ( ifmt = 'i3' ) ; call scompare ( tostring (( / 1 , 2 / )), '1::::2' ) call tostring_set ( trimb = 'NO' ) ; call scompare ( tostring (( / 1 , 2 / )), '  1::::  2' ) call tostring_set ( ifmt = 'i0' ) ; call scompare ( tostring (( / 1 , 2 / )), '1::::2' ) call tostring_set ( sep = '=1234567==' ) ; call scompare ( tostring (( / 1 , 2 / )), '1=1234567=2' ) call tostring_set ( rfmt = 'E7.1E2' ) ; call scompare ( tostring ( 1.0 ), '0.1E+01' ) call tostring_set ( rfmt = '1PE7.1E2' ) ; call scompare ( tostring ( 1.0 ), '1.0E+00' ) call tostring_set ( rfmt = '1PE6.0E2' ) ; call scompare ( tostring ( 1.0 ), '1.E+00' ) call tostring_set ( trimz = 'NONE' ) ; call scompare ( tostring ( 1.0 , 'F4.1' ), ' 1.0' ) call tostring_set ( trimz = 'ALL' ) ; call scompare ( tostring ( 1.0 , 'F4.1' ), ' 1' ) call tostring_set ( ifmt = 'i2' , sep = ',' ) ; call scompare ( tostring (( / 123 , 20 / )), '**,20' ) call tostring_set ( trimb = 'YES' ) ; call scompare ( tostring ( 1.0 , 'F4.1' ), '1' ) call tostring_set ( rfmt = 'F0.3' , ifmt = 'I4' , trimb = 'NO' , trimz = 'NONE' , sep = ';' ) call scompare ( tostring (( / 12345 , 123 / )) , '****; 123' ) call scompare ( tostring (( / 1.1239 , 12 3.45 / )), '1.124;123.450' ) call scompare ( tostring (( / ( 1.0_srk , 0.0_srk ),( 2.1_srk , - 8.7_srk ) / )), '1.000 + 0.000i;2.100 - 8.700i' ) call tostring_set_factory ! Confirm that behavior is back to original: call test_tostring_factory end subroutine test_tostring","tags":"","url":"proc/test_tostring.html"},{"title":"test_tostring_factory – M_display","text":"subroutine test_tostring_factory() Arguments None Source Code subroutine test_tostring_factory ! Tests of tostring when original defaults are in effect call assert ( len ( tostring ( 5.86 )) == 4 ) call scompare ( tostring ( 5.86 ) , '5.86' ) call scompare ( tostring ( 5.86e10 ) , '5.86E+10' , '5.86+010' ) call scompare ( tostring (( / 1 , 100 , 10000 / )) , '1, 100, 10000' ) call scompare ( tostring (( / 1. , 10 0. , 1000 0. / )) , '1, 100, 10000' ) call scompare ( tostring ( 1 0.8 , 'F8.3' ) , '10.800' ) call scompare ( tostring ( 1 0.8 , 'F   8  .   3' ) , '10.800' ) call scompare ( tostring ( 1 0.8 , 'F2.1' ) , '**' ) call scompare ( tostring ( 1 0.8 , 'U9.2' ) , 'Illegal format' ) call scompare ( tostring ( 1 0.8 , '333' ) , 'Illegal format' ) call scompare ( tostring ( 1 0.8 , 'ES' ) , 'Illegal format' ) call scompare ( tostring ( 1 0.8 , '2F' ) , 'Illegal format' ) call scompare ( tostring ( 1 0.8 , 'SP,1PG10.3' ) , '+10.8' ) call scompare ( tostring ( 1 0.8e9 , 'SP,1PG10.3E2' ) , '+1.08E+10' , '+1.08+010' ) call scompare ( tostring (( 1.23 , - 3.222 )) , '1.23 - 3.222i' ) call scompare ( tostring (( / ( 1 , 1 ),( 2 , 2 ) / )) , '1 + 1i, 2 + 2i' ) call scompare ( tostring (( / ( 1 , 1 ),( 2 , 2 ) / ), 'F4.1' ) , '1.0 + 1.0i, 2.0 + 2.0i' ) end subroutine test_tostring_factory","tags":"","url":"proc/test_tostring_factory.html"},{"title":"test_zeroas – M_display","text":"subroutine test_zeroas() Arguments None Variables Type Visibility Attributes Name Initial real(kind=srk), public :: d1 (3,2) = reshape((/2.146_srk, -1.231_srk, 1._srk, 0._srk, 20.33_srk, 0._srk/), (/3, 2/)) real(kind=srk), public :: d2 (2) = (/0._srk, 0._srk/) real(kind=srk), public :: d3 (2) = (/12e20_srk, 0._srk/) real(kind=srk), public :: d4 = 0._srk integer(kind=sik), public :: i1 (4) = (/1, 0, 11, 0/) integer(kind=sik), public :: i2 (2,2) = reshape((/0, 0, 11, 12/), (/2, 2/)) real(kind=srk), public :: r1 (3,2) = reshape((/2.146_srk, -1.231_srk, 1._srk, 0._srk, 20.33_srk, 0._srk/), (/3, 2/)) real(kind=srk), public :: r2 (2) = (/0._srk, 0._srk/) character(len=12), public :: s1a (3) character(len=12), public :: s1b (3) character(len=12), public :: s1c (3) character(len=12), public :: s1d (3) character(len=12), public :: s1e (3) character(len=12), public :: s1f (3) character(len=3), public :: s2 (1) character(len=16), public :: s3 (2) character(len=16), public :: s3a (2) character(len=9), public :: s4 (2) character(len=2), public :: s5 (4) character(len=5), public :: s6 (2) character(len=12), public :: s7 (3) character(len=5), public :: s8 (2) Source Code subroutine test_zeroas ! Test various features of using zeroas real ( srk ) :: d1 ( 3 , 2 ) = reshape (( / 2.146_srk , - 1.231_srk , 1._srk , 0._srk , 2 0.33_srk , 0._srk / ), ( / 3 , 2 / )) real ( srk ) :: d2 ( 2 ) = ( / 0._srk , 0._srk / ) real ( srk ) :: d3 ( 2 ) = ( / 1 2e20_srk , 0._srk / ) real ( srk ) :: d4 = 0._srk real ( srk ) :: r1 ( 3 , 2 ) = reshape (( / 2.146_srk , - 1.231_srk , 1._srk , 0._srk , 2 0.33_srk , 0._srk / ), ( / 3 , 2 / )) real ( srk ) :: r2 ( 2 ) = ( / 0._srk , 0._srk / ) integer ( sik ) :: i1 ( 4 ) = ( / 1 , 0 , 11 , 0 / ) integer ( sik ) :: i2 ( 2 , 2 ) = reshape (( / 0 , 0 , 11 , 12 / ), ( / 2 , 2 / )) character ( 12 ) :: s1a ( 3 ), s1b ( 3 ), s1c ( 3 ), s1d ( 3 ), s1e ( 3 ), s1f ( 3 ) character ( 3 ) :: s2 ( 1 ) character ( 16 ) :: s3 ( 2 ), s3a ( 2 ) character ( 9 ) :: s4 ( 2 ) character ( 2 ) :: s5 ( 4 ) character ( 5 ) :: s6 ( 2 ), s8 ( 2 ) character ( 12 ) :: s7 ( 3 ) ! s1a = ( / ' 2.15      *' ,& & '-1.23  20.33' ,& & ' 1.00      *' / ) s1b = ( / ' 2.15   0.  ' ,& & '-1.23  20.33' ,& & ' 1.00   0.  ' / ) s1c = ( / ' 2.15   000.' ,& & '-1.23  20.33' ,& & ' 1.00   000.' / ) s1d = ( / ' 2.15   .000' ,& & '-1.23  20.33' ,& & ' 1.00   .000' / ) s1e = ( / ' 2.1  zero  ' ,& & '-1.2  20.3  ' ,& & ' 1.0  zero  ' / ) s1f = ( / ' 2.1  zeroas' ,& & '-1.2    20.3' ,& & ' 1.0  zeroas' / ) ! s2 = '0,0' ! s3 ( 1 ) = 'A = 1.20000E+21' s3 ( 2 ) = '              0' ! s3a ( 1 ) = 'A = 1.20000+021' s3a ( 2 ) = '              0' ! s4 ( 1 ) = 'Longtitle' s4 ( 2 ) = '    0    ' ! s5 = ( / ' 1' , '  ' , '11' , '  ' / ) ! s6 = ( / '.  11' , '.  12' / ) ! s7 = ( / '   999  1000' , '1    .    11' , '2    .    12' / ) ! s8 = ( / '0  11' , '0  12' / ) ! call assert_init ( 'TEST_ZEROAS' ) call disp_set ( unit = 8 , style = 'PAD' , zeroas = '0' ) call disp ( d1 , digmax = 4 , zeroas = '*' ); call compare ( s1a ) call disp ( d1 , digmax = 4 , zeroas = '0.' ); call compare ( s1b ) call disp ( d1 , digmax = 4 , zeroas = '000.' ); call compare ( s1c ) call disp ( d1 , digmax = 4 , zeroas = '.000' ); call compare ( s1d ) call disp ( d1 , 'f4.1' , zeroas = 'zeroas' ); call compare ( s1e ) call disp ( d1 , digmax = 3 , zeroas = 'zeroas' ); call compare ( s1f ) call disp ( d2 , sep = ',' , orient = 'row' ); call compare ( s2 ) call disp ( 'A = ' , d3 , style = 'left' ); call compare ( s3 , 'zas' , s3a ) call disp ( 'Longtitle' , d4 ); call compare ( s4 ) call disp ( r1 , digmax = 4 , zeroas = '*' ); call compare ( s1a ) call disp ( r1 , digmax = 4 , zeroas = '0.' ); call compare ( s1b ) call disp ( r2 , sep = ',' , orient = 'row' ); call compare ( s2 ) call disp ( i1 , zeroas = ' ' ); call compare ( s5 ) call disp ( i2 , zeroas = '.' ); call compare ( s6 ) call disp ( i2 , zeroas = '.' , lbound = ( / 1 , 999 / )); call compare ( s7 ) call disp ( i2 , zeroas = '' ); call compare ( s8 ) call disp_set_factory end subroutine test_zeroas","tags":"","url":"proc/test_zeroas.html"},{"title":"tests_from_manual – M_display","text":"subroutine tests_from_manual() Arguments None Source Code subroutine tests_from_manual call assert_init ( 'TESTS_FROM_MANUAL' ) call tests_from_manual_1 call tests_from_manual_2 call tests_from_manual_3 call tests_from_manual_4 call tests_from_manual_5 end subroutine tests_from_manual","tags":"","url":"proc/tests_from_manual.html"},{"title":"tests_from_manual_1 – M_display","text":"subroutine tests_from_manual_1() Arguments None Variables Type Visibility Attributes Name Initial real, public :: A (4,4) character(len=36), public :: ANshouldbe (5) character(len=37), public :: Ashouldbe (4) real, public :: B (4,4) character(len=46), public :: Bshouldbe (4) complex, public :: C (3,3) character(len=55), public :: Cshouldbe (3) integer, public :: X (3,3) character(len=20), public :: XYshouldbe (3) integer, public :: Y (3) integer, public :: i integer, public :: j integer, public :: k Source Code subroutine tests_from_manual_1 ! Test examples in section 1 in the manual integer X ( 3 , 3 ) integer i , j , k , Y ( 3 ) real A ( 4 , 4 ), B ( 4 , 4 ) complex C ( 3 , 3 ) character ( 37 ) Ashouldbe ( 4 ) character ( 36 ) ANshouldbe ( 5 ) character ( 46 ) Bshouldbe ( 4 ) character ( 20 ) XYshouldbe ( 3 ) character ( 55 ) Cshouldbe ( 3 ) call assert_init ( '...section 1' ) A = reshape (( / (( real ( exp ( dble ( i + j - 1 ))) , i = 1 , 4 ), j = 1 , 4 ) / ), ( / 4 , 4 / )) B = reshape (( / (( real ( exp ( dble ( i * j ))), i = 1 , 4 ), j = 1 , 4 ) / ), ( / 4 , 4 / )) X = reshape (( / 7 , 8 , 3 , 4 , 0 , 2 , 1 , 3 , 6 / ), ( / 3 , 3 / ), order = ( / 2 , 1 / )) Y = ( / 11 , 2 , 7 / ) forall ( i = 1 : 3 , k = 1 : 3 ) C ( i , k ) = log ( cmplx ( - i * k )) ** k Ashouldbe = ( / & 'A =  2.72    7.39   20.09    54.60' , & '     7.39   20.09   54.60   148.41' , & '    20.09   54.60  148.41   403.43' , & '    54.60  148.41  403.43  1096.63' / ) ANshouldbe = ( / & '     1       2       3        4  ' , & '1   2.72    7.39   20.09    54.60' , & '2   7.39   20.09   54.60   148.41' , & '3  20.09   54.60  148.41   403.43' , & '4  54.60  148.41  403.43  1096.63' / ) Bshouldbe = ( / & '2.71828E+0  7.38906E+0  2.00855E+1  5.45981E+1' , & '7.38906E+0  5.45981E+1  4.03429E+2  2.98096E+3' , & '2.00855E+1  4.03429E+2  8.10308E+3  1.62755E+5' , & '5.45981E+1  2.98096E+3  1.62755E+5  8.88611E+6' / ) XYshouldbe = ( / & 'X = 7  8  3   Y = 11' , & '    4  0  2        2' , & '    1  3  6        7' / ) Cshouldbe = ( / & 'C = 0.000 + 3.142i  -9.389 +  4.355i  -31.203 - 19.631i' , & '    0.693 + 3.142i  -7.948 +  8.710i  -47.300 -  0.749i' , & '    1.099 + 3.142i  -6.659 + 11.258i  -54.449 + 14.495i' / ) call disp_set ( unit = 8 ) call disp ( 'A = ' , A ) call compare ( Ashouldbe , '1-A' ) call disp ( A , style = 'number' ) call compare ( ANshouldbe , '1-A' ) ! call disp ( B ) call compare ( Bshouldbe , '1-B' ) ! call disp ( 'X = ' , X , ADVANCE = 'no' ) call disp ( 'Y = ' , Y ) call compare ( XYshouldbe , '1-XY' ) ! call disp ( 'C = ' , C , 'F0.3' ) call compare ( Cshouldbe , '1-C' ) ! call disp_set_factory end subroutine tests_from_manual_1","tags":"","url":"proc/tests_from_manual_1.html"},{"title":"tests_from_manual_2 – M_display","text":"subroutine tests_from_manual_2() Arguments None Variables Type Visibility Attributes Name Initial real, public :: A (3) = (/1.2345, 2.3456, 3.4567/) character(len=29), public :: S Source Code subroutine tests_from_manual_2 ! Test examples in section 2 in the manual REAL :: A ( 3 ) = ( / 1.2345 , 2.3456 , 3.4567 / ) CHARACTER ( 29 ) S call assert_init ( '...section 2' ) CALL DISP ( 'A = ' , A , UNIT = 8 , SEP = ', ' , ORIENT = 'ROW' ) rewind ( 8 ) read ( 8 , 1 ) S call msg2 ( S ) call assert ( S == 'A = 1.23450, 2.34560, 3.45670' , '2' ) call reopen_8 1 format ( A ) end subroutine tests_from_manual_2","tags":"","url":"proc/tests_from_manual_2.html"},{"title":"tests_from_manual_3 – M_display","text":"subroutine tests_from_manual_3() Arguments None Variables Type Visibility Attributes Name Initial real, public :: A (0:3,0:3) real, public :: B (4,4) real, public :: Matr (2,2) = reshape((/1.2, 5.6, 4.2, 18.3/), (/2, 2/)) integer, public :: i integer, public :: j integer, public :: k real, public :: pe (2,3) character(len=35), public :: shouldbe_A (5) character(len=74), public :: shouldbe_D (4) character(len=57), public :: shouldbe_E (4) character(len=20), public :: shouldbe_F (3) character(len=24), public :: shouldbe_I (6) character(len=63), public :: shouldbe_zas (4) integer, public :: uv (3) real, public :: x (2,2) integer, public :: xy (3,3) real, public :: z (2,3) = reshape((/14.28, 1.42, 14285714.0, 141421.0, 0.47, 0.69/), (/2, 3/)) Source Code subroutine tests_from_manual_3 ! Test examples in section 3 in the manual real :: Matr ( 2 , 2 ) = reshape ( ( / 1.2 , 5.6 , 4.2 , 1 8.3 / ), ( / 2 , 2 / ) ) real :: z ( 2 , 3 ) = reshape (( / 1 4.28 , 1.42 , 1428571 4.0 , 14142 1.0 , 0.47 , 0.69 / ), ( / 2 , 3 / )) real :: x ( 2 , 2 ), pe ( 2 , 3 ) real :: A ( 0 : 3 , 0 : 3 ), B ( 4 , 4 ) integer xy ( 3 , 3 ), uv ( 3 ), i , j , k character ( 35 ) shouldbe_A ( 5 ) character ( 74 ) shouldbe_D ( 4 ) character ( 57 ) shouldbe_E ( 4 ) character ( 20 ) shouldbe_F ( 3 ) character ( 24 ) shouldbe_I ( 6 ) character ( 63 ) shouldbe_zas ( 4 ) call assert_init ( '...section 3' ) ! SECTION 3.1: call disp_set ( unit = 8 ) call disp ( - 4 4.6 , 'ES11.4E2' ) call disp ( - 4 4.6 , 'F8.4' ) call compare (( / '-4.4600E+01' , '-44.6000   ' / ), '3-A' ) ! CALL DISP ( 'str' , FMT = 'A4' ) CALL DISP ( 'str' , 'A4' ) call compare (( / ' str ' , 'strA4' / ), '3-B' ) ! ! SECTION 3.2: ! ! INTRODUCTION CALL DISP ( 'X=' , ( / 1 2.3 , 1 6.78 / ), DIGMAX = 3 , ORIENT = 'row' ) call compare (( / 'X=12.3  16.8' / ), '3-D' ) ! ! FMT_IMAG CALL DISP (( 1.31 , 2.47 ), 'F0.1' , 'F0.2' ) call compare (( / '1.3 + 2.47i' / ), '3-C' ) ! ! LBOUND forall ( i = 0 : 3 , j = 0 : 3 ) A ( i , j ) = real ( exp ( dble ( i + j - 1 ))) call disp ( A , style = 'number' , lbound = lbound ( A )) shouldbe_A = ( / & '     0       1       2        3  ' , & '0  0.368   1.000   2.718    7.389' , & '1  1.000   2.718   7.389   20.086' , & '2  2.718   7.389  20.086   54.598' , & '3  7.389  20.086  54.598  148.413' / ) call compare ( shouldbe_A ) call disp ( A , lbound = lbound ( A )) call compare ( shouldbe_A ) ! ! SEP CALL DISP ( reshape (( /- 1 , 5 , 5 , 10 / ),( / 2 , 2 / )), SEP = ', ' ) call compare (( / '-1,  5' , ' 5, 10' / ), '3-E' ) ! ! STYLE call disp ( 'a' , ( / 1 , 2 , 3 / ), style = '*underline' , orient = 'row' ) call compare (( / '   a   ' , '*******' , '1  2  3' / )) ! call disp_set ( matsep = '    ' ) call disp ( 'Matr = ' , Matr , digmax = 3 , Style = 'left' , advance = 'no' ) call disp ( 'Matr' , Matr , digmax = 3 , Style = 'pad' , advance = 'no' ) call disp ( 'Matr' , Matr , digmax = 3 , Style = 'underline' , advance = 'no' ) call disp ( Matr , digmax = 3 , Style = 'number' , advance = 'no' ) call disp ( 'Matr' , Matr , digmax = 3 , Style = '_pad & number' , advance = 'yes' ) shouldbe_D = ( / & 'Matr = 1.2   4.2    ---Matr--       Matr          1     2     ____Matr____' , & '       5.6  18.3    1.2   4.2    ---------    1  1.2   4.2        1     2 ' , & '                    5.6  18.3    1.2   4.2    2  5.6  18.3    1  1.2   4.2' , & '                                 5.6  18.3                    2  5.6  18.3' / ) call compare ( shouldbe_D , '3-F' ) ! ! TRIM call disp_set ( style = 'pad' , orient = 'row' , advance = 'no' , sep = ' ' , matsep = '   ' ) shouldbe_E = ( / & '----X----   -------Y------   -----U-----   -------V------' ,& '1  2    3      1    2    3   333 22 4444    333   22 4444' ,& '2 22   34      2   22   34                               ' ,& '3 32 1234      3   32 1234                               ' / ) xy = reshape (( / 1 , 2 , 3 , 2 , 22 , 32 , 3 , 34 , 1234 / ),( / 3 , 3 / )) uv = ( / 333 , 22 , 4444 / ) call disp ( 'X' , xy , trim = 'yes' ) call disp ( 'Y' , xy , trim = 'no' ) call disp ( 'U' , uv , trim = 'yes' ) call disp ( 'V' , uv , trim = 'no' , advance = 'yes' ) call compare ( shouldbe_E , '3-G' ) call disp_set_factory ; ! call disp_set ( style = 'above' , unit = 8 ) forall ( i = 1 : 2 , k = 1 : 3 ) pe ( i , k ) = real ( exp ( dble ( k ) ** i )) call disp ( 'power exponentials' , pe , trim = 'yes' ) shouldbe_F = ( / & ' power exponentials ' ,& '2.72   7.39    20.09' ,& '2.72  54.60  8103.08' / ) call compare ( shouldbe_F , '3-H' ) call disp_set_factory ; call disp_set ( unit = 8 ) ! x = reshape (( / 1.2e5 , 2.3e-3 , - 4.1e-2 , 8.6e1 / ), ( / 2 , 2 / )) call disp_set ( style = 'left' , sep = ' ' ) call disp ( 'X=' , x , 'es7.1e1' , trim = 'yes' ) call compare (( / 'X=1.2E+5 -4.1E-2' , '  2.3E-3  8.6E+1' / ), '3-I' ) call disp ( 'X=' , x , 'es7.1e1' , trim = 'no' ) call compare (( / 'X= 1.2E+5 -4.1E-2' , '   2.3E-3  8.6E+1' / ), '3-J' ) call disp_set_factory ; call disp_set ( unit = 8 ) ! ! ZEROAS forall ( i = 1 : 4 , j = 1 : 4 ) B ( i , j ) = max ( 0. , j - i + 1. ) where ( B > 0 ) B = 1 / B shouldbe_zas = ( / & 'A = 1.000  0.500  0.333  0.250   B = 1.000  0.500  0.333  0.250' , & '        0  1.000  0.500  0.333        .     1.000  0.500  0.333' , & '        0      0  1.000  0.500        .      .     1.000  0.500' , & '        0      0      0  1.000        .      .      .     1.000' / ) call disp ( 'A = ' , B , 'F0.3' , zeroas = '0' , advance = 'no' ) call disp ( 'B = ' , B , 'F0.3' , zeroas = '.' ) call compare ( shouldbe_zas , '3-ZAS' ) call disp_set_factory ; call disp_set ( unit = 8 ) ! ! SECTION 3.3: call disp ( 'TESTING NULL_UNIT -- THIS SHOULD NOT BE DISPLAYED' , unit = - 1 ) call disp ( 'TESTING NULL_UNIT -- THIS SHOULD NOT BE DISPLAYED' , unit = NULL_UNIT ) call assert ( ASTERISK_UNIT == - 3 , 'asterisk_unit' ) call assert ( PUTSTR_UNIT == - 2 , 'putstr_unit' ) call assert ( NULL_UNIT == - 1 , 'null_unit' ) ! ! SECTION 3.5 call disp ( 'F0.2' , z , 'f0.2' , style = 'pad' ) call disp ( \"F13.2, TRIM='yes'\" , z , 'f7.2' , style = 'pad' , trim = 'yes' ) shouldbe_I = ( / & & \"----------F0.2----------\" ,& & \"14.28  14285714.00  0.47\" ,& & \" 1.42    141421.00  0.69\" ,& & \"--F13.2, TRIM='yes'-    \" ,& & \"14.28  *******  0.47    \" ,& & \" 1.42  *******  0.69    \" / ) call compare ( shouldbe_I , '3-I' ) ! call disp_set_factory end subroutine tests_from_manual_3","tags":"","url":"proc/tests_from_manual_3.html"},{"title":"tests_from_manual_4 – M_display","text":"subroutine tests_from_manual_4() Arguments None Variables Type Visibility Attributes Name Initial type( disp_settings ), public :: ds character(len=15), public :: s (3) = (/'12.2 |  1.3 | 1', ' 9.6 | 13.0 | 3', '-2.0 |  4.0 | 4'/) real, public :: x (3) = (/12.2, 9.6, -2.0/) real, public :: y (3) = (/1.3, 13.0, 4.0/) integer, public :: z (3) = (/1, 3, 4/) Source Code subroutine tests_from_manual_4 ! Test examples in section 4 in the manual type ( disp_settings ) ds real :: x ( 3 ) = ( / 1 2.2 , 9.6 , - 2.0 / ), y ( 3 ) = ( / 1.3 , 1 3.0 , 4.0 / ) integer :: z ( 3 ) = ( / 1 , 3 , 4 / ) character ( 15 ) :: s ( 3 ) = ( / '12.2 |  1.3 | 1' ,& & ' 9.6 | 13.0 | 3' ,& & '-2.0 |  4.0 | 4' / ) call assert_init ( '...section 4' ) call test_disp_set1 call disp_set ( style = 'PAD' , sep = ' ' ) ds = disp_get () call assert ( ds % style == 'PAD' , '4a' ) call assert ( ds % sep == ' ' . and . ds % seplen == 1 , '4b' ) call disp_set_factory call disp_set ( unit = 8 , digmax = 3 ) call disp ( x , advance = 'no' ) call disp ( y , advance = 'no' ) call disp_set ( matsep = ' | ' ) call disp ( z , advance = 'yes' ) call compare ( s , '4c' ) call disp_xy ( reshape ( x ,( / 1 , 3 / )), reshape ( y ,( / 1 , 3 / ))) ds = disp_get () call assert ( ds % sep == ' ' . and . ds % digmax == 3 ) call compare (( / 'x=12.20,9.60,-2.00' , 'y=1.30,13.00,4.00 ' / ), '4d' ) call disp_set_factory end subroutine tests_from_manual_4","tags":"","url":"proc/tests_from_manual_4.html"},{"title":"tests_from_manual_5 – M_display","text":"subroutine tests_from_manual_5() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i character(len=50), public :: s character(len=*), public, parameter :: s1 = '1, 256, 6561, 65536, 3.90625+005' character(len=*), public, parameter :: s2 = '0.707107 + 0.707107i, 0.840896 + 0.840896i' character(len=*), public, parameter :: s4 = '1.1, 2.2+010, 3.3+020' real(kind=srk), public :: sr real, public :: x = 1.5 Source Code subroutine tests_from_manual_5 ! Test examples in section 5 in the manual character ( 50 ) s integer i real ( srk ) sr character ( * ), parameter :: & ! Alternative results: s1 = '1, 256, 6561, 65536, 3.90625+005' , & s2 = '0.707107 + 0.707107i, 0.840896 + 0.840896i' , & s4 = '1.1, 2.2+010, 3.3+020' real :: x = 1.5 ! call assert_init ( '...section 5' ) call disp_set ( unit = 8 ) ! ! SECTIONS 5.1-5.3 call disp ( 'The square of ' // tostring ( x ) // ' is ' // tostring ( x * x )) call compare (( / 'The square of 1.5 is 2.25' / )) CALL TOSTRING_SET ( SEP = '; ' ) s = tostring (( / 1 , 2 / )) ; call scompare ( s , '1; 2' ) call tostring_set_factory ! ! SECTION 5.4 s = tostring ( atan ( 1.0 )) ; call tscompare ( s , ( / 0.785398 / ), '1a' ) !tostring(exp((/-3d0,-1d0,0d0,1d0/))) see (*) below s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 ) ; call scompare ( s , '1, 256, 6561, 65536, 3.90625E+05' , s1 ) s = tostring (( / 1.23456 , 1.2300 , 1.23456e6 / )) ; call tscompare ( s , ( / 1.23456 , 1.23 , 1.23456E+06 / ), '1c' ) s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 , 'f0.1' ) ; call scompare ( s , '1.0, 256.0, 6561.0, 65536.0, 390625.0' ) s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 , 'f6.1' ) ; call scompare ( s , '1.0, 256.0, 6561.0, ******, ******' ) s = tostring (( / 120000 0. , - 1.2e-9 / )) ; call scompare ( s , '1.2E+06, -1.2E-09' ) ! s = tostring ( - 77 ) ; call scompare ( s , '-77' ) s = tostring (( / ( i , i =- 3 , 3 ) / ) ** 11 ) ; call scompare ( s , '-177147, -2048, -1, 0, 1, 2048, 177147' ) s = tostring (( / ( i , i =- 3 , 3 ) / ) ** 11 , 'i7' ) ; call scompare ( s , '-177147, -2048, -1, 0, 1, 2048, 177147' ) s = tostring (( / ( i , i =- 3 , 3 ) / ) ** 11 , 'i4' ) ; call scompare ( s , '****, ****, -1, 0, 1, 2048, ****' ) ! s = tostring (( 1 , 3 ) / ( 4 , 2 )) ; call scompare ( s , '0.5 + 0.5i' ) s = tostring ( cmplx (( /- 1 , - 2 / )) ** 0.25 ) ; call scompare ( s , '0.70711 + 0.70711i, 0.8409 + 0.8409i' , s2 ) ! s = tostring (( / . true ., . false ., . false . / )) ; call scompare ( s , 'T, F, F' ) s = tostring (. true ., 'L2' ) ; call scompare ( s , 'T' ) ! call tostring_set ( sep = ';' ) s = tostring (( / 1 , 2 , 30 / )) ; call scompare ( s , '1;2;30' ) ! call tostring_set ( trimb = 'NO' ) s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 , 'f6.1' ) ; call scompare ( s , '   1.0; 256.0;6561.0;******;******' ) s = tostring (( / 1 , 2 , 30 / ), 'i3' ) ; call scompare ( s , '  1;  2; 30' ) s = tostring (( / ( i , i =- 3 , 3 ) / ) ** 11 , 'i4' ) ; call scompare ( s , '****;****;  -1;   0;   1;2048;****' ) s = tostring (( / 1 , 2 , 30 / ), 'i0' ) ; call scompare ( s , '1;2;30' ) s = tostring (. true ., 'L3' ) ; call scompare ( s , '  T' ) ! call tostring_set ( trimz = 'NONE' , sep = ', ' , trimb = 'YES' ) s = tostring ( real (( / ( i , i = 1 , 4 ) / )) ** 8 ) ; call tscompare ( s , ( / 1. , 25 6. , 656 1. , 6553 6. / ), '1d' ) s = tostring (( / 1.23456 , 1.2300 , 1.23456e6 / )) ; call tscompare ( s , ( / 1.23456 , 1.23 , 1.23456E+06 / ), '1e' ) if ( range ( 0._srk ) >= 103 ) then s = '1.2d103' read ( s , * ) sr s = tostring ( sr , 'ES11.5' ) ; call scompare ( s , '1.20000+103' ) call tostring_set ( trimz = 'ALL' ) s = tostring ( sr ) ; call scompare ( s , '1.2+103' ) s = tostring (( / 1.1_srk , 2.2e10_srk , 3.3e20_srk / )) ; call scompare ( s , '1.1, 2.2E+10, 3.3E+20' , s4 ) s = tostring ( exp (( /- 3._srk , - 1._srk , 0._srk , 1._srk / ))); call tscompare ( s , ( / 4.97871E-02 , 0.36788 , 1. , 2.71828 / ), '1b' ) ! (*) endif ! call tostring_set ( trimz = 'ALL' ) s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 , 'f0.1' ) ; call scompare ( s , '1, 256, 6561, 65536, 390625' ) ! call tostring_set ( rfmt = 'G12.4E2' ) s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 ) ; call scompare ( s , '1, 256, 6561, 0.6554E+05, 0.3906E+06' ) s = tostring (( / 120000 0. , - 1.2e-9 / )) ; call scompare ( s , '0.12E+07, -0.12E-08' ) ! call disp_set_factory call tostring_set_factory end subroutine tests_from_manual_5","tags":"","url":"proc/tests_from_manual_5.html"},{"title":"tscompare – M_display","text":"subroutine tscompare(s, vec, msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s real, intent(in) :: vec (:) character(len=*), intent(in) :: msg Variables Type Visibility Attributes Name Initial integer, public :: i real, public :: svec (size(vec)) Source Code subroutine tscompare ( s , vec , msg ) character ( * ), intent ( in ) :: s , msg real , intent ( in ) :: vec (:) real svec ( size ( vec )) integer i read ( s , * ) svec do i = 1 , size ( vec ) call assert ( abs ( vec ( i ) - svec ( i )) / abs ( vec ( i )) < 1e-4 , 'tscompare:' // msg ) enddo end subroutine tscompare","tags":"","url":"proc/tscompare.html"},{"title":"w4blnk – M_display","text":"subroutine w4blnk() Arguments None Source Code subroutine w4blnk ! Write 4 blanks write ( * , '(\"    \")' , advance = 'no' ) end subroutine w4blnk","tags":"","url":"proc/w4blnk.html"},{"title":"M_display__PUTSTRMODULE – M_display","text":"M_display, A FORTRAN 95 MODULE FOR PRETTY-PRINTING MATRICES. o  Version number 1.02 6-Sept-2008\no  Version number 2.00 31-Oct-2017, f2003 version; John S. Urban Copyright (c) 2008, Kristjan Jonasson, Dept. of Computer Science, University of\n   Iceland (jonasson@hi.is). This software is free. For details see the file README. AUTHOR Based on dispmodule(3f), “A Fortran 95 module for pretty-printing matrices”.\n   Version number 1.02 6-Sept-2008,\n   Kristjan Jonasson, Department of Computer Science,\n   School of Science and Engineering, University of Iceland,\n   Hjardarhaga 4, 107 Reykjavik, Iceland (jonasson@hi.is). Variables Type Visibility Attributes Name Initial integer, public, parameter :: DEFAULT_UNIT = -3 Subroutines public  subroutine putnl () Arguments None public  subroutine putstr (s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s","tags":"","url":"module/m_display__putstrmodule.html"},{"title":"M_display__UTIL – M_display","text":"NAME M_display(3f) - [M_display::INTRO] module for pretty-printing matrices INTRODUCTION M_display is a standard Fortran 95 module for quick and easy displaying\n of numbers, vectors or matrices using default or specified format. It\n can be useful for debugging purposes, for preliminary display of\n numerical results, and even for final display of such results in cases\n when carefully formatted tables are not needed. It is comparable to the\n automatic matrix printing of Matlab, S and R, but offers substantially\n more control over the format used. The module can handle the standard Fortran data types integer, single\n precision, double precision, complex, logical and character. Integer,\n real, complex and logical data of other than default kind are supported\n with add-on modules. The module contains the following public procedures: Subroutine DISP                  The main procedure used for displaying items\n Subroutine DISP_SET              Used to change default settings for DISP\n Subroutine DISP_SET_FACTORY      Restores DISP-settings to original (factory) default\n Function DISP_GET                Returns a structure with current DISP-settings\n Function TOSTRING                Returns a string representation of a scalar or vector\n Subroutine TOSTRING_SET          Used to change default settings for TOSTRING\n Subroutine TOSTRING_SET_FACTORY  Restores TOSTRING-settings to original default In addition the module defines a public derived type, DISP_SETTINGS,\n used for saving and restoring settings for DISP. The procedures DISP and\n TOSTRING have a generic interface and optional arguments, so the same\n subroutine / function name, is used to display items of different data\n types and ranks, with or without labels, and using default or specified\n format. Similarly DISP_SET is generic and can be used both to change\n individual settings and to restore previously saved settings. The most basic calling syntax for displaying is CALL DISP(expression)\n which will display the expression with default format. The format\n may be specified with CALL DISP(expression, edit- descriptor), and\n CALL DISP(title, expression) will label the displayed item with a\n title. Examples are CALL DISP(A), CALL DISP(A,’F9.3’), CALL DISP(‘A=’,A)\n and CALL DISP(‘A=’,A,’F9.3’), the last one specifying both title and\n format. If aij = exp(i + j - 1), i, j = 1,…,4, then CALL DISP(‘A =\n ‘, A) writes out: > A =  2.72    7.39   20.09    54.60\n  >      7.39   20.09   54.60   148.41\n  >     20.09   54.60  148.41   403.43\n  >     54.60  148.41  403.43  1096.63 and if bij = exp(i*j) the result of CALL DISP(B) is: > 2.71828E+0  7.38906E+0  2.00855E+1  5.45981E+1\n  > 7.38906E+0  5.45981E+1  4.03429E+2  2.98096E+3\n  > 2.00855E+1  4.03429E+2  8.10308E+3  1.62755E+5\n  > 5.45981E+1  2.98096E+3  1.62755E+5  8.88611E+6. It is also possible to number the rows and columns: CALL DISP(A,\n STYLE=’NUMBER’) will give: >      1       2       3        4\n  > 1   2.72    7.39   20.09    54.60\n  > 2   7.39   20.09   54.60   148.41\n  > 3  20.09   54.60  148.41   403.43\n  > 4  54.60  148.41  403.43  1096.63. The selection between F and E editing depends on the size of the largest\n displayed element as discussed in section 3.2 below. Among the settings\n that may be controlled is the spacing between columns, the number\n of significant digits, the placement of the label, and the file unit\n where the output goes. Items can in addition be displayed side by side,\n for example: > CALL DISP('X = ', X, ADVANCE='NO')\n  > CALL DISP('Y = ', Y) which might output: > X = 7  8  3   Y = 11\n  >     4  0  2        2\n  >     1  3  6        7 Complex numbers are formatted as illustrated by: > COMPLEX C(3,3) > FORALL(I=1:3, K=1:3) C(I,K)=LOG(CMPLX(-I*K))**K > CALL DISP('C = ', C, 'F0.3') which will display > C = 0.000 + 3.142i   -9.389 +  4.355i   -31.203 - 19.631i\n  >     0.693 + 3.142i   -7.948 +  8.710i   -47.300 -  0.749i\n  >     1.099 + 3.142i   -6.659 + 11.258i   -54.449 + 14.495i infinite and not-a-number real values are supported and displayed as nan,\n +inf or -inf. the remaining sections in this user manual contain detailed information\n on using the module. section 2 discusses the basics of using the\n module, including use statements, compiling and linking, and add-on\n modules supporting non-default kinds of data. section 3 gives a detailed\n description of the generic subroutine disp. all the possible arguments\n are listed and the purpose of each one described. section 4 describes\n how to change various settings that control how items are displayed with\n disp. section 5 describes the function tostring which may be used to\n change numbers to strings. finally testing of the module is discussed\n in section 6. OVERVIEW OF MODULES The file M_display.f90 actually begins with two auxiliary modules,\n M_display__PUTSTRMODULE and M_display__UTIL. The first one contains two dummy\n subroutines, PUTSTR and PUTNL, which do nothing, but must be incorporated\n to avoid an “undefined symbol” link error. In addition it defines the\n named constant (parameter) DEFAULT_UNIT = -3, which makes the asterisk\n unit (usually the screen) the default to display on. Alternatively the user can write his own M_display__PUTSTRMODULE as described\n below. An example is near the beginning of M_display.f90 (commented out)\n and also in the file putstrmodule_mex.f90, enclosed with the package. It\n may be used (commented in instead of the default one) to allow Matlab\n mex files to display in the Matlab command window. AN EXAMPLE PROGRAM Following is a short example program that uses the package: program example\n     use M_display\n     real :: a(3) = [ 1.2345, 2.3456, 3.4567 ]\n     call disp('A = ', A, SEP=', ', ORIENT = 'ROW')\n   end program example The program should write out “A = 1.23450, 2.34560, 3.45670”. A longer example program: program demo_M_display use M_display implicit none integer , parameter :: rk = selected_real_kind ( 6 ), n = 3 real ( rk ) :: a ( n , n ), b ( n , n ), x integer i , j , k ( 5 ) call disp_set ( advance = ' double ' ) forall ( i = 1 : n , j = 1 : n ) a ( i , j ) = exp ( real ( i + j - 1 , rk )) b ( i , j ) = exp ( real ( i ** j , rk )) end forall call disp ( ' A = ' , a ) call disp ( b ) call disp ( a ( 1 : 2 ,:), ' f0 .5 ' ) call disp ( ' MATRIX ' , a , style = ' UNDERLINE & NUMBER ' , unit = - 3 , digmax = 4 ) k = [ - 3 , 0 , 12 , 14 , 0 ] call disp ( 'K' , k , style = ' pad ' , orient = ' row ' , sep = ' ' , zeroas = '.' ) x = 1.5 call disp ( ' The square of ' //tostring(x)//' is '//tostring(x*x)) call disp_set ( matsep = ' | ' ) call disp ([ 11 , 12 , 13 ], advance = ' no ' ) call disp ([. true ., . false ., . true .], advance = ' no ' ) call disp ([ 'A' , 'B' , 'C' ]) end program demo_M_display Expected results: > A =  2.718   7.389   20.086\n >      7.389  20.086   54.598\n >     20.086  54.598  148.413\n >\n > 2.71828E+00  2.71828E+00  2.71828E+00\n > 7.38906E+00  5.45982E+01  2.98096E+03\n > 2.00855E+01  8.10308E+03  5.32048E+11\n >\n > 2.71828   7.38906  20.08554\n > 7.38906  20.08554  54.59815\n >\n >        MATRIX\n > --------------------\n >      1     2      3\n > 1   2.7   7.4   20.1\n > 2   7.4  20.1   54.6\n > 3  20.1  54.6  148.4\n >\n > ------K-----\n > -3 . 12 14 .\n >\n > The square of 1.5 is 2.25\n >\n > 11 | T | A\n > 12 | F | B\n > 13 | T | C AUTHOR Based on dispmodule ( 3 f ), \"A Fortran 95 module for pretty-printing matrices\" . Version number 1.02 6 - Sept - 2008 , Kristjan Jonasson , Dept . of Computer Science , University of Iceland ( jonasson @hi . is ). Uses M_display__PUTSTRMODULE Variables Type Visibility Attributes Name Initial type( disp_settings ), public, save :: DEFSET type( disp_settings ), public, save :: FACTORY_SETTINGS character(len=*), public, parameter :: errormsg = 'Illegal format' type( tostring_settings ), public, save :: tosfac type( tostring_settings ), public, save :: tosset Derived Types type, public :: boxlist Components Type Visibility Attributes Name Initial type( boxnode ), public, pointer :: firstbox => null() type( boxnode ), public, pointer :: lastbox => null() type( boxlist ), public, pointer :: nextboxlist => null() integer, public :: unit = 1 type, public :: boxnode Components Type Visibility Attributes Name Initial character(len=1), public, pointer :: box (:,:) type( boxnode ), public, pointer :: nextbox => null() type, public :: disp_settings Components Type Visibility Attributes Name Initial character(len=6), public :: advance = 'YES' integer, public :: digmax = 6 character(len=9), public :: matsep = '   ' integer, public :: matseplen = 3 character(len=3), public :: orient = 'COL' character(len=9), public :: sep = '  ' integer, public :: seplen = 2 character(len=20), public :: style = 'LEFT' character(len=4), public :: trim = 'AUTO' integer, public :: unit = DEFAULT_UNIT integer, public :: zaslen = 0 character(len=9), public :: zeroas = '' type, public :: settings Components Type Visibility Attributes Name Initial integer, public :: adv integer, public :: d integer, public :: dmx character(len=22), public :: ed logical, public :: gedit integer, public :: lsep integer, public :: lun integer, public :: lzas integer, public :: m1 integer, public :: n1 logical, public :: number logical, public :: row character(len=9), public :: sep character(len=1), public :: tch logical, public :: trm character(len=9), public :: tsty logical, public :: vec integer, public :: w character(len=9), public :: zas type, public :: tostring_settings Components Type Visibility Attributes Name Initial character(len=10), public :: ifmt = 'I0' character(len=16), public :: rfmt = '1PG12.5' character(len=9), public :: sep = ', ' integer, public :: seplen = 2 character(len=3), public :: trimb = 'YES' character(len=4), public :: trimz = 'G' Functions public pure function nnblk (s) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value integer public pure function upper (s) result(su) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value character(len=len(s)) Subroutines public  subroutine check_settings () Arguments None public  subroutine copyseptobox (sep, m, lin1, boxp, wleft) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: sep integer, intent(in) :: m integer, intent(in) :: lin1 character(len=1), intent(inout) :: boxp (:,:) integer, intent(inout) :: wleft public  subroutine copytobox (s, lin1, widj, widpj, nblj, boxp, wleft) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (:) integer, intent(in) :: lin1 integer, intent(in) :: widj integer, intent(in) :: widpj integer, intent(in) :: nblj character(len=1), intent(inout) :: boxp (:,:) integer, intent(inout) :: wleft public  subroutine disp_errmsg (s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s public  subroutine find_editdesc_real (exp, expm, dmx, edesc, flen, ndec, posit) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: exp integer, intent(in) :: expm integer, intent(in) :: dmx character(len=14), intent(out) :: edesc integer, intent(out) :: flen integer, intent(out) :: ndec logical, intent(in) :: posit public  subroutine finishbox (title, SE, boxp) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title type( settings ), intent(in) :: SE character(len=1), intent(inout) :: boxp (:,:) public  subroutine get_SE (SE, title, shapex, fmt, advance, lbound, separator, style, trim, unit, orient, zeroas, digmax) Arguments Type Intent Optional Attributes Name type( settings ), intent(out) :: SE character(len=*), intent(in) :: title integer, intent(in) :: shapex (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: separator character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient character(len=*), intent(in), optional :: zeroas integer, intent(in), optional :: digmax public  subroutine preparebox (title, SE, m, n, wid, widp, lin1, wleft, boxp) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title type( settings ), intent(in) :: SE integer, intent(in) :: m integer, intent(in) :: n integer, intent(inout) :: wid (:) integer, intent(out) :: widp (:) integer, intent(out) :: lin1 integer, intent(out) :: wleft character(len=1), pointer :: boxp (:,:) public pure subroutine readfmt (fmt, fmt1, w, d, gedit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fmt character(len=*), intent(out) :: fmt1 integer, intent(out) :: w integer, intent(out) :: d logical, intent(out) :: gedit public pure subroutine replace_w (fmt, wnew) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: fmt integer, intent(in) :: wnew public  subroutine replace_zeronaninf (s, zas, maskz, masknan, maskminf, maskinf) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: s (:) character(len=*), intent(in) :: zas logical, intent(in) :: maskz (:) logical, intent(in), optional :: masknan (:) logical, intent(in), optional :: maskminf (:) logical, intent(in), optional :: maskinf (:) public  subroutine tostring_check_settings () Arguments None public pure subroutine tostring_get (sa, st) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: sa (:) character(len=*), intent(out) :: st public pure subroutine tostring_get_complex (sar, sgn, sai, st) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: sar (:) character(len=*), intent(in) :: sgn (*) character(len=*), intent(in) :: sai (:) character(len=*), intent(out) :: st public pure subroutine trim_real (sa, gedit, w) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: sa (:) logical, intent(in) :: gedit integer, intent(in) :: w public pure subroutine trim_s_real (sa, gedit, w) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: sa logical, intent(in) :: gedit integer, intent(in) :: w","tags":"","url":"module/m_display__util.html"},{"title":"M_display – M_display","text":"Uses M_display__UTIL Variables Type Visibility Attributes Name Initial integer, public, parameter :: ASTERISK_UNIT = -3 integer, public, parameter :: NULL_UNIT = -1 integer, public, parameter :: PUTSTR_UNIT = -2 Interfaces public        interface disp NAME disp ( 3 f ) - [ M_display ] pretty - print a matrix DESCRIPTION This is the principal subroutine of the package. It has various control\n arguments that specify the exact format of the output. Most of these\n may also be used as arguments of the subroutine DISP_SET. When used\n with DISP, a control argument affects only the item being displayed with\n the current call, but when used with DISP_SET, the default settings for\n subsequent DISP calls are affected. The default values for individual\n arguments given below are used unless they have been changed by a call\n to DISP_SET. All character arguments should be of type default character. Simple Calls: call disp\n   call disp(x)\n   call disp(title, x)\n   call disp(x, fmt)\n   call disp(title, x, fmt) The first call advances to the next line, and the other calls display X\n on the default unit (the unit may be changed with the UNIT argument). The\n default putstrmodule (see section 2) sets the asterisk unit (usually the\n screen) to be default. The purpose of individual arguments is as follows: X      The item to be displayed. X may be scalar, vector or matrix\n        (i.e. of rank <= 2) and the following kinds of data are supported: default integer\n       default real (or single precision, real(kind(1.0)))\n       double precision real (or real(kind(1d0)))\n       default complex (or complex(kind(1.0)))\n       double precision complex (or complex(kind(1d0)))\n       default logical\n       default character\n\n    With the add-on modules described in section 2.3 other kinds may\n    be displayed. Matrices are displayed in traditional mathematical\n    order, so the rows displayed are X(1,:), X(2,:) etc. Vectors are\n    by default displayed as column vectors (but a row orientation may\n    be specified with the ORIENT argument). An SS edit descriptor is\n    applied automatically so positive elements are not prefixed with\n    a + sign (the Fortran standard makes outputting a + sign optional). TITLE  Provides a label for X. The label prefixes X by default but this\n        may be changed with the STYLE argument (see examples in section\n        3.2). When X is absent TITLE must also be absent. FMT    When present, FMT should contain an edit descriptor that will be\n        used to format each element of X (or the real parts of X in case\n        X is complex and FMT_IMAG is present; see below). The possible\n        edit descriptors are: Fw . d , Dw . d , Ew . dEe , ENw . dEe , ESw . dEe : real data ( the Ee suffixes are optional ) Iw , Bw , Ow , Zw : integer data ( all may be suffixed with . m ) Lw : logical data A , Aw : character data Gw . d , Gw . dEe : any data Example calls for numeric X are CALL DISP ( X , ' ES11 .4 ' ) and CALL DISP ( ' X = ' , X , ' F8 .4 ' ). If X is a scalar string ( i . e . of rank 0 ) and TITLE is absent FMT must be specified with a keyword ( otherwise the call is taken to have TITLE and X ): CALL DISP ( ' str ' , FMT = ' A4 ' ) displays \"str\" but CALL DISP ( ' str ',' A4 ' ) displays \"strA4\" ). If FMT is absent , each element of X is formatted with a default edit descriptor . When X is of type logical the default is L1 and when it is of type character the default is A ( which is equivalent to Aw where w = LEN ( X )). For integer data the default is Iw where w is exactly big enough to accommodate both the largest positive and the largest negative values in X . For real and complex data the default also depends on the largest absolute values in X , as detailed in the DIGMAX - paragraph in section 3.2 . The format used for complex numbers is demonstrated in the introduction above . CALL WITH COMPLETE LIST OF ARGUMENTS CALL DISP(TITLE, X, FMT, FMT_IMAG, ADVANCE, DIGMAX, LBOUND, ORIENT,\n   SEP, STYLE, TRIM, UNIT, ZEROAS) All dummy arguments are optional and some of them are incompatible\n with some data types of X. The arguments control how X is displayed,\n as described in section 3.1 and below. For the character arguments\n ADVANCE and ORIENT the case of letters is ignored (so e.g. ADVANCE =\n ‘yes’ and ADVANCE = ‘YES’ are equivalent). Normally argument association\n for arguments after FMT (or FMT_IMAG) will be realized with argument\n keywords, e.g. CALL DISP(‘X=’, X, DIGMAX=3, ORIENT=’ROW’). When X is a\n scalar string FMT must also be associated with keyword, as mentioned in\n section 3.1. The most useful application of calling DISP with X absent is\n to advance to the next line or display an empty line. For this purpose,\n the only relevant arguments are UNIT, and ADVANCE with the value ‘YES’\n or ‘DOUBLE’. FMT_IMAG = edit-descriptor-imag  An edit descriptor for imaginary parts\n        of complex X. The statement CALL DISP((1.31,2.47),’F0.1’,’F0.2’)\n        will display “1.3 + 2.47i”. If FMT_IMAG is absent and FMT\n        is present then both real and imaginary parts are edited with\n        FMT. If both are absent, separate defaults are used, as explained\n        in the DIGMAX-paragraph below. FMT_IMAG must be absent if X is\n        not complex. ADVANCE = adv  The value for ADVANCE may be ‘yes’, ‘no’ or ‘double’. If\n       the value is ‘yes’ then X is written out immediately, if it is\n       ‘double’ then X is written out followed by an empty line (thus\n       giving double spacing), and if it is ‘no’ then X is not written\n       out until the next DISP call on the same unit with advancing turned\n       on (either by default, via a call to DISP_SET, or via the ADVANCE\n       keyword). When this occurs, all the items displayed with DISP since\n       the last output occurred on the unit are written out side by side,\n       separated by three spaces unless a different separation has been\n       specified via the MATSEP argument of DISP_SET. Default value of\n       ADVANCE is ‘yes’. DIGMAX = n  Controls the format used for real and complex data in the\n       absence of FMT. For real items the format is chosen so that the\n       displayed number of largest absolute magnitude (say xmax) has n\n       significant decimal digits. If 0.1 <= |xmax| < 10**n an F edit\n       descriptor is used, otherwise an E edit descriptor. For complex\n       items these rules are applied separately to the real parts and\n       imaginary parts, and thus two different formats are used. When X\n       is not of real or complex type the argument DIGMAX is ignored. When\n       DIGMAX is present FMT should be absent. The default is n = 6. LBOUND = lbound  This argument is a default integer vector with the\n       numbers of the first row / column to show when displaying with\n       numbered style. When calling subroutines in Fortran, only the\n       shape of matrix arguments is passed with the arguments, but matrix\n       lower bounds are assumed to be 1 unless declared explicitly in\n       the routine. To compensate for this deficiency LBOUND may be\n       set to the declared lower bound(s) of X. To take an example, let\n       aij = exp(i + j - 1) as in section 1, but let A be declared with\n       REAL::A(0:3,0:3). Then CALL DISP(A, STYLE = ‘NUMBER’, LBOUND =\n       LBOUND(A)) will display: >        0       1        2        3\n     >  0   1.000   2.718    7.389   20.086\n     >  1   2.718   7.389   20.086   54.598\n     >  2   7.389  20.086   54.598  148.413\n     >  3  20.086  54.598  148.413  403.429.\n\n   In fact the call may be shortened to CALL DISP(A, LBOUND =\n   LBOUND(A)) because numbering is default when LBOUND is present. ORIENT = ori  This argument can only be used when X is a vector (i.e. has\n       rank 1). If ORIENT is ‘col’ (the default) a column vector is\n       displayed, and if ORIENT is ‘row’ a row vector results. SEP = sep  Specifies a string which is written out between columns of\n       displayed matrices. If X has rows (-1, 3) and (5, 10) and SEP is ‘,\n       ’ then the output will be: >  -1,  5\n     >   5, 10\n\n   The length of the string must be at most 9. Default is '  '\n   (character string with two spaces). STYLE = style  There are five possible styles: 'left'       Title is immediately to the left of the first line\n                of the displayed item.\n   'above'      Title is centered immediately above the item.\n   'pad'        Title is centered above the item, padded with hyphens (-).\n   'underline'  Title is centered above the item, underlined with hyphens.\n   'number'     Each matrix or vector row and / or column is numbered.\n\n   Any of the four title position styles can also be combined with the\n   number style by specifying for example STYLE = 'pad & number'. Any\n   character except space may be used instead of hyphen by prefixing\n   it to the style. STYLE = '*underline' will thus underline the title\n   with asterisks. Both row and column numbers appear for numbered\n   matrices, but for vectors only row numbers appear (or column numbers\n   when ORIENT is 'col'). The five styles are illustrated below,\n   accompanied by an example of combined padded title and numbering. > Matr = 1.2   4.2       Matr      ---Matr--       Matr          1     2     ____Matr____ > 5.6  18.3    1.2   4.2    1.2   4.2    ---------    1  1.2   4.2        1     2 > 5.6  18.3    5.6  18.3    1.2   4.2    2  5.6  18.3    1  1.2   4.2 > 5.6  18.3                    2  5.6  18.3 The default value of STYLE is 'left' if LBOUND is absent, 'number'\n   if it is present, and 'left & number' if both TITLE and LBOUND\n   are present. TRIM = trim  This argument can take three values, ‘YES’, ‘NO’ and\n       ‘AUTO’. When YES is specified, each column of displayed items is\n       trimmed from the left, with ‘NO’ the items are not trimmed and if\n       TRIM is ‘AUTO’ the items are trimmed when FMT is absent but not when\n       it is present. In the following example, X and U are displayed\n       with TRIM = ‘yes’, but Y and V with TRIM = ‘no’. In all cases the\n       edit descriptor is the default (I4). The default is TRIM = ‘AUTO’. > ---- X ---- ------- Y ------ ----- U ----- ------- V ------ > 1 2 4 1 2 3 333 22 4444 333 22 4444 > 2 22 34 2 22 34 > 3 32 1234 3 32 1234 One application of trimming is to display matrices with a fixed number of fractional digits but variable effective field width . Then Fw . d editing with w big enough is accompanied by TRIM = 'yes' . An example is the following display of a matrix with ( i , k ) element exp ( k ** i ) using F20 . 2 and 'yes' : > power exponentials > 2.72 7.39 20.09 > 2.72 54.60 8103.08 Similar output may be obtained using I and F edit descriptors with w = 0 as discussed in section 3.5 . Apart from I and F edited displays , it is possible to trim A - edited displays as well as E - edited displays with some negative elements , but the first column all positive : With TRIM = 'yes' : X = 1.2e+5 - 4.1e-2 With TRIM = 'no' : X = 1.2e+5 - 4.1e-2 2.3e-3 8.6e+1 2.3e-3 8.6e+1 UNIT = external-file-unit  The unit which the output is sent to. There\n       are three special units, which may be referred to either with\n       constants or parameters (named constants) as follows: Constant Parameter Preconnected unit - 3 ASTERISK_UNIT The asterisk unit ( often the screen ) - 2 PUTSTR_UNIT The subroutines PUTSTR and PUTNL - 1 NULL_UNIT Null device ( all output to this is discarded ) These units are further described in sections 3.3 and 3.4 . Other unit numbers correspond to external files that should have been connected with open - statements . The default unit depends on the named constant DEFAULT_UNIT , defined in PUTSTRMODULE . The default PUTSTRMODULE sets it to - 3 ( see sections 2 and 3.4 ) . ZEROAS = zerostring  Supported for integer and real X (not complex)\n       Any element that compares equal to 0 will be displayed as\n       zerostring. If, for example, A is a 4 by 4 upper triangular\n       matrix with aij = 1/max(0,j - i + 1) then CALL DISP(‘A = ‘, A,\n       ‘F0.3’, ZEROAS = ‘0’, ADVANCE = ‘NO’) and CALL DISP(‘B = ‘, A,\n       ‘F0.3’, ZEROAS = ‘.’) will display: A = 1.000  0.500  0.333  0.250   B = 1.000  0.500  0.333  0.250\n               0  1.000  0.500  0.333        .     1.000  0.500  0.333\n               0      0  1.000  0.500        .      .     1.000  0.500\n               0      0      0  1.000        .      .      .     1.000\n\n   Notice that when zerostring contains a decimal point it is lined\n   up with other decimal points in the column. If zerostring has\n   length 0, the default behavior of not treating zeros specially is\n   re-established, in case an earlier DISP_SET call has been used to\n   set ZEROAS. ASTERISK_UNIT AND NULL_UNIT As already mentioned in section 3.2 there are three special units,\n ASTERISK_UNIT = -3, PUTSTR_UNIT = -2 and NULL_UNIT = -1. These public\n named constants (parameters) are defined by M_display. Selecting ASTERISK_UNIT channels all output to the unit that\n WRITE(*,…) statements use. The ISO_FORTRAN_ENV intrinsic module of\n Fortran 2003 defines the named constant OUTPUT_UNIT and this may be\n used instead, unless its value is set to -2 by the compiler (which would\n clash with PUTSTR_UNIT). Selecting NULL_UNIT causes all output via DISP to be discarded. This\n feature makes it simple to turn the output on and off, which may be\n useful for debugging and testing purposes. If UNIT = U is specified\n in all DISP-calls, it is enough to change the value of U to -1 to turn\n off output. PUTSTR_UNIT: Output with user written subroutines One of the purposes of the PUTSTR_UNIT is to make displaying possible in\n situations where ordinary print- and write-statements do not work. This\n is for example the case in Matlab mex-files (in fact the execution\n of a write statement on the asterisk unit crashes Matlab). To use the\n PUTSTR_UNIT it is necessary to write two subroutines with interfaces: SUBROUTINE PUTSTR(S)\n   CHARACTER(*), INTENT(IN) :: S\n\n   SUBROUTINE PUTNL() The first of these should output the string S, and the second one should\n advance output to the next line. These subroutines should be placed\n in a module PUTSTRMODULE as explained in section 2. The module should\n also define a named constant DEFAULT_UNIT, which could be set to -2 to\n make the PUTSTR_UNIT default. An example that works with g95 and Matlab\n mex-files is: module M_display__putstrmodule integer , parameter :: default_unit = - 2 contains subroutine putstr ( s ) character (*), intent ( in ) :: s call mexprintf ( s // char ( 0 )) end subroutine putstr subroutine putnl () call mexprintf ( char ( 10 )// char ( 0 )) end subroutine putnl end module M_display__putstrmodule At the beginning of the file M_display.f90 there is a slightly longer\n version which works with both g95 and gfortran. Testing this module is\n discussed in section 6.2 below. USING W=0 EDITING The Fortran standard stipulates that writing a single element with\n I0 editing results in the smallest field width that accommodates the\n value, and the same applies to B0, O0, Z0 and F0.d editing. With DISP,\n the width of a displayed column will be the width of the widest field\n in the column, and each element is right-adjusted in the column. This\n gives exactly the same output as using TRIM=’yes’ and a specified field\n width bigger than the largest occurring. Note that with F0.d editing,\n there is no limit on the width of a column, but with Fw.d and TRIM=’yes’\n any element wider than w will be displayed as w asterisks: ------------------F0.2------------------    -----F13.2, TRIM='yes'----\n   14.28  142857142857142857142857.14  0.47    14.28  *************  0.47\n    1.42                1414213562.37  0.69     1.42  1414213562.37  0.69 NOT-A-NUMBER AND INFINITE VALUES If the compiler supports not-a-number and infinite values as defined by\n the IEEE exceptional values of Fortran 2003, these are displayed as NaN,\n +Inf or Inf. A not-a-number value X is identified as being not equal to\n itself, and an infinite value is either greater than HUGE(X) or smaller\n than -HUGE(X). On all the compilers tried the sequence BIG=1E20; CALL\n DISP(EXP(BIG)) displays +Inf, and the program segment: > real :: z = 0, big = 1e20\n > call disp([z, z/z, big, -exp(big)]) displays\n     >  0.00000E+00\n     >          NaN\n     >  1.00000E+20\n     >         -Inf AUTHOR Based on dispmodule(3f),\n   “A Fortran 95 module for pretty-printing matrices”.\n   Version number 1.02 6-Sept-2008,\n   Kristjan Jonasson,\n   Dept. of Computer Science,\n   University of Iceland (jonasson@hi.is). private  subroutine disp_scalar_int(x, fmt, advance, sep, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name integer(kind=dint), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_title_scalar_int(title, x, fmt, advance, sep, style, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title integer(kind=dint), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_vector_int(x, fmt, advance, lbound, sep, style, trim, unit, orient, zeroas) Arguments Type Intent Optional Attributes Name integer(kind=dint), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient character(len=*), intent(in), optional :: zeroas private  subroutine disp_title_vector_int(title, x, fmt, advance, lbound, sep, style, trim, unit, orient, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title integer(kind=dint), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient character(len=*), intent(in), optional :: zeroas private  subroutine disp_matrix_int(x, fmt, advance, lbound, sep, style, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name integer(kind=dint), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_title_matrix_int(title, x, fmt, advance, lbound, sep, style, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title integer(kind=dint), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_s_sngl(x, fmt, advance, digmax, sep, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name real(kind=sngl), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_ts_sngl(title, x, fmt, advance, digmax, sep, style, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title real(kind=sngl), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_v_sngl(x, fmt, advance, digmax, lbound, sep, style, trim, unit, orient, zeroas) Arguments Type Intent Optional Attributes Name real(kind=sngl), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient character(len=*), intent(in), optional :: zeroas private  subroutine disp_tv_sngl(title, x, fmt, advance, digmax, lbound, sep, style, trim, unit, orient, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title real(kind=sngl), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient character(len=*), intent(in), optional :: zeroas private  subroutine disp_m_sngl(x, fmt, advance, lbound, sep, style, trim, unit, digmax, zeroas) Arguments Type Intent Optional Attributes Name real(kind=sngl), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: zeroas private  subroutine disp_tm_sngl(title, x, fmt, advance, digmax, lbound, sep, style, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title real(kind=sngl), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_s_dble(x, fmt, advance, digmax, sep, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name real(kind=dble), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_ts_dble(title, x, fmt, advance, digmax, sep, style, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title real(kind=dble), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_v_dble(x, fmt, advance, digmax, lbound, sep, style, trim, unit, orient, zeroas) Arguments Type Intent Optional Attributes Name real(kind=dble), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient character(len=*), intent(in), optional :: zeroas private  subroutine disp_tv_dble(title, x, fmt, advance, digmax, lbound, sep, style, trim, unit, orient, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title real(kind=dble), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient character(len=*), intent(in), optional :: zeroas private  subroutine disp_m_dble(x, fmt, advance, lbound, sep, style, trim, unit, digmax, zeroas) Arguments Type Intent Optional Attributes Name real(kind=dble), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: zeroas private  subroutine disp_tm_dble(title, x, fmt, advance, digmax, lbound, sep, style, trim, unit, zeroas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title real(kind=dble), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas private  subroutine disp_s_cplx(x, fmt, fmt_imag, advance, digmax, sep, trim, unit) Arguments Type Intent Optional Attributes Name complex(kind=sngl), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_ts_cplx(title, x, fmt, fmt_imag, advance, digmax, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title complex(kind=sngl), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_v_cplx(x, fmt, fmt_imag, advance, digmax, lbound, sep, style, trim, unit, orient) Arguments Type Intent Optional Attributes Name complex(kind=sngl), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient private  subroutine disp_tv_cplx(title, x, fmt, fmt_imag, advance, digmax, lbound, sep, style, trim, unit, orient) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title complex(kind=sngl), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient private  subroutine disp_m_cplx(x, fmt, fmt_imag, advance, digmax, lbound, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name complex(kind=sngl), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_tm_cplx(title, x, fmt, fmt_imag, advance, digmax, lbound, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title complex(kind=sngl), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_s_cpld(x, fmt, fmt_imag, advance, digmax, sep, trim, unit) Arguments Type Intent Optional Attributes Name complex(kind=dble), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_ts_cpld(title, x, fmt, fmt_imag, advance, digmax, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title complex(kind=dble), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_v_cpld(x, fmt, fmt_imag, advance, digmax, lbound, sep, style, trim, unit, orient) Arguments Type Intent Optional Attributes Name complex(kind=dble), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient private  subroutine disp_tv_cpld(title, x, fmt, fmt_imag, advance, digmax, lbound, sep, style, trim, unit, orient) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title complex(kind=dble), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient private  subroutine disp_m_cpld(x, fmt, fmt_imag, advance, digmax, lbound, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name complex(kind=dble), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_tm_cpld(title, x, fmt, fmt_imag, advance, digmax, lbound, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title complex(kind=dble), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: fmt_imag character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_s_dlog(x, fmt, advance, sep, trim, unit) Arguments Type Intent Optional Attributes Name logical(kind=dlog), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_ts_dlog(title, x, fmt, advance, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title logical(kind=dlog), intent(in) :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_v_dlog(x, fmt, advance, lbound, sep, style, trim, unit, orient) Arguments Type Intent Optional Attributes Name logical(kind=dlog), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient private  subroutine disp_tv_dlog(title, x, fmt, advance, lbound, sep, style, trim, unit, orient) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title logical(kind=dlog), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient private  subroutine disp_m_dlog(x, fmt, advance, lbound, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name logical(kind=dlog), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_tm_dlog(title, x, fmt, advance, lbound, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title logical(kind=dlog), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_ts_dchr(title, x, fmt, advance, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title character(len=*), intent(in), optional :: x character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_v_dchr(x, fmt, advance, lbound, sep, style, trim, unit, orient) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient private  subroutine disp_tv_dchr(title, x, fmt, advance, lbound, sep, style, trim, unit, orient) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title character(len=*), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit character(len=*), intent(in), optional :: orient private  subroutine disp_m_dchr(x, fmt, advance, lbound, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit private  subroutine disp_tm_dchr(title, x, fmt, advance, lbound, sep, style, trim, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title character(len=*), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: advance integer, intent(in), optional :: lbound (:) character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style character(len=*), intent(in), optional :: trim integer, intent(in), optional :: unit public        interface tostring private  function tostring_dint(x) result(st) Arguments Type Intent Optional Attributes Name integer(kind=dint), intent(in) :: x (:) Return Value character(kind=tosset%ifmt), len=len_f_dint(x) private  function tostring_f_dint(x, fmt) result(st) Arguments Type Intent Optional Attributes Name integer(kind=dint), intent(in) :: x (:) character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_dint(x) private  function tostring_s_dint(x) result(st) Arguments Type Intent Optional Attributes Name integer(kind=dint), intent(in) :: x Return Value character(kind=tosset%ifmt), len=len_f_dint([x]) private  function tostring_sf_dint(x, fmt) result(st) Arguments Type Intent Optional Attributes Name integer(kind=dint), intent(in) :: x character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_dint([x]) private  function tostring_dlog(x) result(st) Arguments Type Intent Optional Attributes Name logical(kind=dlog), intent(in) :: x (:) Return Value character(len=1) private  function tostring_f_dlog(x, fmt) result(st) Arguments Type Intent Optional Attributes Name logical(kind=dlog), intent(in) :: x (:) character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_dlog(x) private  function tostring_s_dlog(x) result(st) Arguments Type Intent Optional Attributes Name logical(kind=dlog), intent(in) :: x Return Value character(len=1) private  function tostring_sf_dlog(x, fmt) result(st) Arguments Type Intent Optional Attributes Name logical(kind=dlog), intent(in) :: x character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_dlog([x]) private  function tostring_sngl(x) result(st) Arguments Type Intent Optional Attributes Name real(kind=sngl), intent(in) :: x (:) Return Value character(kind=tosset%rfmt), len=len_f_sngl(x) private  function tostring_f_sngl(x, fmt) result(st) Arguments Type Intent Optional Attributes Name real(kind=sngl), intent(in) :: x (:) character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_sngl(x) private  function tostring_s_sngl(x) result(st) Arguments Type Intent Optional Attributes Name real(kind=sngl), intent(in) :: x Return Value character(kind=tosset%rfmt), len=len_f_sngl([x]) private  function tostring_sf_sngl(x, fmt) result(st) Arguments Type Intent Optional Attributes Name real(kind=sngl), intent(in) :: x character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_sngl([x]) private  function tostring_dble(x) result(st) Arguments Type Intent Optional Attributes Name real(kind=dble), intent(in) :: x (:) Return Value character(kind=tosset%rfmt), len=len_f_dble(x) private  function tostring_f_dble(x, fmt) result(st) Arguments Type Intent Optional Attributes Name real(kind=dble), intent(in) :: x (:) character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_dble(x) private  function tostring_s_dble(x) result(st) Arguments Type Intent Optional Attributes Name real(kind=dble), intent(in) :: x Return Value character(kind=tosset%rfmt), len=len_f_dble([x]) private  function tostring_sf_dble(x, fmt) result(st) Arguments Type Intent Optional Attributes Name real(kind=dble), intent(in) :: x character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_dble([x]) private  function tostring_cplx(x) result(st) Arguments Type Intent Optional Attributes Name complex(kind=sngl), intent(in) :: x (:) Return Value character(kind=tosset%rfmt), len=len_f_cplx(x) private  function tostring_f_cplx(x, fmt) result(st) Arguments Type Intent Optional Attributes Name complex(kind=sngl), intent(in) :: x (:) character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_cplx(x) private  function tostring_s_cplx(x) result(st) Arguments Type Intent Optional Attributes Name complex(kind=sngl), intent(in) :: x Return Value character(kind=tosset%rfmt), len=len_s_cplx(x) private  function tostring_sf_cplx(x, fmt) result(st) Arguments Type Intent Optional Attributes Name complex(kind=sngl), intent(in) :: x character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_s_cplx(x) private  function tostring_cpld(x) result(st) Arguments Type Intent Optional Attributes Name complex(kind=dble), intent(in) :: x (:) Return Value character(kind=tosset%rfmt), len=len_f_cpld(x) private  function tostring_f_cpld(x, fmt) result(st) Arguments Type Intent Optional Attributes Name complex(kind=dble), intent(in) :: x (:) character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_f_cpld(x) private  function tostring_s_cpld(x) result(st) Arguments Type Intent Optional Attributes Name complex(kind=dble), intent(in) :: x Return Value character(kind=tosset%rfmt), len=len_s_cpld(x) private  function tostring_sf_cpld(x, fmt) result(st) Arguments Type Intent Optional Attributes Name complex(kind=dble), intent(in) :: x character(len=*), intent(in) :: fmt Return Value character(kind=fmt), len=len_s_cpld(x) Functions public  function disp_get () result(defs) disp_get(3f) - [M_display] return default settings in a structure of\n                DISP(3f) settings Read more… Arguments None Return Value type( disp_settings ) Subroutines public  subroutine disp_set (advance, digmax, matsep, orient, sep, style, unit, zeroas) The subroutine DISP_SET may be used to change default values of all\n the arguments of DISP except TITLE, X, FMT and LBOUND. In addition the\n default separator between items that are displayed side-by-side (using\n ADVANCE=’no’) may be changed with the MATSEP argument. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: advance integer, intent(in), optional :: digmax character(len=*), intent(in), optional :: matsep character(len=*), intent(in), optional :: orient character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: style integer, intent(in), optional :: unit character(len=*), intent(in), optional :: zeroas public  subroutine disp_set_factory () Based on dispmodule(3f),\n   “A Fortran 95 module for pretty-printing matrices”.\n   Version number 1.02 6-Sept-2008,\n   Kristjan Jonasson,\n   Dept. of Computer Science, University of Iceland (jonasson@hi.is). Read more… Arguments None public  subroutine tostring_set (sep, rfmt, ifmt, trimb, trimz) The subroutine TOSTRING_SET has five arguments, all of which are\n optional. Argument association will normally be realized using argument\n keywords, e.g. CALL TOSTRING_SET(SEP=’; ‘). The examples in section 5.4\n clarify how to use this subroutine. The five arguments are: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: sep character(len=*), intent(in), optional :: rfmt character(len=*), intent(in), optional :: ifmt character(len=*), intent(in), optional :: trimb character(len=*), intent(in), optional :: trimz public  subroutine tostring_set_factory () The subroutine TOSTRING_SET_FACTORY (which has no arguments) may be\n called to restore all settings of TOSTRING(3f) to the original default\n values (the factory defaults): SEP=’,’, RFMT = ‘1PG12.5’, IFMT= ‘I0’,\n TRIMB=’YES’ and TRIMZ=’G’. Read more… Arguments None","tags":"","url":"module/m_display.html"},{"title":"TEST_NANINF_MOD – M_display","text":"Variables Type Visibility Attributes Name Initial character(len=3), public :: adv = 'no' character(len=30), public :: assert_string = '' integer, public :: compare_no = 0 character(len=90), public :: fmt = '(\"  Testing display of nan and -inf and inf, real kind=\",I0,\"...\")' integer, public, parameter :: srk = kind(0d0) integer, public, parameter :: verbose = 0 Subroutines public  subroutine assert (s, msg) Arguments Type Intent Optional Attributes Name logical :: s character(len=*), optional :: msg public  subroutine assert_init (st) Arguments Type Intent Optional Attributes Name character(len=*), optional :: st public  subroutine close_8 () Arguments None public  subroutine compare (sok, message, sok1) Arguments Type Intent Optional Attributes Name character(len=*) :: sok (:) character(len=*), optional :: message character(len=*), optional :: sok1 (:) public  subroutine msg1 (st) Arguments Type Intent Optional Attributes Name character(len=*) :: st public  subroutine msg2 (st) Arguments Type Intent Optional Attributes Name character(len=*) :: st public  subroutine open_8 () Arguments None public  subroutine reopen_8 () Arguments None public  subroutine test_ni (nan, inf, minf) Arguments Type Intent Optional Attributes Name real(kind=srk), intent(in) :: nan real(kind=srk), intent(in) :: inf real(kind=srk), intent(in) :: minf","tags":"","url":"module/test_naninf_mod.html"},{"title":"TEST_NANINF – M_display","text":"Uses TEST_NANINF_MOD Variables Type Attributes Name Initial real(kind=srk) :: big = 1.e20 real(kind=srk) :: inf real(kind=srk) :: minf real(kind=srk) :: nan real(kind=srk) :: zero = 0._srk Source Code PROGRAM TEST_NANINF ! PROGRAM TO TEST DISPLAY OF NOT-A-NUMBER-S AND INFINITIES BY M_display ! (Appropriate for compilers that support IEEE-arithmetic as described in the Fortran 2003 standard) USE TEST_NANINF_MOD ! USE DISP_R16MOD ! uncomment this line if testing of disp_r16mod (quad precision) is required ! ! Copyright (c) 2008, Kristj n J nasson, Dept. of Computer Science, University of ! Iceland (jonasson@hi.is). This software is free. For details see the file README. implicit none real ( srk ) :: zero = 0._srk , big = 1.e20 , nan , inf , minf nan = zero / zero inf = exp ( big ) minf = - inf call test_ni ( nan , inf , minf ) END PROGRAM TEST_NANINF","tags":"","url":"program/test_naninf.html"},{"title":"demo_M_display – M_display","text":"Uses M_display Variables Type Attributes Name Initial real(kind=rk) :: a (n,n) real(kind=rk) :: b (n,n) integer :: i integer :: j integer :: k (5) integer, parameter :: n = 3 integer, parameter :: rk = selected_real_kind(6) real(kind=rk) :: x Source Code program demo_M_display use M_display implicit none integer , parameter :: rk = selected_real_kind ( 6 ), n = 3 real ( rk ) :: a ( n , n ), b ( n , n ), x integer i , j , k ( 5 ) call disp_set ( advance = 'double' ) forall ( i = 1 : n , j = 1 : n ) a ( i , j ) = exp ( real ( i + j - 1 , rk )) b ( i , j ) = exp ( real ( i ** j , rk )) end forall call disp ( 'A = ' , a ) call disp ( b ) call disp ( a ( 1 : 2 ,:), 'f0.5' ) call disp ( 'MATRIX' , a , style = 'UNDERLINE & NUMBER' , unit =- 3 , digmax = 4 ) k = [ - 3 , 0 , 12 , 14 , 0 ] call disp ( 'K' , k , style = 'pad' , orient = 'row' , sep = ' ' , zeroas = '.' ) x = 1.5 call disp ( 'The square of ' // tostring ( x ) // ' is ' // tostring ( x * x )) call disp_set ( matsep = ' | ' ) call disp ([ 11 , 12 , 13 ], advance = 'no' ) call disp ([. true ., . false ., . true .], advance = 'no' ) call disp ([ 'A' , 'B' , 'C' ]) end program demo_M_display","tags":"","url":"program/demo_m_display.html"},{"title":"demo_disp_get – M_display","text":"Variables Type Attributes Name Initial real :: xx (2,3) real :: yy (2,3) Subroutines subroutine disp_xy (x, y) Arguments Type Intent Optional Attributes Name real :: x (:,:) real :: y (:,:) Source Code program demo_disp_get real :: xx ( 2 , 3 ), yy ( 2 , 3 ) xx ( 1 ,:) = [ 1.0 , 6.0 , 5.0 ] xx ( 2 ,:) = [ 2.4 , 4.0 , 6.0 ] yy ( 1 ,:) = [ 0.0 , 3.5 , 2.0 ] yy ( 2 ,:) = [ 7.0 , 4.0 , 8.22 ] call disp_xy ( xx , yy ) contains subroutine disp_xy ( x , y ) use M_display real x (:,:), y (:,:) type ( disp_settings ) ds ds = disp_get () call disp_set ( digmax = 4 , sep = ',' ) call disp ( 'x=' , x ) write ( * , * ) call disp ( 'y=' , y ) call disp_set ( ds ) end subroutine disp_xy end program demo_disp_get","tags":"","url":"program/demo_disp_get.html"},{"title":"TEST_M_display – M_display","text":"Uses M_display M_framework__verify Variables Type Attributes Name Initial character(len=3) :: adv = 'no' character(len=30) :: assert_string = '' integer :: compare_no = 0 character(len=90) :: fmt = '(\"  Testing M_display, int kind=\",I0,\", real kind=\",I0,\", logical kind=\",I0,\"...\")' integer, parameter :: irange = 9 integer, parameter :: logikind = kind(.false.) integer, parameter :: sik = selected_int_kind(irange) integer, parameter :: srk = kind(0.0) integer, parameter :: verbose = 2 Subroutines subroutine assert (s, msg) Arguments Type Intent Optional Attributes Name logical, intent(in) :: s character(len=*), intent(in), optional :: msg subroutine assert_init (st) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: st subroutine close_8 () Arguments None subroutine compare (sok, message, sok1) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: sok (:) character(len=*), intent(in), optional :: message character(len=*), intent(in), optional :: sok1 (:) subroutine disp_xy (x, y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x (:,:) real, intent(in) :: y (:,:) subroutine msg1 (st) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: st subroutine msg2 (st) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: st subroutine open_8 () Arguments None subroutine reopen_8 () Arguments None subroutine scompare (s, shouldbe, sb1, sb2, sb3) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s character(len=*), intent(in) :: shouldbe character(len=*), intent(in), optional :: sb1 character(len=*), intent(in), optional :: sb2 character(len=*), intent(in), optional :: sb3 subroutine test_advance_double () Arguments None subroutine test_advance_no () Arguments None subroutine test_char () Arguments None subroutine test_complex () Arguments None subroutine test_disp_set1 () Arguments None subroutine test_disp_set2 () Arguments None subroutine test_empty () Arguments None subroutine test_empty_char () Arguments None subroutine test_empty_int () Arguments None subroutine test_empty_logical () Arguments None subroutine test_empty_real () Arguments None subroutine test_error_messages () Arguments None subroutine test_integer () Arguments None subroutine test_logical () Arguments None subroutine test_numbering () Arguments None subroutine test_real () Arguments None subroutine test_scalar_string () Arguments None subroutine test_tostring () Arguments None subroutine test_tostring_factory () Arguments None subroutine test_zeroas () Arguments None subroutine tests_from_manual () Arguments None subroutine tests_from_manual_1 () Arguments None subroutine tests_from_manual_2 () Arguments None subroutine tests_from_manual_3 () Arguments None subroutine tests_from_manual_4 () Arguments None subroutine tests_from_manual_5 () Arguments None subroutine tscompare (s, vec, msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s real, intent(in) :: vec (:) character(len=*), intent(in) :: msg subroutine w4blnk () Arguments None Source Code PROGRAM TEST_M_display use M_framework__verify , only : unit_check , unit_check_start , unit_check_good , unit_check_bad ! MAIN TEST PROGRAM FOR M_display. SEE ALSO test_M_display_fpp.F90 USE M_display ! USE DISP_I1MOD  ! uncomment this line if testing of disp_i1mod (1 byte integers) is required ! USE DISP_I2MOD  ! uncomment this line if testing of disp_i2mod (2 byte integers) is required ! USE DISP_I4MOD  ! uncomment this line if testing of disp_i4mod (4 byte integers) is required ! USE DISP_I8MOD  ! uncomment this line if testing of disp_i8mod (8 byte integers) is required ! USE DISP_L1MOD  ! uncomment this line if testing of disp_l1mod (1 byte logicals) is required ! USE DISP_R16MOD ! uncomment this line if testing of disp_r16mod (quad precision) is required ! ! Note that default integers are often 4 (sometimes 8) bytes, Note also that many computers/compilers do not ! support quad precision, and some support 10 byte reals (at least g95 on x86 platforms, it uses kind=10) ! ! Copyright (c) 2008, Kristjan Jonasson, Dept. of Computer Science, University of ! Iceland (jonasson@hi.is). This software is free. For details see the file README. implicit none integer , parameter :: verbose = 2 ! 0 = quiet !                                  ! 1 = report only names of test routines !                                  ! 2 = report also what the tests display integer , parameter :: irange = 9 ! Run for irange = 2, 4, 9 and 18 for test of 1, 2, 4 and 8 byte integers !                                  ! (most likely) integer , parameter :: logikind = kind (. false .) ! Run for logikind = 1 (probably) for test of 1 byte logicals integer , parameter :: sik = selected_int_kind ( irange ) ! Usually either 0, 1, 2, 3 or 1, 2, 4, 8 integer , parameter :: srk = kind ( 0.0 ) ! Run (at least) for srk = kind(0.0) and kind(0d0) integer :: compare_no = 0 character ( 30 ) :: assert_string = '' character ( 3 ) :: adv = 'no' character ( 90 ) :: fmt = '(\"  Testing M_display, int kind=\",I0,\", real kind=\",I0,\", logical kind=\",I0,\"...\")' write ( * , '(a)' ) 'STARTED M_display' ! Use goodbad(1) to indicate the test sequence was begun call unit_check_start ( 'M_display' , ' & & -section 3  & & -library libGPF  & & -filename `pwd`/M_display.FF & & -documentation y & &  -prep         y & &  -ccall        n & &  -archive      GPF.a & & ' ) if ( verbose > 0 ) adv = 'yes' write ( * , fmt , advance = adv ) sik , srk , logikind call open_8 call tests_from_manual call test_disp_set1 call test_disp_set2 call test_integer call test_real call test_complex call test_logical call test_char call test_scalar_string call test_numbering call test_zeroas call test_advance_double call test_advance_no call test_empty call test_tostring call test_error_messages call close_8 write ( * , '(\"  OK\")' ) call unit_check_good ( 'M_display' ) write ( * , '(a)' ) 'COMPLETED M_display' CONTAINS !=================================================================================================================================== subroutine msg1 ( st ) ! Print st if verbose is >= 1 character ( * ), intent ( in ) :: st if ( verbose >= 1 ) write ( * , '(2x,a)' ) trim ( st ) end subroutine msg1 !=================================================================================================================================== subroutine msg2 ( st ) ! Print st if verbose is >= 2 character ( * ), intent ( in ) :: st if ( verbose >= 2 ) write ( * , '(4x,a)' ) trim ( st ) end subroutine msg2 !=================================================================================================================================== subroutine w4blnk ! Write 4 blanks write ( * , '(\"    \")' , advance = 'no' ) end subroutine w4blnk !=================================================================================================================================== subroutine test_disp_set1 ! Check default values of disp_settings type ( disp_settings ) ds ds = disp_get () call assert ( ds % advance == 'YES' , '1A' ) call assert ( ds % trim == 'AUTO' , '1B' ) call assert ( ds % sep == '  ' , '1C' ) call assert ( ds % matsep == '   ' , '1D' ) call assert ( ds % orient == 'COL' , '1E' ) call assert ( ds % style == 'LEFT' , '1F' ) call assert ( ds % seplen == 2 , '1H' ) call assert ( ds % matseplen == 3 , '1I' ) call assert ( ds % digmax == 6 , '1J' ) call assert ( ds % zeroas == '' , '1K' ) call assert ( ds % zaslen == 0 , '1L' ) call assert ( ds % unit == - 3 , '1M' ) call assert ( ds % unit == ASTERISK_UNIT , '1M' ) end subroutine test_disp_set1 !=================================================================================================================================== subroutine test_disp_set2 ! Set, retrieve settings with disp_get and check contents of retrieved settings type ( disp_settings ) ds call disp_set ( advance = 'yes' ) call disp_set ( matsep = 'ss' ) call disp_set ( sep = 'cc' ) call disp_set ( orient = 'row' ) call disp_set ( style = 'xpad' ) call disp_set ( unit = 7 ) call disp_set ( digmax = 13 ) call disp_set ( zeroas = '**' ) ds = disp_get () call assert ( ds % advance == 'YES' , '2A' ) call assert ( ds % matsep == 'ss' , '2B' ) call assert ( ds % sep == 'cc' , '2C' ) call assert ( ds % orient == 'ROW' , '2D' ) call assert ( ds % style == 'xpad' , '2E' ) call assert ( ds % unit == 7 , '2G' ) call assert ( ds % digmax == 13 , '2H' ) call assert ( ds % zeroas == '**' , '2I' ) call assert ( ds % zaslen == 2 , '2J' ) call disp_set ( orient = 'col' ) call disp_set ( style = 'UNDERLINE' ) ds = disp_get () call assert ( ds % orient == 'COL' , '2K' ) call assert ( ds % style == 'UNDERLINE' , '2L' ) call disp_set_factory end subroutine test_disp_set2 !=================================================================================================================================== subroutine test_error_messages if ( verbose < 1 ) return call msg2 ( '' ) call msg1 ( 'TEST_ERROR_MESSAGES' ) call msg1 ( '  (Following should print 17 error messages,' ) call msg1 ( '  5 for disp_set, 8 for disp and 4 for tostring_set)' ) call disp_set ( unit = NULL_UNIT ) call w4blnk ; call disp_set ( advance = 'abc' ) call w4blnk ; call disp_set ( style = 'xyz' ) call w4blnk ; call disp_set ( digmax = 0 ) call w4blnk ; call disp_set ( digmax = 90 ) call w4blnk ; call disp_set ( orient = 'xyz' ) call disp_set ( digmax = 1 ) ! should not give error call disp_set ( digmax = 89 ) ! should not give error call disp ( 0.17 , digmax = 89 ) ! should not give error call w4blnk ; call disp ( 0.17 , digmax = 0 ) call w4blnk ; call disp ( 0.17 , digmax = 90 ) call w4blnk ; call disp ( 0.17 , digmax = 2 , fmt = 'f0.1' ) call w4blnk ; call disp ( 0.17 , advance = 'xyz' ) call w4blnk ; call disp ( 0.17 , trim = 'xyz' ) call w4blnk ; call disp ( 'x=' , 0.17 , style = 'xyz' ) call w4blnk ; call disp (( / 0.17 / ), orient = 'xyz' ) call w4blnk ; call disp (( 1 , 1 ), fmt_imag = 'F10.2' ) call w4blnk ; call tostring_set ( trimb = 'xyz' ) call w4blnk ; call tostring_set ( trimz = 'xyz' ) call w4blnk ; call tostring_set ( rfmt = 'xyz' ) call w4blnk ; call tostring_set ( ifmt = 'xyz' ) call disp_set_factory end subroutine test_error_messages !=================================================================================================================================== subroutine test_integer ! Check that disp works with integers integer ( sik ) :: i1 ( 1 , 2 ) = reshape (( /- 9_sik * 10_sik ** ( irange - 1 ) + 1 , 9_sik * 10_sik ** ( irange - 1 ) - 1 / ), ( / 1 , 2 / )) integer ( sik ) :: i2 ( 2 , 2 ) = reshape (( / 100 , - 99 , - 99 , 0 / ), ( / 2 , 2 / )) integer ( sik ) :: i3 ( 2 , 2 ) = reshape (( / 12 , 1 , - 12 , 0 / ), ( / 2 , 2 / )) integer ( sik ) :: i4 ( 2 ) = ( / 1 , - 2 / ) integer ( sik ) :: i5 ( 1 ) = ( / 0 / ) integer ( sik ) :: i6 ( 1 , 2 ) = reshape (( / 13 , - 12 / ), ( / 1 , 2 / )) integer ( sik ) :: i7 ( 2 ), i8 character ( 2 * irange + 3 ) :: s1 ( 1 ) character ( 9 ) :: s2 ( 3 ), s3 ( 2 ), s3a ( 2 ), s4 ( 3 ), s4a ( 2 ) character ( 2 ) :: s5 ( 1 ) character ( 7 ) :: s6 ( 3 ) character ( 10 ) :: s7 ( 1 ) character ( 13 ) :: s7a ( 1 ) character ( 3 ) :: fmt , s8 ( 2 ) character ( 10 ) :: st integer k500 , k5000 ! call assert_init ( 'TEST_INTEGER' ) st = '' if ( sik == kind ( 0 )) st = ' (default)' call msg1 ( '  (' // tostring ( bit_size ( i1 )) // ' bit' // trim ( st ) // ' integers)' ) s1 ( 1 ) = '-8' // repeat ( '9' , irange - 1 ) // ', 8' // repeat ( '9' , irange - 1 ) ! s2 ( 1 ) = '----AB---' s2 ( 2 ) = '100,  -99' s2 ( 3 ) = '-99,    0' ! s3 ( 1 ) = 'a=12::-12' s3 ( 2 ) = '   1::  0' s3a ( 1 ) = 'a= 12,-12' s3a ( 2 ) = '    1,  0' ! s4 ( 1 ) = 'Longtitle' s4 ( 2 ) = '    1    ' s4 ( 3 ) = '   -2    ' ! s4a ( 1 ) = 'Longtitle' s4a ( 2 ) = '   1;-2  ' ! s5 ( 1 ) = 'X0' ! s6 ( 1 ) = '  XY  ' s6 ( 2 ) = '======' s6 ( 3 ) = ' 13-12' ! s7 ( 1 ) = 'ab=5  5000' s7a ( 1 ) = 'ab=   5  5000' ! s8 ( 1 ) = 'abc' s8 ( 2 ) = '500' ! ! Tests with default format call disp_set ( unit = 8 ) call disp ( i1 , sep = ', ' ); call compare ( s1 ) call disp ( 'AB' , i2 , style = 'pad' , sep = ',  ' ); call compare ( s2 ) call disp ( 'a=' , i3 , sep = '::' ); call compare ( s3 ) call disp ( 'Longtitle' , i4 , style = 'pad' , orient = 'col' ); call compare ( s4 ) call disp ( 'X' , i5 ); call compare ( s5 ) call disp ( 'XY' , i6 , style = '=underline' , sep = '' , trim = 'no' ); call compare ( s6 ) ! ! Tests with specified format write ( fmt , '(\"i\",i2)' ) irange + 1 call disp ( i1 , fmt , sep = ',' ); call compare ( s1 ) call disp ( 'AB' , i2 , 'i3' , style = 'pad' , sep = ',  ' ); call compare ( s2 ) call disp ( 'a=' , i3 , 'i3' , sep = ',' ); call compare ( s3a ) call disp ( 'Longtitle' , i4 , 'i2' , style = 'above' ); call compare ( s4 ) call disp ( 'Longtitle' , i4 , 'i2' , style = 'above' , orient = 'col' ); call compare ( s4 ) call disp ( 'Longtitle' , i4 , 'i2' , style = 'pad' , orient = 'row' , sep = ';' ); call compare ( s4a ) call disp ( 'X' , i5 , 'i1' ); call compare ( s5 ) call disp ( 'XY' , i6 , 'i3' , style = '=underline' , sep = '' ); call compare ( s6 ) ! ! Test 4 byte numbers if ( irange >= 4 ) then k500 = 500 k5000 = 5000 i7 = ( / 5 , k5000 / ) i8 = k500 call disp_set ( orient = 'row' ) ! Without format: call disp ( 'ab=' , i7 ); call compare ( s7 ) call disp ( 'abc' , i8 , style = 'pad' ); call compare ( s8 ) ! With format: call disp ( 'ab=' , i7 , 'i4' ); call compare ( s7a ) call disp ( 'abc' , i8 , 'i0' , style = 'above' ); call compare ( s8 ) endif call disp_set_factory end subroutine test_integer !=================================================================================================================================== subroutine test_real ! Check that disp works with reals real ( srk ) :: r1 ( 2 , 2 ) = reshape (( / 2.146_srk , - 1.231_srk , 0.008_srk , 2 0.33_srk / ), ( / 2 , 2 / )) real ( srk ) :: r2 ( 1 , 2 ) = reshape (( / 1 2.0_srk , - 123 4.5678_srk / ), ( / 1 , 2 / )) real ( srk ) :: r3 ( 2 , 1 ) real ( srk ) :: r4 ( 1 , 1 ) = reshape (( / 0.0_srk / ), ( / 1 , 1 / )) real ( srk ) :: r5 = 0.0_srk integer :: rrng ! character ( 3 ) rrangec character ( 6 ) r3_2chr ! character ( 12 ) :: s1 ( 2 ), f1 ( 2 ) character ( 13 ) :: f3 ( 2 ) character ( 15 ) :: f2 ( 2 ) character ( 16 ) :: s3 ( 2 ) character ( 17 ) :: s2 ( 2 ), s3a ( 2 ) character ( 9 ) :: s4 ( 3 ), f4 ( 3 ) character ( 18 ) :: prc ! call assert_init ( 'TEST_REAL' ) prc = '' if ( srk == kind ( 0.0 )) prc = ', single precision' if ( srk == kind ( 0 d0 )) prc = ', double precision' call msg1 ( '  (kind = ' // tostring ( srk ) // trim ( prc ) // ')' ) s1 ( 1 ) = ' 2.15   0.01' s1 ( 2 ) = '-1.23  20.33' f1 = s1 ! s2 ( 1 ) = '--------AB-------' s2 ( 2 ) = '   12.00,-1234.57' f2 ( 1 ) = '-------AB------' f2 ( 2 ) = '   12.0,-1234.6' ! ! A number close to the largest possible real ! (r3 could for example be [1.2e21, -2e37] for single precision and [1.2e21, -2e307] for double) rrng = min ( 999 , range ( 0.0_srk )) ! test not designed for numbers >= 10**1000. write ( rrangec , '(i3.3)' ) rrng s3 ( 1 ) = 'A =  1.20000E+21' s3a ( 1 ) = 'A =  1.20000E+021' s3 ( 2 ) = '    -2.00000E+' // rrangec ( 2 : 3 ) s3a ( 2 ) = '    -2.00000E+' // rrangec f3 ( 1 ) = 'A =  1.2E+021' f3 ( 2 ) = '    -2.0E+' // rrangec r3 ( 1 , 1 ) = 1.2e21 r3_2chr = '-2e' // rrangec read ( r3_2chr , * ) r3 ( 2 , 1 ) ! s4 ( 1 ) = 'Longtitle' s4 ( 2 ) = '---------' s4 ( 3 ) = ' 0.00000 ' f4 ( 1 ) = 'Longtitle' f4 ( 2 ) = '*********' f4 ( 3 ) = '   0.    ' ! ! Test calls without format (r2(1,:) tests vector): call disp_set ( unit = 8 , style = 'PAD' , sep = ',' ) call disp ( r1 , digmax = 4 , style = 'LEFT' , sep = '  ' ); call compare ( s1 , 'ok-1' ) call disp ( 'AB' , r2 , trim = 'no' ); call compare ( s2 , 'ok-2' ) call disp ( 'AB' , r2 ( 1 ,:), trim = 'no' , orient = 'row' ); call compare ( s2 , 'ok-3' ) call disp ( 'A = ' , r3 , style = 'left' ); if ( rrng <= 99 ) call compare ( s3 , 'ok-4' ) if ( rrng > 99 ) call compare ( s3a , 'ok-4' ) call disp ( 'Longtitle' , r4 , style = 'underline' ); call compare ( s4 , 'ok-6' ) call disp ( 'Longtitle' , r5 , style = 'underline' ); call compare ( s4 , 'ok-7' ) ! Test calls with format: call disp ( r1 , 'f5.2' , style = 'LEFT' , sep = '  ' ); call compare ( f1 , 'ok-8' ) call disp ( 'AB' , r2 , 'f7.1' ); call compare ( f2 , 'ok-9' ) call disp ( 'AB' , r2 ( 1 ,:), 'f7.1' , orient = 'row' ); call compare ( f2 , 'ok-10' ) call disp ( 'A = ' , r3 , 'es9.1e3' , style = 'left' ); call compare ( f3 , 'ok-11' ) call disp ( 'Longtitle' , r4 , 'f2.0' , style = '*underline' ); call compare ( f4 , 'ok-12' ) call disp_set_factory end subroutine test_real !=================================================================================================================================== subroutine test_numbering integer :: i real ( srk ) :: r1 ( 2 , 2 ) = reshape (( / 2.146_srk , - 1.231_srk , 0._srk , 0.33_srk / ), ( / 2 , 2 / )) integer ( sik ) :: i2 ( 2 ) = ( / 0 , 0 / ), i3 ( 11 ) = ( / ( 0 , i = 1 , 11 ) / ), i4 ( 1 , 2 ) = reshape (( / 0 , 0 / ), ( / 1 , 2 / )) character ( 15 ) :: s1a ( 3 ), s1b ( 3 ), s1c ( 3 ), s1d ( 3 ), s1e ( 3 ), s1f ( 4 ) character ( 20 ) :: s1g ( 3 ) character ( 9 ) :: s2a ( 2 ), s2b ( 2 ), s2c ( 2 ), s2d ( 2 ), s2e ( 3 ), s4 ( 2 ) character ( 42 ) :: s3c ( 2 ) s1a = ( / '      1     2 ' ,& & '1   2.15  0.00' ,& & '2  -1.23  0.33' / ) s1b = ( / '     10    11 ' ,& & '1   2.15  0.00' ,& & '2  -1.23  0.33' / ) s1c = ( / '   10001  10002' ,& & '1    2.1    0.0' ,& & '2   -1.2    0.3' / ) s1d = ( / '    10   11 ' ,& & '1, 2.15,0.00' ,& & '2,-1.23,0.33' / ) s1e = ( / '    10    11 ' ,& & '1, 2.15, 0.00' ,& & '2,-1.23, 0.33' / ) s1f = ( / '------s1f-----' ,& & '      1     2 ' ,& & '1   2.15  0.00' ,& & '2  -1.23  0.33' / ) s1g = ( / '            1     2 ' ,& & 's1g = 1   2.15  0.00' ,& & '      2  -1.23  0.33' / ) ! s2a = ( / '1  2' ,& & '0  0' / ) s2b = ( / '-2  -1' ,& & ' 0   0' / ) s2c = ( / '1  0' ,& & '2  0' / ) s2d = ( / 'XX = 1  0' ,& & '     2  0' / ) s2e = ( / '-XX-' ,& & '1  0' ,& & '2  0' / ) s3c = ( / '-10  -9  -8  -7  -6  -5  -4  -3  -2  -1  0' ,& & '  0   0   0   0   0   0   0   0   0   0  0' / ) s4 = ( / '   1  2' ,& & '1  0  0' / ) ! call assert_init ( 'TEST_NUMBERING' ) call disp_set ( unit = 8 ) call disp ( r1 , 'F0.2' , style = 'number' ) ; call compare ( s1a ) call disp ( r1 , 'F0.2' , style = 'number' , lbound = ( / 1 , 10 / )) ; call compare ( s1b ) call disp ( r1 , 'F0.2' , lbound = ( / 1 , 10 / )) ; call compare ( s1b ) call disp ( r1 , 'F0.1' , lbound = ( / 1 , 10001 / )) ; call compare ( s1c ) call disp ( r1 , 'F0.2' , sep = ',' , lbound = ( / 1 , 10 / )) ; call compare ( s1d ) call disp ( r1 , 'F5.2' , sep = ',' , lbound = ( / 1 , 10 / )) ; call compare ( s1e ) call disp ( 's1f' , r1 , 'F0.2' , style = 'pad & number' ) ; call compare ( s1f ) call disp ( 's1g = ' , r1 , 'F0.2' , style = 'number' ) ; call compare ( s1g ) call disp ( i2 , style = 'number' , orient = 'row' ) ; call compare ( s2a ) call disp ( i2 , lbound = ( / 1 / ), orient = 'row' ) ; call compare ( s2a ) call disp ( i2 , lbound = ( /- 2 / ), orient = 'row' ) ; call compare ( s2b ) call disp ( i2 , style = 'number' ) ; call compare ( s2c ) call disp ( 'XX = ' , i2 , style = 'number' ) ; call compare ( s2d ) call disp ( 'XX' , i2 , style = 'pad & number' ) ; call compare ( s2e ) call disp ( i3 , lbound = ( /- 10 / ), orient = 'row' ) ; call compare ( s3c ) call disp ( i4 , style = 'number' ) ; call compare ( s4 ) end subroutine test_numbering !=================================================================================================================================== subroutine test_advance_double call assert_init ( 'TEST_ADVANCE_DOUBLE' ) call disp_set ( unit = 8 ) call disp ( 5 , advance = 'double' ) call disp ( 6 ) call compare (( / '5' , ' ' , '6' / )) call disp_set ( advance = 'double' ) call disp ( 7 , advance = 'no' ) call disp ( 8 ) call disp ( 9 ) call compare (( / '7   8' , '     ' , '9    ' , '     ' / )) call disp_set_factory end subroutine test_advance_double !=================================================================================================================================== subroutine test_advance_no call assert_init ( 'TEST_ADVANCE_NO' ) call disp_set ( unit = 8 ) call disp ( 1 , advance = 'no' ) call disp (( / 2 , 3 / ), advance = 'yes' ) call compare (( / '1   2' , '    3' / )) call disp_set_factory end subroutine test_advance_no !=================================================================================================================================== subroutine test_zeroas ! Test various features of using zeroas real ( srk ) :: d1 ( 3 , 2 ) = reshape (( / 2.146_srk , - 1.231_srk , 1._srk , 0._srk , 2 0.33_srk , 0._srk / ), ( / 3 , 2 / )) real ( srk ) :: d2 ( 2 ) = ( / 0._srk , 0._srk / ) real ( srk ) :: d3 ( 2 ) = ( / 1 2e20_srk , 0._srk / ) real ( srk ) :: d4 = 0._srk real ( srk ) :: r1 ( 3 , 2 ) = reshape (( / 2.146_srk , - 1.231_srk , 1._srk , 0._srk , 2 0.33_srk , 0._srk / ), ( / 3 , 2 / )) real ( srk ) :: r2 ( 2 ) = ( / 0._srk , 0._srk / ) integer ( sik ) :: i1 ( 4 ) = ( / 1 , 0 , 11 , 0 / ) integer ( sik ) :: i2 ( 2 , 2 ) = reshape (( / 0 , 0 , 11 , 12 / ), ( / 2 , 2 / )) character ( 12 ) :: s1a ( 3 ), s1b ( 3 ), s1c ( 3 ), s1d ( 3 ), s1e ( 3 ), s1f ( 3 ) character ( 3 ) :: s2 ( 1 ) character ( 16 ) :: s3 ( 2 ), s3a ( 2 ) character ( 9 ) :: s4 ( 2 ) character ( 2 ) :: s5 ( 4 ) character ( 5 ) :: s6 ( 2 ), s8 ( 2 ) character ( 12 ) :: s7 ( 3 ) ! s1a = ( / ' 2.15      *' ,& & '-1.23  20.33' ,& & ' 1.00      *' / ) s1b = ( / ' 2.15   0.  ' ,& & '-1.23  20.33' ,& & ' 1.00   0.  ' / ) s1c = ( / ' 2.15   000.' ,& & '-1.23  20.33' ,& & ' 1.00   000.' / ) s1d = ( / ' 2.15   .000' ,& & '-1.23  20.33' ,& & ' 1.00   .000' / ) s1e = ( / ' 2.1  zero  ' ,& & '-1.2  20.3  ' ,& & ' 1.0  zero  ' / ) s1f = ( / ' 2.1  zeroas' ,& & '-1.2    20.3' ,& & ' 1.0  zeroas' / ) ! s2 = '0,0' ! s3 ( 1 ) = 'A = 1.20000E+21' s3 ( 2 ) = '              0' ! s3a ( 1 ) = 'A = 1.20000+021' s3a ( 2 ) = '              0' ! s4 ( 1 ) = 'Longtitle' s4 ( 2 ) = '    0    ' ! s5 = ( / ' 1' , '  ' , '11' , '  ' / ) ! s6 = ( / '.  11' , '.  12' / ) ! s7 = ( / '   999  1000' , '1    .    11' , '2    .    12' / ) ! s8 = ( / '0  11' , '0  12' / ) ! call assert_init ( 'TEST_ZEROAS' ) call disp_set ( unit = 8 , style = 'PAD' , zeroas = '0' ) call disp ( d1 , digmax = 4 , zeroas = '*' ); call compare ( s1a ) call disp ( d1 , digmax = 4 , zeroas = '0.' ); call compare ( s1b ) call disp ( d1 , digmax = 4 , zeroas = '000.' ); call compare ( s1c ) call disp ( d1 , digmax = 4 , zeroas = '.000' ); call compare ( s1d ) call disp ( d1 , 'f4.1' , zeroas = 'zeroas' ); call compare ( s1e ) call disp ( d1 , digmax = 3 , zeroas = 'zeroas' ); call compare ( s1f ) call disp ( d2 , sep = ',' , orient = 'row' ); call compare ( s2 ) call disp ( 'A = ' , d3 , style = 'left' ); call compare ( s3 , 'zas' , s3a ) call disp ( 'Longtitle' , d4 ); call compare ( s4 ) call disp ( r1 , digmax = 4 , zeroas = '*' ); call compare ( s1a ) call disp ( r1 , digmax = 4 , zeroas = '0.' ); call compare ( s1b ) call disp ( r2 , sep = ',' , orient = 'row' ); call compare ( s2 ) call disp ( i1 , zeroas = ' ' ); call compare ( s5 ) call disp ( i2 , zeroas = '.' ); call compare ( s6 ) call disp ( i2 , zeroas = '.' , lbound = ( / 1 , 999 / )); call compare ( s7 ) call disp ( i2 , zeroas = '' ); call compare ( s8 ) call disp_set_factory end subroutine test_zeroas !=================================================================================================================================== subroutine test_complex ! Test disp with complex data real ( srk ) :: r1 ( 2 , 2 ) = reshape (( / 2.146_srk , - 1.231_srk , 0.008_srk , 2 0.33_srk / ), ( / 2 , 2 / )) real ( srk ) :: r2 ( 2 ) = ( / 1 2.0_srk , - 123 4.5678_srk / ) complex ( srk ) :: c1 ( 2 , 2 ), c2 ( 2 ), c3 character ( 29 ) :: s1 ( 2 ) character ( 31 ) :: s1a ( 2 ), s1b ( 2 ) character ( 36 ) :: s2 ( 2 ) character ( 16 ) :: s3 ( 1 ) ! call assert_init ( 'TEST_COMPLEX' ) s1 ( 1 ) = ' 2.15 + 4.29i   0.01 +  0.02i' s1 ( 2 ) = '-1.23 - 2.46i  20.33 + 40.66i' ! s1a ( 1 ) = ' 2.1460 + 4.3i   0.0080 +  0.0i' s1a ( 2 ) = '-1.2310 - 2.5i  20.3300 + 40.7i' ! s1b ( 1 ) = ' 2.1 + 4.2920i   0.0 +  0.0160i' s1b ( 2 ) = '-1.2 - 2.4620i  20.3 + 40.6600i' ! s2 ( 1 ) = '---------------AB--------------' s2 ( 2 ) = '12.0 + 12.0i, -1234.6 - 1234.6i' ! s3 ( 1 ) = '1.2345 - 2.3457i' ! c1 = cmplx ( r1 , 2 * r1 ) c2 = cmplx ( r2 , r2 ) c3 = ( 1.2345_srk , - 2.34567_srk ) ! call disp_set ( unit = 8 ) call disp ( c1 , 'F0.2' ); call compare ( s1 ) call disp ( c1 , 'F0.4' , fmt_imag = 'F0.1' ); call compare ( s1a ) call disp ( c1 , 'F0.1' , fmt_imag = 'F0.4' ); call compare ( s1b ) call disp_set ( style = 'PAD' , digmax = 5 , sep = ', ' ); call disp ( 'AB' , c2 , orient = 'row' ); call compare ( s2 ) call disp ( c3 ); call compare ( s3 ) call disp_set_factory end subroutine test_complex !=================================================================================================================================== subroutine test_char ! Check that disp works for outputting character strings with explicit or default format character ( 3 ) :: c1 ( 2 , 2 ) = reshape (( / 'ABC' , '   ' , 'A  ' , '  B' / ), ( / 2 , 2 / )) character ( 3 ) :: c2 ( 1 , 2 ) = reshape (( / 'ABC' , 'AB ' / ), ( / 1 , 2 / )) character ( 1 ) :: c3 ( 2 , 1 ) = reshape (( / 'X' , 'Y' / ), ( / 2 , 1 / )) character ( 3 ) :: c4 ( 1 , 1 ) = reshape (( / 'ABC' / ), ( / 1 , 1 / )) character ( 8 ) :: s1 ( 2 ) character ( 9 ) :: s2 ( 2 ) character ( 5 ) :: s3 ( 2 ) character ( 9 ) :: s4 ( 3 ) ! call assert_init ( 'TEST_CHAR' ) s1 = ( / 'ABC  A  ' ,& & '       B' / ) s2 = ( / '--title--' ,& & ' ABC, AB ' / ) s3 = ( / 'A = X' ,& & '    Y' / ) s4 = ( / 'Longtitle' ,& & '*********' ,& & '   ABC   ' / ) call disp_set ( unit = 8 , style = 'PAD' ) ! SPECIFIED FORMAT: call disp ( c1 , 'A' , style = 'left' ); call compare ( s1 ) call disp ( 'title' , c2 , 'A4' , sep = ',' ); call compare ( s2 ) call disp ( 'A = ' , c3 , 'a1' , style = 'left' ); call compare ( s3 ) call disp ( 'Longtitle' , c4 , 'A' , style = '*underline' ); call compare ( s4 ) ! DEFAULT FORMAT: call disp ( c1 , style = 'left' ); call compare ( s1 ) call disp ( 'A = ' , c3 , style = 'left' ); call compare ( s3 ) call disp ( 'Longtitle' , c4 , style = '*underline' ); call compare ( s4 ) call disp_set_factory end subroutine test_char !=================================================================================================================================== subroutine test_logical ! Check that disp works for outputting logicals with explicit or default format logical ( logikind ) :: l1 ( 2 , 2 ) logical ( logikind ) :: l2 ( 1 , 2 ) logical ( logikind ) :: l3 ( 2 , 1 ) logical ( logikind ) :: l4 character ( 5 ), dimension ( 2 ) :: s1 , s2 , s3 , s4 character :: s5 ( 1 ) integer ( selected_int_kind ( 2 )) :: nbytes = 0 l1 = reshape (( / . true ., . true ., . false ., . false . / ), ( / 2 , 2 / )) l2 = reshape (( / . false ., . true . / ), ( / 1 , 2 / )) l3 = reshape (( / . true ., . false . / ), ( / 2 , 1 / )) l4 = . true . nbytes = int ( size ( transfer ( l4 , ( / nbytes / ))), selected_int_kind ( 2 )) ! call assert_init ( 'TEST_LOGICAL' ) call msg1 ( '  (' // tostring ( int ( nbytes )) // ' byte logicals)' ) s1 = ( / ' T, F' ,& & ' T, F' / ) s2 = ( / 'T  F ' ,& & 'T  F ' / ) s3 = ( / 'title' ,& & 'F  T ' / ) s4 = ( / 'A = T' ,& & '    F' / ) s5 = ( / 'T' / ) ! call disp_set ( unit = 8 ) !SPECIFIED FORMAT: call disp ( l1 , 'L2' , sep = ',' ); call compare ( s1 ) call disp ( 'title' , l2 , 'L1' , style = 'pad' ); call compare ( s3 ) call disp ( 'A = ' , l3 , 'L1' ); call compare ( s4 ) !DEFAULT FORMAT: call disp ( l1 ); call compare ( s2 ) call disp ( 'title' , l2 , style = 'pad' ); call compare ( s3 ) call disp ( 'A = ' , l3 ); call compare ( s4 ) call disp ( l4 ); call compare ( s5 ) call disp_set_factory end subroutine test_logical !=================================================================================================================================== subroutine tests_from_manual call assert_init ( 'TESTS_FROM_MANUAL' ) call tests_from_manual_1 call tests_from_manual_2 call tests_from_manual_3 call tests_from_manual_4 call tests_from_manual_5 end subroutine tests_from_manual !=================================================================================================================================== subroutine tests_from_manual_1 ! Test examples in section 1 in the manual integer X ( 3 , 3 ) integer i , j , k , Y ( 3 ) real A ( 4 , 4 ), B ( 4 , 4 ) complex C ( 3 , 3 ) character ( 37 ) Ashouldbe ( 4 ) character ( 36 ) ANshouldbe ( 5 ) character ( 46 ) Bshouldbe ( 4 ) character ( 20 ) XYshouldbe ( 3 ) character ( 55 ) Cshouldbe ( 3 ) call assert_init ( '...section 1' ) A = reshape (( / (( real ( exp ( dble ( i + j - 1 ))) , i = 1 , 4 ), j = 1 , 4 ) / ), ( / 4 , 4 / )) B = reshape (( / (( real ( exp ( dble ( i * j ))), i = 1 , 4 ), j = 1 , 4 ) / ), ( / 4 , 4 / )) X = reshape (( / 7 , 8 , 3 , 4 , 0 , 2 , 1 , 3 , 6 / ), ( / 3 , 3 / ), order = ( / 2 , 1 / )) Y = ( / 11 , 2 , 7 / ) forall ( i = 1 : 3 , k = 1 : 3 ) C ( i , k ) = log ( cmplx ( - i * k )) ** k Ashouldbe = ( / & 'A =  2.72    7.39   20.09    54.60' , & '     7.39   20.09   54.60   148.41' , & '    20.09   54.60  148.41   403.43' , & '    54.60  148.41  403.43  1096.63' / ) ANshouldbe = ( / & '     1       2       3        4  ' , & '1   2.72    7.39   20.09    54.60' , & '2   7.39   20.09   54.60   148.41' , & '3  20.09   54.60  148.41   403.43' , & '4  54.60  148.41  403.43  1096.63' / ) Bshouldbe = ( / & '2.71828E+0  7.38906E+0  2.00855E+1  5.45981E+1' , & '7.38906E+0  5.45981E+1  4.03429E+2  2.98096E+3' , & '2.00855E+1  4.03429E+2  8.10308E+3  1.62755E+5' , & '5.45981E+1  2.98096E+3  1.62755E+5  8.88611E+6' / ) XYshouldbe = ( / & 'X = 7  8  3   Y = 11' , & '    4  0  2        2' , & '    1  3  6        7' / ) Cshouldbe = ( / & 'C = 0.000 + 3.142i  -9.389 +  4.355i  -31.203 - 19.631i' , & '    0.693 + 3.142i  -7.948 +  8.710i  -47.300 -  0.749i' , & '    1.099 + 3.142i  -6.659 + 11.258i  -54.449 + 14.495i' / ) call disp_set ( unit = 8 ) call disp ( 'A = ' , A ) call compare ( Ashouldbe , '1-A' ) call disp ( A , style = 'number' ) call compare ( ANshouldbe , '1-A' ) ! call disp ( B ) call compare ( Bshouldbe , '1-B' ) ! call disp ( 'X = ' , X , ADVANCE = 'no' ) call disp ( 'Y = ' , Y ) call compare ( XYshouldbe , '1-XY' ) ! call disp ( 'C = ' , C , 'F0.3' ) call compare ( Cshouldbe , '1-C' ) ! call disp_set_factory end subroutine tests_from_manual_1 !=================================================================================================================================== subroutine tests_from_manual_2 ! Test examples in section 2 in the manual REAL :: A ( 3 ) = ( / 1.2345 , 2.3456 , 3.4567 / ) CHARACTER ( 29 ) S call assert_init ( '...section 2' ) CALL DISP ( 'A = ' , A , UNIT = 8 , SEP = ', ' , ORIENT = 'ROW' ) rewind ( 8 ) read ( 8 , 1 ) S call msg2 ( S ) call assert ( S == 'A = 1.23450, 2.34560, 3.45670' , '2' ) call reopen_8 1 format ( A ) end subroutine tests_from_manual_2 !=================================================================================================================================== subroutine tests_from_manual_3 ! Test examples in section 3 in the manual real :: Matr ( 2 , 2 ) = reshape ( ( / 1.2 , 5.6 , 4.2 , 1 8.3 / ), ( / 2 , 2 / ) ) real :: z ( 2 , 3 ) = reshape (( / 1 4.28 , 1.42 , 1428571 4.0 , 14142 1.0 , 0.47 , 0.69 / ), ( / 2 , 3 / )) real :: x ( 2 , 2 ), pe ( 2 , 3 ) real :: A ( 0 : 3 , 0 : 3 ), B ( 4 , 4 ) integer xy ( 3 , 3 ), uv ( 3 ), i , j , k character ( 35 ) shouldbe_A ( 5 ) character ( 74 ) shouldbe_D ( 4 ) character ( 57 ) shouldbe_E ( 4 ) character ( 20 ) shouldbe_F ( 3 ) character ( 24 ) shouldbe_I ( 6 ) character ( 63 ) shouldbe_zas ( 4 ) call assert_init ( '...section 3' ) ! SECTION 3.1: call disp_set ( unit = 8 ) call disp ( - 4 4.6 , 'ES11.4E2' ) call disp ( - 4 4.6 , 'F8.4' ) call compare (( / '-4.4600E+01' , '-44.6000   ' / ), '3-A' ) ! CALL DISP ( 'str' , FMT = 'A4' ) CALL DISP ( 'str' , 'A4' ) call compare (( / ' str ' , 'strA4' / ), '3-B' ) ! ! SECTION 3.2: ! ! INTRODUCTION CALL DISP ( 'X=' , ( / 1 2.3 , 1 6.78 / ), DIGMAX = 3 , ORIENT = 'row' ) call compare (( / 'X=12.3  16.8' / ), '3-D' ) ! ! FMT_IMAG CALL DISP (( 1.31 , 2.47 ), 'F0.1' , 'F0.2' ) call compare (( / '1.3 + 2.47i' / ), '3-C' ) ! ! LBOUND forall ( i = 0 : 3 , j = 0 : 3 ) A ( i , j ) = real ( exp ( dble ( i + j - 1 ))) call disp ( A , style = 'number' , lbound = lbound ( A )) shouldbe_A = ( / & '     0       1       2        3  ' , & '0  0.368   1.000   2.718    7.389' , & '1  1.000   2.718   7.389   20.086' , & '2  2.718   7.389  20.086   54.598' , & '3  7.389  20.086  54.598  148.413' / ) call compare ( shouldbe_A ) call disp ( A , lbound = lbound ( A )) call compare ( shouldbe_A ) ! ! SEP CALL DISP ( reshape (( /- 1 , 5 , 5 , 10 / ),( / 2 , 2 / )), SEP = ', ' ) call compare (( / '-1,  5' , ' 5, 10' / ), '3-E' ) ! ! STYLE call disp ( 'a' , ( / 1 , 2 , 3 / ), style = '*underline' , orient = 'row' ) call compare (( / '   a   ' , '*******' , '1  2  3' / )) ! call disp_set ( matsep = '    ' ) call disp ( 'Matr = ' , Matr , digmax = 3 , Style = 'left' , advance = 'no' ) call disp ( 'Matr' , Matr , digmax = 3 , Style = 'pad' , advance = 'no' ) call disp ( 'Matr' , Matr , digmax = 3 , Style = 'underline' , advance = 'no' ) call disp ( Matr , digmax = 3 , Style = 'number' , advance = 'no' ) call disp ( 'Matr' , Matr , digmax = 3 , Style = '_pad & number' , advance = 'yes' ) shouldbe_D = ( / & 'Matr = 1.2   4.2    ---Matr--       Matr          1     2     ____Matr____' , & '       5.6  18.3    1.2   4.2    ---------    1  1.2   4.2        1     2 ' , & '                    5.6  18.3    1.2   4.2    2  5.6  18.3    1  1.2   4.2' , & '                                 5.6  18.3                    2  5.6  18.3' / ) call compare ( shouldbe_D , '3-F' ) ! ! TRIM call disp_set ( style = 'pad' , orient = 'row' , advance = 'no' , sep = ' ' , matsep = '   ' ) shouldbe_E = ( / & '----X----   -------Y------   -----U-----   -------V------' ,& '1  2    3      1    2    3   333 22 4444    333   22 4444' ,& '2 22   34      2   22   34                               ' ,& '3 32 1234      3   32 1234                               ' / ) xy = reshape (( / 1 , 2 , 3 , 2 , 22 , 32 , 3 , 34 , 1234 / ),( / 3 , 3 / )) uv = ( / 333 , 22 , 4444 / ) call disp ( 'X' , xy , trim = 'yes' ) call disp ( 'Y' , xy , trim = 'no' ) call disp ( 'U' , uv , trim = 'yes' ) call disp ( 'V' , uv , trim = 'no' , advance = 'yes' ) call compare ( shouldbe_E , '3-G' ) call disp_set_factory ; ! call disp_set ( style = 'above' , unit = 8 ) forall ( i = 1 : 2 , k = 1 : 3 ) pe ( i , k ) = real ( exp ( dble ( k ) ** i )) call disp ( 'power exponentials' , pe , trim = 'yes' ) shouldbe_F = ( / & ' power exponentials ' ,& '2.72   7.39    20.09' ,& '2.72  54.60  8103.08' / ) call compare ( shouldbe_F , '3-H' ) call disp_set_factory ; call disp_set ( unit = 8 ) ! x = reshape (( / 1.2e5 , 2.3e-3 , - 4.1e-2 , 8.6e1 / ), ( / 2 , 2 / )) call disp_set ( style = 'left' , sep = ' ' ) call disp ( 'X=' , x , 'es7.1e1' , trim = 'yes' ) call compare (( / 'X=1.2E+5 -4.1E-2' , '  2.3E-3  8.6E+1' / ), '3-I' ) call disp ( 'X=' , x , 'es7.1e1' , trim = 'no' ) call compare (( / 'X= 1.2E+5 -4.1E-2' , '   2.3E-3  8.6E+1' / ), '3-J' ) call disp_set_factory ; call disp_set ( unit = 8 ) ! ! ZEROAS forall ( i = 1 : 4 , j = 1 : 4 ) B ( i , j ) = max ( 0. , j - i + 1. ) where ( B > 0 ) B = 1 / B shouldbe_zas = ( / & 'A = 1.000  0.500  0.333  0.250   B = 1.000  0.500  0.333  0.250' , & '        0  1.000  0.500  0.333        .     1.000  0.500  0.333' , & '        0      0  1.000  0.500        .      .     1.000  0.500' , & '        0      0      0  1.000        .      .      .     1.000' / ) call disp ( 'A = ' , B , 'F0.3' , zeroas = '0' , advance = 'no' ) call disp ( 'B = ' , B , 'F0.3' , zeroas = '.' ) call compare ( shouldbe_zas , '3-ZAS' ) call disp_set_factory ; call disp_set ( unit = 8 ) ! ! SECTION 3.3: call disp ( 'TESTING NULL_UNIT -- THIS SHOULD NOT BE DISPLAYED' , unit = - 1 ) call disp ( 'TESTING NULL_UNIT -- THIS SHOULD NOT BE DISPLAYED' , unit = NULL_UNIT ) call assert ( ASTERISK_UNIT == - 3 , 'asterisk_unit' ) call assert ( PUTSTR_UNIT == - 2 , 'putstr_unit' ) call assert ( NULL_UNIT == - 1 , 'null_unit' ) ! ! SECTION 3.5 call disp ( 'F0.2' , z , 'f0.2' , style = 'pad' ) call disp ( \"F13.2, TRIM='yes'\" , z , 'f7.2' , style = 'pad' , trim = 'yes' ) shouldbe_I = ( / & & \"----------F0.2----------\" ,& & \"14.28  14285714.00  0.47\" ,& & \" 1.42    141421.00  0.69\" ,& & \"--F13.2, TRIM='yes'-    \" ,& & \"14.28  *******  0.47    \" ,& & \" 1.42  *******  0.69    \" / ) call compare ( shouldbe_I , '3-I' ) ! call disp_set_factory end subroutine tests_from_manual_3 !=================================================================================================================================== subroutine tests_from_manual_4 ! Test examples in section 4 in the manual type ( disp_settings ) ds real :: x ( 3 ) = ( / 1 2.2 , 9.6 , - 2.0 / ), y ( 3 ) = ( / 1.3 , 1 3.0 , 4.0 / ) integer :: z ( 3 ) = ( / 1 , 3 , 4 / ) character ( 15 ) :: s ( 3 ) = ( / '12.2 |  1.3 | 1' ,& & ' 9.6 | 13.0 | 3' ,& & '-2.0 |  4.0 | 4' / ) call assert_init ( '...section 4' ) call test_disp_set1 call disp_set ( style = 'PAD' , sep = ' ' ) ds = disp_get () call assert ( ds % style == 'PAD' , '4a' ) call assert ( ds % sep == ' ' . and . ds % seplen == 1 , '4b' ) call disp_set_factory call disp_set ( unit = 8 , digmax = 3 ) call disp ( x , advance = 'no' ) call disp ( y , advance = 'no' ) call disp_set ( matsep = ' | ' ) call disp ( z , advance = 'yes' ) call compare ( s , '4c' ) call disp_xy ( reshape ( x ,( / 1 , 3 / )), reshape ( y ,( / 1 , 3 / ))) ds = disp_get () call assert ( ds % sep == ' ' . and . ds % digmax == 3 ) call compare (( / 'x=12.20,9.60,-2.00' , 'y=1.30,13.00,4.00 ' / ), '4d' ) call disp_set_factory end subroutine tests_from_manual_4 !=================================================================================================================================== subroutine disp_xy ( x , y ) ! Utility for tests_from_manual_4 ! use M_display (already \"used\" here, but explicit in manual) real , intent ( in ) :: x (:,:), y (:,:) type ( disp_settings ) ds ds = disp_get () call disp_set ( digmax = 4 , sep = ',' ) call disp ( 'x=' , x ) call disp ( 'y=' , y ) call disp_set ( ds ) end subroutine disp_xy !=================================================================================================================================== subroutine tests_from_manual_5 ! Test examples in section 5 in the manual character ( 50 ) s integer i real ( srk ) sr character ( * ), parameter :: & ! Alternative results: s1 = '1, 256, 6561, 65536, 3.90625+005' , & s2 = '0.707107 + 0.707107i, 0.840896 + 0.840896i' , & s4 = '1.1, 2.2+010, 3.3+020' real :: x = 1.5 ! call assert_init ( '...section 5' ) call disp_set ( unit = 8 ) ! ! SECTIONS 5.1-5.3 call disp ( 'The square of ' // tostring ( x ) // ' is ' // tostring ( x * x )) call compare (( / 'The square of 1.5 is 2.25' / )) CALL TOSTRING_SET ( SEP = '; ' ) s = tostring (( / 1 , 2 / )) ; call scompare ( s , '1; 2' ) call tostring_set_factory ! ! SECTION 5.4 s = tostring ( atan ( 1.0 )) ; call tscompare ( s , ( / 0.785398 / ), '1a' ) !tostring(exp((/-3d0,-1d0,0d0,1d0/))) see (*) below s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 ) ; call scompare ( s , '1, 256, 6561, 65536, 3.90625E+05' , s1 ) s = tostring (( / 1.23456 , 1.2300 , 1.23456e6 / )) ; call tscompare ( s , ( / 1.23456 , 1.23 , 1.23456E+06 / ), '1c' ) s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 , 'f0.1' ) ; call scompare ( s , '1.0, 256.0, 6561.0, 65536.0, 390625.0' ) s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 , 'f6.1' ) ; call scompare ( s , '1.0, 256.0, 6561.0, ******, ******' ) s = tostring (( / 120000 0. , - 1.2e-9 / )) ; call scompare ( s , '1.2E+06, -1.2E-09' ) ! s = tostring ( - 77 ) ; call scompare ( s , '-77' ) s = tostring (( / ( i , i =- 3 , 3 ) / ) ** 11 ) ; call scompare ( s , '-177147, -2048, -1, 0, 1, 2048, 177147' ) s = tostring (( / ( i , i =- 3 , 3 ) / ) ** 11 , 'i7' ) ; call scompare ( s , '-177147, -2048, -1, 0, 1, 2048, 177147' ) s = tostring (( / ( i , i =- 3 , 3 ) / ) ** 11 , 'i4' ) ; call scompare ( s , '****, ****, -1, 0, 1, 2048, ****' ) ! s = tostring (( 1 , 3 ) / ( 4 , 2 )) ; call scompare ( s , '0.5 + 0.5i' ) s = tostring ( cmplx (( /- 1 , - 2 / )) ** 0.25 ) ; call scompare ( s , '0.70711 + 0.70711i, 0.8409 + 0.8409i' , s2 ) ! s = tostring (( / . true ., . false ., . false . / )) ; call scompare ( s , 'T, F, F' ) s = tostring (. true ., 'L2' ) ; call scompare ( s , 'T' ) ! call tostring_set ( sep = ';' ) s = tostring (( / 1 , 2 , 30 / )) ; call scompare ( s , '1;2;30' ) ! call tostring_set ( trimb = 'NO' ) s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 , 'f6.1' ) ; call scompare ( s , '   1.0; 256.0;6561.0;******;******' ) s = tostring (( / 1 , 2 , 30 / ), 'i3' ) ; call scompare ( s , '  1;  2; 30' ) s = tostring (( / ( i , i =- 3 , 3 ) / ) ** 11 , 'i4' ) ; call scompare ( s , '****;****;  -1;   0;   1;2048;****' ) s = tostring (( / 1 , 2 , 30 / ), 'i0' ) ; call scompare ( s , '1;2;30' ) s = tostring (. true ., 'L3' ) ; call scompare ( s , '  T' ) ! call tostring_set ( trimz = 'NONE' , sep = ', ' , trimb = 'YES' ) s = tostring ( real (( / ( i , i = 1 , 4 ) / )) ** 8 ) ; call tscompare ( s , ( / 1. , 25 6. , 656 1. , 6553 6. / ), '1d' ) s = tostring (( / 1.23456 , 1.2300 , 1.23456e6 / )) ; call tscompare ( s , ( / 1.23456 , 1.23 , 1.23456E+06 / ), '1e' ) if ( range ( 0._srk ) >= 103 ) then s = '1.2d103' read ( s , * ) sr s = tostring ( sr , 'ES11.5' ) ; call scompare ( s , '1.20000+103' ) call tostring_set ( trimz = 'ALL' ) s = tostring ( sr ) ; call scompare ( s , '1.2+103' ) s = tostring (( / 1.1_srk , 2.2e10_srk , 3.3e20_srk / )) ; call scompare ( s , '1.1, 2.2E+10, 3.3E+20' , s4 ) s = tostring ( exp (( /- 3._srk , - 1._srk , 0._srk , 1._srk / ))); call tscompare ( s , ( / 4.97871E-02 , 0.36788 , 1. , 2.71828 / ), '1b' ) ! (*) endif ! call tostring_set ( trimz = 'ALL' ) s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 , 'f0.1' ) ; call scompare ( s , '1, 256, 6561, 65536, 390625' ) ! call tostring_set ( rfmt = 'G12.4E2' ) s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 ) ; call scompare ( s , '1, 256, 6561, 0.6554E+05, 0.3906E+06' ) s = tostring (( / 120000 0. , - 1.2e-9 / )) ; call scompare ( s , '0.12E+07, -0.12E-08' ) ! call disp_set_factory call tostring_set_factory end subroutine tests_from_manual_5 !=================================================================================================================================== subroutine tscompare ( s , vec , msg ) character ( * ), intent ( in ) :: s , msg real , intent ( in ) :: vec (:) real svec ( size ( vec )) integer i read ( s , * ) svec do i = 1 , size ( vec ) call assert ( abs ( vec ( i ) - svec ( i )) / abs ( vec ( i )) < 1e-4 , 'tscompare:' // msg ) enddo end subroutine tscompare !=================================================================================================================================== subroutine test_empty ! Test display of empty vectors / matrices of various dimensions (0 by 0, 0 by 1, 1 by 0, 0 by 2 etc.) character ( 16 ) shouldbe ( 14 ) character ( 20 ) shouldbe_char ( 14 ) call assert_init ( 'TEST_EMPTY' ) shouldbe = ( / & 'v=,v=   ,v,-v-,*' , & 'v,*             ' , & ' ,*             ' , & ' v              ' , & '---             ' , & 'M02= ,M02=   ,* ' , & 'M02,  M02 ,*    ' , & '---,------,     ' , & 'M20=,M20=,*     ' , & '    ,    ,      ' , & 'M20,M20,*       ' , & '---,---,        ' , & '   ,   ,        ' , & '   ,   ,        ' / ) shouldbe_char = ( / & 'v=  ,v=   ,-v,-v-,* ' , & 'v,*                 ' , & ' ,*                 ' , & ' v                  ' , & '---                 ' , & 'M02=     ,M02=   ,* ' , & '  M02 , M02,*       ' , & '------,----,        ' , & 'M20=,M20=,*         ' , & '    ,    ,          ' , & 'M20,M20,*           ' , & '---,---,            ' , & '   ,   ,            ' , & '   ,   ,            ' / ) call disp_set ( unit = 8 , advance = 'no' , matsep = ',' ) call test_empty_int ; call compare ( shouldbe , 'int' ) call test_empty_real ; call compare ( shouldbe , 'real' ) call test_empty_logical ; call compare ( shouldbe , 'logical' ) call test_empty_char ; call compare ( shouldbe_char , 'char' ) call disp_set_factory call assert_init () end subroutine test_empty !=================================================================================================================================== subroutine test_empty_int integer :: ivec ( 0 ), i02mat ( 0 , 2 ), i20mat ( 2 , 0 ) ivec = 0 ; i02mat = 0 ; i20mat = 0 call msg2 ( '...empty integer' ) call disp ( 'v=' , ivec ) call disp ( 'v=' , ivec , 'I3' ) call disp ( 'v' , ivec , style = 'pad' ) call disp ( 'v' , ivec , 'I3' , style = 'pad' ) call disp ( '*' , advance = 'yes' ) call disp ( 'v' , ivec , style = 'pad' , orient = 'row' ) call disp (( / '*' , '*' / ), advance = 'yes' ) call disp ( 'v' , ivec , 'I3' , style = 'underline' , advance = 'yes' ) call disp ( 'M02=' , i02mat , sep = ':' ) call disp ( 'M02=' , i02mat , 'I1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M02' , i02mat , style = 'underline' ) call disp ( 'M02' , i02mat , 'I2' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20=' , i20mat , sep = ':' ) call disp ( 'M20=' , i20mat , 'I1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20' , i20mat , style = 'underline' ) call disp ( 'M20' , i20mat , 'I2' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) end subroutine test_empty_int !=================================================================================================================================== subroutine test_empty_logical logical ( logikind ) :: lvec ( 0 ), l02mat ( 0 , 2 ), l20mat ( 2 , 0 ) lvec = . false .; l02mat = . false .; l20mat = . false . call assert_init ( '...empty logical' ) call disp ( 'v=' , lvec ) call disp ( 'v=' , lvec , 'L3' ) call disp ( 'v' , lvec , style = 'pad' ) call disp ( 'v' , lvec , 'L3' , style = 'pad' ) call disp ( '*' , advance = 'yes' ) call disp ( 'v' , lvec , style = 'pad' , orient = 'row' ) call disp (( / '*' , '*' / ), advance = 'yes' ) call disp ( 'v' , lvec , 'L3' , style = 'underline' , advance = 'yes' ) call disp ( 'M02=' , l02mat , sep = ':' ) call disp ( 'M02=' , l02mat , 'L1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M02' , l02mat , style = 'underline' ) call disp ( 'M02' , l02mat , 'L2' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20=' , l20mat , sep = ':' ) call disp ( 'M20=' , l20mat , 'L1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20' , l20mat , style = 'underline' ) call disp ( 'M20' , l20mat , 'L2' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) end subroutine test_empty_logical !=================================================================================================================================== subroutine test_empty_real real :: rvec ( 0 ), r02mat ( 0 , 2 ), r20mat ( 2 , 0 ) rvec = 0.0 ; r02mat = 0.0 ; r20mat = 0.0 call assert_init ( '...empty real' ) call disp ( 'v=' , rvec ) call disp ( 'v=' , rvec , 'F3.0' ) call disp ( 'v' , rvec , style = 'pad' ) call disp ( 'v' , rvec , 'F3.0' , style = 'pad' ) call disp ( '*' , advance = 'yes' ) call disp ( 'v' , rvec , style = 'pad' , orient = 'row' ) call disp (( / '*' , '*' / ), advance = 'yes' ) call disp ( 'v' , rvec , 'F3.0' , style = 'underline' , advance = 'yes' ) call disp ( 'M02=' , r02mat , sep = ':' ) call disp ( 'M02=' , r02mat , 'F1.0' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M02' , r02mat , style = 'underline' ) call disp ( 'M02' , r02mat , 'F2.0' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20=' , r20mat , sep = ':' ) call disp ( 'M20=' , r20mat , 'F1.0' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20' , r20mat , style = 'underline' ) call disp ( 'M20' , r20mat , 'F2.0' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) end subroutine test_empty_real !=================================================================================================================================== subroutine test_empty_char character ( 2 ) :: cvec ( 0 ), c02mat ( 0 , 2 ), c20mat ( 2 , 0 ) cvec = '' ; c02mat = '' ; c20mat = '' ; call assert_init ( '...empty char' ) call disp ( 'v=' , cvec ) call disp ( 'v=' , cvec , 'A3' ) call disp ( 'v' , cvec , style = 'pad' ) call disp ( 'v' , cvec , 'A3' , style = 'pad' ) call disp ( '*' , advance = 'yes' ) call disp ( 'v' , cvec , style = 'pad' , orient = 'row' ) call disp (( / '*' , '*' / ), advance = 'yes' ) call disp ( 'v' , cvec , 'A3' , style = 'underline' , advance = 'yes' ) call disp ( 'M02=' , c02mat , sep = ':' ) call disp ( 'M02=' , c02mat , 'A1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M02' , c02mat , style = 'underline' ) call disp ( 'M02' , c02mat , 'A1' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20=' , c20mat , sep = ':' ) call disp ( 'M20=' , c20mat , 'A1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20' , c20mat , style = 'underline' ) call disp ( 'M20' , c20mat , 'A2' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) end subroutine test_empty_char !=================================================================================================================================== subroutine test_scalar_string ! Test features with scalar-string (and missing item) character ( 6 ) shouldbe ( 7 ) ! call assert_init ( 'TEST_SCALAR_STRING' ) shouldbe = ( / & 'A     ' , & '      ' , & ' B   C' , & 'T     ' , & '-     ' , & 'D     ' , & 'E=E   ' / ) call disp_set ( unit = 8 ) call disp ( 'A' ) call disp () call disp ( 'B' , fmt = 'A2' , advance = 'no' ) call disp ( 'C' , advance = 'yes' ) call disp ( 'T' , 'D' , style = 'underline' ) call disp ( 'E=' , 'E' , advance = 'no' ) call disp ( advance = 'yes' ) call compare ( shouldbe , 'x' ) call disp_set_factory end subroutine test_scalar_string !=================================================================================================================================== subroutine test_tostring character ( 50 ) s call assert_init ( 'TEST_TOSTRING' ) ! First test: call assert ( len ( tostring ( 1e23 , 'F0.2' )) == 26 . or . len ( tostring ( 1e23 , 'F0.2' )) == 27 ) s = tostring ( 1e23 , 'F0.2' ) call assert ( s ( 1 : 6 ) == '100000' . and . len_trim ( s ) == 27 . or . s ( 1 : 6 ) == '999999' . and . len_trim ( s ) == 26 ) ! Tests when factory defaults are in effect: call test_tostring_factory ! Tests of tostring when tostring_set is used to change defaults: call tostring_set ( sep = '::::' ) ; call scompare ( tostring (( / 1 , 2 , 3 / )), '1::::2::::3' ) call tostring_set ( ifmt = 'i3' ) ; call scompare ( tostring (( / 1 , 2 / )), '1::::2' ) call tostring_set ( trimb = 'NO' ) ; call scompare ( tostring (( / 1 , 2 / )), '  1::::  2' ) call tostring_set ( ifmt = 'i0' ) ; call scompare ( tostring (( / 1 , 2 / )), '1::::2' ) call tostring_set ( sep = '=1234567==' ) ; call scompare ( tostring (( / 1 , 2 / )), '1=1234567=2' ) call tostring_set ( rfmt = 'E7.1E2' ) ; call scompare ( tostring ( 1.0 ), '0.1E+01' ) call tostring_set ( rfmt = '1PE7.1E2' ) ; call scompare ( tostring ( 1.0 ), '1.0E+00' ) call tostring_set ( rfmt = '1PE6.0E2' ) ; call scompare ( tostring ( 1.0 ), '1.E+00' ) call tostring_set ( trimz = 'NONE' ) ; call scompare ( tostring ( 1.0 , 'F4.1' ), ' 1.0' ) call tostring_set ( trimz = 'ALL' ) ; call scompare ( tostring ( 1.0 , 'F4.1' ), ' 1' ) call tostring_set ( ifmt = 'i2' , sep = ',' ) ; call scompare ( tostring (( / 123 , 20 / )), '**,20' ) call tostring_set ( trimb = 'YES' ) ; call scompare ( tostring ( 1.0 , 'F4.1' ), '1' ) call tostring_set ( rfmt = 'F0.3' , ifmt = 'I4' , trimb = 'NO' , trimz = 'NONE' , sep = ';' ) call scompare ( tostring (( / 12345 , 123 / )) , '****; 123' ) call scompare ( tostring (( / 1.1239 , 12 3.45 / )), '1.124;123.450' ) call scompare ( tostring (( / ( 1.0_srk , 0.0_srk ),( 2.1_srk , - 8.7_srk ) / )), '1.000 + 0.000i;2.100 - 8.700i' ) call tostring_set_factory ! Confirm that behavior is back to original: call test_tostring_factory end subroutine test_tostring !=================================================================================================================================== subroutine test_tostring_factory ! Tests of tostring when original defaults are in effect call assert ( len ( tostring ( 5.86 )) == 4 ) call scompare ( tostring ( 5.86 ) , '5.86' ) call scompare ( tostring ( 5.86e10 ) , '5.86E+10' , '5.86+010' ) call scompare ( tostring (( / 1 , 100 , 10000 / )) , '1, 100, 10000' ) call scompare ( tostring (( / 1. , 10 0. , 1000 0. / )) , '1, 100, 10000' ) call scompare ( tostring ( 1 0.8 , 'F8.3' ) , '10.800' ) call scompare ( tostring ( 1 0.8 , 'F   8  .   3' ) , '10.800' ) call scompare ( tostring ( 1 0.8 , 'F2.1' ) , '**' ) call scompare ( tostring ( 1 0.8 , 'U9.2' ) , 'Illegal format' ) call scompare ( tostring ( 1 0.8 , '333' ) , 'Illegal format' ) call scompare ( tostring ( 1 0.8 , 'ES' ) , 'Illegal format' ) call scompare ( tostring ( 1 0.8 , '2F' ) , 'Illegal format' ) call scompare ( tostring ( 1 0.8 , 'SP,1PG10.3' ) , '+10.8' ) call scompare ( tostring ( 1 0.8e9 , 'SP,1PG10.3E2' ) , '+1.08E+10' , '+1.08+010' ) call scompare ( tostring (( 1.23 , - 3.222 )) , '1.23 - 3.222i' ) call scompare ( tostring (( / ( 1 , 1 ),( 2 , 2 ) / )) , '1 + 1i, 2 + 2i' ) call scompare ( tostring (( / ( 1 , 1 ),( 2 , 2 ) / ), 'F4.1' ) , '1.0 + 1.0i, 2.0 + 2.0i' ) end subroutine test_tostring_factory !=================================================================================================================================== subroutine scompare ( s , shouldbe , sb1 , sb2 , sb3 ) ! Utility for test_tostring. Print s to the screen and assert that it is ! matches either shouldbe, sb1, sb2 or sb3. character ( * ), intent ( in ) :: s , shouldbe , sb1 , sb2 , sb3 optional sb1 , sb2 , sb3 call msg2 ( '\"' // trim ( s ) // '\" should be \"' // trim ( shouldbe ) // '\"' ) if ( present ( sb3 )) call assert ( s == shouldbe . or . s == sb1 . or . s == sb2 . or . s == sb3 ) if ( present ( sb2 )) call assert ( s == shouldbe . or . s == sb1 . or . s == sb2 ) if ( present ( sb1 )) call assert ( s == shouldbe . or . s == sb1 ) if (. not . present ( sb1 )) call assert ( s == shouldbe ) end subroutine scompare !=================================================================================================================================== subroutine compare ( sok , message , sok1 ) ! Utility for all the test routines. Print to the screen what the last disp calls ! displayed, and assert that what was displayed matches either sok or sok1. character ( * ), intent ( in ) :: sok (:), sok1 (:), message optional :: message , sok1 character ( 100 ) :: s , mess integer ios1 , i rewind ( 8 ) compare_no = compare_no + 1 if ( present ( message )) then mess = message else write ( mess , '(a,\"-\",i0)' ) trim ( assert_string ), compare_no endif do i = 1 , 9999 read ( 8 , 1 , iostat = ios1 ) s if ( ios1 < 0 ) exit call msg2 ( s ) call assert ( i <= size ( sok ), message ) if ( present ( sok1 )) call assert ( sok ( i ) == s . or . sok1 ( i ) == s , mess ) if (. not . present ( sok1 )) call assert ( sok ( i ) == s , mess ) enddo call assert ( i == size ( sok ) + 1 , mess ) call reopen_8 1 format ( A ) end subroutine compare !=================================================================================================================================== subroutine reopen_8 call close_8 call open_8 end subroutine reopen_8 subroutine open_8 open ( 8 , file = 'testtmp.dat' , status = 'replace' ) end subroutine open_8 subroutine close_8 close ( 8 ) end subroutine close_8 !=================================================================================================================================== subroutine assert_init ( st ) ! Set assert-string (used by subroutine compare) to st, compare_no to zero and display st ! if verbose is true. If st is absent, set assert_string to '' character ( * ), optional , intent ( in ) :: st if ( present ( st )) then assert_string = st call msg2 ( '' ) call msg1 ( st ) else assert_string = '' endif compare_no = 0 end subroutine assert_init !=================================================================================================================================== subroutine assert ( s , msg ) ! Assert that s is true. If not print \"assertion failed\" and msg if it is present logical , intent ( in ) :: s character ( * ), optional , intent ( in ) :: msg if (. not . s ) then if ( present ( msg )) then print '(a, \": assertion failed\")' , trim ( msg ) else print '(\"assertion failed\")' endif stop 2 endif end subroutine assert !=================================================================================================================================== END PROGRAM TEST_M_display","tags":"","url":"program/test_m_display.html"},{"title":"DISPDEMO – M_display","text":"Uses M_display Variables Type Attributes Name Initial real(kind=RK) :: A (N,N) real(kind=RK) :: B (N,N) integer :: I integer :: J integer :: K (5) integer, parameter :: N = 3 integer, parameter :: RK = SELECTED_REAL_KIND(6) real(kind=RK) :: X Source Code PROGRAM DISPDEMO ! Example driver for M_display. USE M_display ! USE DISP_R16MOD IMPLICIT NONE INTEGER , PARAMETER :: RK = SELECTED_REAL_KIND ( 6 ), N = 3 REAL ( RK ) :: A ( N , N ), B ( N , N ), X INTEGER I , J , K ( 5 ) CALL DISP_SET ( ADVANCE = 'DOUBLE' ) FORALL ( I = 1 : N , J = 1 : N ) A ( I , J ) = EXP ( REAL ( I + J - 1 , RK )) B ( I , J ) = EXP ( REAL ( I ** J , RK )) END FORALL CALL DISP ( 'A = ' , A ) CALL DISP ( B ) CALL DISP ( A ( 1 : 2 ,:), 'F0.5' ) CALL DISP ( 'MATRIX' , A , STYLE = 'UNDERLINE & NUMBER' , UNIT =- 3 , DIGMAX = 4 ) K = ( /- 3 , 0 , 12 , 14 , 0 / ) CALL DISP ( 'K' , K , STYLE = 'PAD' , ORIENT = 'ROW' , SEP = ' ' , ZEROAS = '.' ) X = 1.5 CALL DISP ( 'The square of ' // TOSTRING ( X ) // ' is ' // TOSTRING ( X * X )) CALL DISP_SET ( MATSEP = ' | ' ) CALL DISP (( / 11 , 12 , 13 / ), ADVANCE = 'NO' ) CALL DISP (( / . TRUE ., . FALSE ., . TRUE . / ), ADVANCE = 'NO' ) CALL DISP (( / 'A' , 'B' , 'C' / )) END PROGRAM DISPDEMO","tags":"","url":"program/dispdemo.html"},{"title":"TEST_NANINF – M_display","text":"Uses ieee_arithmetic TEST_NANINF_MOD Variables Type Attributes Name Initial real(kind=srk) :: inf real(kind=srk) :: minf real(kind=srk) :: nan Source Code PROGRAM TEST_NANINF ! PROGRAM TO TEST DISPLAY OF NOT-A-NUMBER-S AND INFINITIES BY M_display ! (Appropriate for compilers that support IEEE-arithmetic as described in the Fortran 2003 standard) USE , INTRINSIC :: IEEE_ARITHMETIC USE TEST_NANINF_MOD ! USE DISP_R16MOD ! uncomment this line if testing of disp_r16mod (quad precision) is required ! ! Copyright (c) 2008, Kristj n J nasson, Dept. of Computer Science, University of ! Iceland (jonasson@hi.is). This software is free. For details see the file README. implicit none real ( srk ) nan , inf , minf nan = ieee_value ( 0._srk , ieee_quiet_nan ) inf = ieee_value ( 0._srk , ieee_positive_inf ) minf = ieee_value ( 0._srk , ieee_negative_inf ) call test_ni ( nan , inf , minf ) END PROGRAM TEST_NANINF","tags":"","url":"program/test_naninf~2.html"},{"title":"M_display.f90 – M_display","text":"Source Code !> !! !!   M_display, A FORTRAN 95 MODULE FOR PRETTY-PRINTING MATRICES. !! !!    o  Version number 1.02 6-Sept-2008 !!    o  Version number 2.00 31-Oct-2017, f2003 version; John S. Urban !! !!   Copyright (c) 2008, Kristjan Jonasson, Dept. of Computer Science, University of !!   Iceland (jonasson@hi.is). This software is free. For details see the file README. !! !!##AUTHOR !!   Based on dispmodule(3f), \"A Fortran 95 module for pretty-printing matrices\". !!   Version number 1.02 6-Sept-2008, !!   Kristjan Jonasson, Department of Computer Science, !!   School of Science and Engineering, University of Iceland, !!   Hjardarhaga 4, 107 Reykjavik, Iceland (jonasson@hi.is). !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== MODULE M_display__PUTSTRMODULE ! DUMMY VERSION ! An auxiliary module that accompanies M_display. This module contains dummy versions of the ! subroutines putstr and putnl that do nothing. It is needed to avoid an \"undefined symbol\" link ! error for these. In addition it defines the named constant (or parameter) DEFAULT_UNIT = -3, ! which makes the asterisk unit (usually the screen) the default to display on. ! ! The purpose of having this module is to make displaying possible in situations where ordinary ! print- and write-statements do not work. Then this module should be replaced by one defining ! functional versions of putstr and putnl. An example is given by the commented out M_display__PUTSTRMODULE ! for Matlab mex files below. ! integer , parameter :: DEFAULT_UNIT = - 3 ! CONTAINS !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine putstr ( s ) character ( * ), intent ( in ) :: s integer ldummy , ldummy1 ! these variables exist to avoid unused variable warnings ldummy = len ( s ) ldummy1 = ldummy ldummy = ldummy1 end subroutine putstr !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine putnl () end subroutine putnl !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== END MODULE M_display__PUTSTRMODULE !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! MODULE M_display__PUTSTRMODULE  ! for Matlab mex files. !   ! This module contains functional versions of subroutines putstr and putnl. It also sets !   ! DEFAULT_UNIT = -2, which makes putstr/putnl the default to display with. Using this module, !   ! instead of the dummy module above allows M_display to be used with Matlab mex files. !   ! used (commented in) instead of the one above (which should then be commented out), then !   ! M_display can be used with Matlab mex files. A shorter version (given in the user manual) !   ! may be used with g95, but the one below works for both g95 and gfortran. !   ! !   use, intrinsic :: ISO_C_BINDING !   integer, parameter :: default_unit = -2 !   interface !     subroutine mexprintf(s) bind(C, name = 'mexPrintf') !       import c_char !       character(kind=c_char) s(*) !     end subroutine mexprintf !   end interface ! CONTAINS !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !   subroutine putstr(s) !     character(*), intent(in) :: s !     call mexprintf(s//char(0)) !   end subroutine putstr !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !   subroutine putnl() !     call mexprintf(char(10)//char(0)) !   end subroutine putnl !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! END MODULE M_display__PUTSTRMODULE !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!      M_display(3f) - [M_display::INTRO] module for pretty-printing matrices !! !!##INTRODUCTION !! !! M_display is a standard Fortran 95 module for quick and easy displaying !! of numbers, vectors or matrices using default or specified format. It !! can be useful for debugging purposes, for preliminary display of !! numerical results, and even for final display of such results in cases !! when carefully formatted tables are not needed. It is comparable to the !! automatic matrix printing of Matlab, S and R, but offers substantially !! more control over the format used. !! !! The module can handle the standard Fortran data types integer, single !! precision, double precision, complex, logical and character. Integer, !! real, complex and logical data of other than default kind are supported !! with add-on modules. The module contains the following public procedures: !! !!     Subroutine DISP                  The main procedure used for displaying items !!     Subroutine DISP_SET              Used to change default settings for DISP !!     Subroutine DISP_SET_FACTORY      Restores DISP-settings to original (factory) default !!     Function DISP_GET                Returns a structure with current DISP-settings !!     Function TOSTRING                Returns a string representation of a scalar or vector !!     Subroutine TOSTRING_SET          Used to change default settings for TOSTRING !!     Subroutine TOSTRING_SET_FACTORY  Restores TOSTRING-settings to original default !! !! In addition the module defines a public derived type, DISP_SETTINGS, !! used for saving and restoring settings for DISP. The procedures DISP and !! TOSTRING have a generic interface and optional arguments, so the same !! subroutine / function name, is used to display items of different data !! types and ranks, with or without labels, and using default or specified !! format. Similarly DISP_SET is generic and can be used both to change !! individual settings and to restore previously saved settings. !! !! The most basic calling syntax for displaying is CALL DISP(expression) !! which will display the expression with default format. The format !! may be specified with CALL DISP(expression, edit- descriptor), and !! CALL DISP(title, expression) will label the displayed item with a !! title. Examples are CALL DISP(A), CALL DISP(A,'F9.3'), CALL DISP('A=',A) !! and CALL DISP('A=',A,'F9.3'), the last one specifying both title and !! format. If aij = exp(i + j - 1), i, j = 1,...,4, then CALL DISP('A = !! ', A) writes out: !! !!      > A =  2.72    7.39   20.09    54.60 !!      >      7.39   20.09   54.60   148.41 !!      >     20.09   54.60  148.41   403.43 !!      >     54.60  148.41  403.43  1096.63 !! !! and if bij = exp(i*j) the result of CALL DISP(B) is: !! !!      > 2.71828E+0  7.38906E+0  2.00855E+1  5.45981E+1 !!      > 7.38906E+0  5.45981E+1  4.03429E+2  2.98096E+3 !!      > 2.00855E+1  4.03429E+2  8.10308E+3  1.62755E+5 !!      > 5.45981E+1  2.98096E+3  1.62755E+5  8.88611E+6. !! !! It is also possible to number the rows and columns: CALL DISP(A, !! STYLE='NUMBER') will give: !! !!      >      1       2       3        4 !!      > 1   2.72    7.39   20.09    54.60 !!      > 2   7.39   20.09   54.60   148.41 !!      > 3  20.09   54.60  148.41   403.43 !!      > 4  54.60  148.41  403.43  1096.63. !! !! The selection between F and E editing depends on the size of the largest !! displayed element as discussed in section 3.2 below. Among the settings !! that may be controlled is the spacing between columns, the number !! of significant digits, the placement of the label, and the file unit !! where the output goes. Items can in addition be displayed side by side, !! for example: !! !!      > CALL DISP('X = ', X, ADVANCE='NO') !!      > CALL DISP('Y = ', Y) !! !! which might output: !! !!      > X = 7  8  3   Y = 11 !!      >     4  0  2        2 !!      >     1  3  6        7 !! !! Complex numbers are formatted as illustrated by: !! !!      > COMPLEX C(3,3) !!      > FORALL(I=1:3, K=1:3) C(I,K)=LOG(CMPLX(-I*K))**K !!      > CALL DISP('C = ', C, 'F0.3') !! !! which will display !! !!      > C = 0.000 + 3.142i   -9.389 +  4.355i   -31.203 - 19.631i !!      >     0.693 + 3.142i   -7.948 +  8.710i   -47.300 -  0.749i !!      >     1.099 + 3.142i   -6.659 + 11.258i   -54.449 + 14.495i !! !! infinite and not-a-number real values are supported and displayed as nan, !! +inf or -inf. !! !! the remaining sections in this user manual contain detailed information !! on using the module. section 2 discusses the basics of using the !! module, including use statements, compiling and linking, and add-on !! modules supporting non-default kinds of data. section 3 gives a detailed !! description of the generic subroutine disp. all the possible arguments !! are listed and the purpose of each one described. section 4 describes !! how to change various settings that control how items are displayed with !! disp. section 5 describes the function tostring which may be used to !! change numbers to strings. finally testing of the module is discussed !! in section 6. !! !!##OVERVIEW OF MODULES !! !! The file M_display.f90 actually begins with two auxiliary modules, !! M_display__PUTSTRMODULE and M_display__UTIL. The first one contains two dummy !! subroutines, PUTSTR and PUTNL, which do nothing, but must be incorporated !! to avoid an \"undefined symbol\" link error. In addition it defines the !! named constant (parameter) DEFAULT_UNIT = -3, which makes the asterisk !! unit (usually the screen) the default to display on. !! !! Alternatively the user can write his own M_display__PUTSTRMODULE as described !! below. An example is near the beginning of M_display.f90 (commented out) !! and also in the file putstrmodule_mex.f90, enclosed with the package. It !! may be used (commented in instead of the default one) to allow Matlab !! mex files to display in the Matlab command window. !! !!##AN EXAMPLE PROGRAM !! !! Following is a short example program that uses the package: !! !!       program example !!         use M_display !!         real :: a(3) = [ 1.2345, 2.3456, 3.4567 ] !!         call disp('A = ', A, SEP=', ', ORIENT = 'ROW') !!       end program example !! !! The program should write out \"A = 1.23450, 2.34560, 3.45670\". !! !! A longer example program: !! !!    program demo_M_display !!    use M_display !!    implicit none !!    integer, parameter :: rk = selected_real_kind(6), n = 3 !!    real(rk) :: a(n,n), b(n,n), x !!    integer i, j, k(5) !!      call disp_set(advance = 'double') !!      forall(i=1:n, j=1:n) !!        a(i,j) = exp(real(i+j-1, rk)) !!        b(i,j) = exp(real(i**j, rk)) !!      end forall !!      call disp('A = ', a) !!      call disp(b) !!      call disp(a(1:2,:),'f0.5') !!      call disp('MATRIX', a, style='UNDERLINE & NUMBER', unit=-3, digmax=4) !!      k = [-3,0,12,14,0] !!      call disp('K', k, style='pad', orient='row', sep=' ', zeroas='.') !!      x = 1.5 !!      call disp('The square of '//tostring(x)//' is '//tostring(x*x)) !!      call disp_set(matsep = ' | ') !!      call disp([11,12,13], advance='no') !!      call disp([.true., .false., .true.], advance='no') !!      call disp(['A','B','C']) !!    end program demo_M_display !! !! Expected results: !! !!     > A =  2.718   7.389   20.086 !!     >      7.389  20.086   54.598 !!     >     20.086  54.598  148.413 !!     > !!     > 2.71828E+00  2.71828E+00  2.71828E+00 !!     > 7.38906E+00  5.45982E+01  2.98096E+03 !!     > 2.00855E+01  8.10308E+03  5.32048E+11 !!     > !!     > 2.71828   7.38906  20.08554 !!     > 7.38906  20.08554  54.59815 !!     > !!     >        MATRIX !!     > -------------------- !!     >      1     2      3 !!     > 1   2.7   7.4   20.1 !!     > 2   7.4  20.1   54.6 !!     > 3  20.1  54.6  148.4 !!     > !!     > ------K----- !!     > -3 . 12 14 . !!     > !!     > The square of 1.5 is 2.25 !!     > !!     > 11 | T | A !!     > 12 | F | B !!     > 13 | T | C !! !!##AUTHOR !!     Based on dispmodule(3f), !!     \"A Fortran 95 module for pretty-printing matrices\". !!     Version number 1.02 6-Sept-2008, !!     Kristjan Jonasson, !!     Dept. of Computer Science, !!     University of Iceland (jonasson@hi.is). !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== MODULE M_display__UTIL ! M_display__util contains utilities that are used by M_display, and the add-on modules ! disp_i1mod, disp_i2mod,..., disp_l1mod and disp_r16mod. Note that the entities that are ! declared public below are not exported to the user. The private statements in M_display and ! the add-on modules prevent that from happening. use M_display__putstrmodule implicit none ! ident_1=\"@(#) M_display(3fm) module for pretty-printing matrices\" ! ***************** PUBLIC ENTITIES (ONLY PUBLIC TO M_display, NOT TO USER PROGRAMS) *************** private public disp_settings , defset , factory_settings , tosset , tosfac , errormsg , tostring_settings public nnblk , upper , readfmt , replace_w , trim_real , get_SE , preparebox , copytobox , boxlist , boxnode public copyseptobox , finishbox , tostring_get_complex , disp_errmsg , tostring_get , find_editdesc_real public check_settings , tostring_check_settings , replace_zeronaninf , settings , trim_s_real ! *********************************** GENERAL DECLARATIONS ******************************************** type disp_settings ! Settings used by subroutine disp and the utility procedures. character ( 6 ) :: advance = 'YES' character ( 9 ) :: matsep = '   ' character ( 3 ) :: orient = 'COL' character ( 9 ) :: sep = '  ' character ( 20 ) :: style = 'LEFT' character ( 4 ) :: trim = 'AUTO' character ( 9 ) :: zeroas = '' integer :: digmax = 6 integer :: matseplen = 3 integer :: seplen = 2 integer :: unit = DEFAULT_UNIT integer :: zaslen = 0 end type disp_settings type tostring_settings ! Settings used by function tostring. character ( 10 ) :: ifmt = 'I0' character ( 16 ) :: rfmt = '1PG12.5' ! 'SP,1P,G20.11E3' has length 14 and is about max character ( 9 ) :: sep = ', ' integer :: seplen = 2 character ( 3 ) :: trimb = 'YES' character ( 4 ) :: trimz = 'G' end type tostring_settings type settings ! Settings used (privately) by disp and the utility procedures, in the variable SE. character ( 22 ) ed character ( 9 ) sep , tsty , zas character ( 1 ) tch integer lun , dmx , w , d , lsep , lzas , m1 , n1 , adv logical trm , number , vec , row , gedit end type settings type ( disp_settings ), save :: DEFSET , & ! Current default settings for disp & FACTORY_SETTINGS ! Original (factory) settings for disp type ( tostring_settings ), save :: tosset , & ! Current settings for tostring & tosfac ! Factory settings for tostring character ( * ), parameter :: errormsg = 'Illegal format' ! ********************* BOX-PACKAGE DECLARATIONS (SEE EXPLANATION ABOUT BOX-PACKAGE BELOW) ***************** type boxnode ! A box is the character representation of a printed item character , pointer :: box (:,:) type ( boxnode ), pointer :: nextbox => null () end type boxnode ! type boxlist ! There is one list of boxes associated with each logical unit integer :: unit = 1 type ( boxnode ), pointer :: firstbox => null () type ( boxnode ), pointer :: lastbox => null () type ( boxlist ), pointer :: nextboxlist => null () end type boxlist ! type ( boxlist ), pointer :: firstboxlist => null () ! ************************ END OF BOX-PACKAGE DECLARATIONS ****************************** CONTAINS !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! ******************************************************* GENERAL PROCEDURES ******************************************************* !=================================================================================================================================== subroutine check_settings () ! Sanity check of display settings character ( 9 ) :: tsty character tch logical number , ok , dmxerr , orierr , styerr , adverr character ( 6 ), parameter :: ADVOK ( 3 ) = [ 'NO    ' , 'YES   ' , 'DOUBLE' ] type ( disp_settings ) ds ds = DEFSET call getstyles ( ds % style , tsty , tch , number , ok ) styerr = . not . ok dmxerr = ds % digmax < 1 . or . ds % digmax > 89 orierr = all ( ds % orient /= [ 'ROW' , 'COL' ]) adverr = all ( ds % advance /= ADVOK ) if ( dmxerr ) DEFSET % digmax = 6 if ( orierr ) DEFSET % orient = 'COL' if ( styerr ) DEFSET % style = 'LEFT' if ( adverr ) DEFSET % advance = 'YES' ! if ( dmxerr ) call disp_errmsg ( 'DISP_SET: error, illegal digmax (must be 1-89), set to 6' ) if ( orierr ) call disp_errmsg ( 'DISP_SET: error, illegal orient: ' // trim ( ds % orient ) // ', set to \"COL\"' ) if ( styerr ) call disp_errmsg ( 'DISP_SET: error, illegal style: ' // trim ( ds % style ) // ', set to \"LEFT\"' ) if ( adverr ) call disp_errmsg ( 'DISP_SET: error, illegal advance: ' // trim ( ds % advance ) // ', set to \"YES\"' ) end subroutine check_settings !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function number_rows ( SE ) result ( nbr ) ! Should rows be numbered? type ( settings ), intent ( in ) :: SE logical nbr nbr = . false . if (. not . SE % number ) return if ( SE % vec . and . SE % row ) return nbr = . true . end function number_rows !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function number_cols ( SE ) result ( nbr ) ! Should columns be numbered? type ( settings ), intent ( in ) :: SE logical nbr nbr = . false . if (. not . SE % number ) return if ( SE % vec . and . . not . SE % row ) return nbr = . true . end function number_cols !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine preparebox ( title , SE , m , n , wid , widp , lin1 , wleft , boxp ) ! Determine format to use to write matrix to box and row where matrix begins, copy character ( * ), intent ( in ) :: title ! The title to use for the matrix type ( settings ), intent ( in ) :: SE ! Settings integer , intent ( in ) :: m ! Row count of matrix integer , intent ( in ) :: n ! Column count of matrix integer , intent ( inout ) :: wid (:) ! widths of columns in matrix integer , intent ( out ) :: widp (:) ! widths of columns in box (max(wid, width of col nums)) integer , intent ( out ) :: lin1 ! Row number where matrix begins (tsty='left' 0, 'pad' 1, 'underline' 2) integer , intent ( out ) :: wleft ! Number of spaces on left of matrix (when tsty is left or title long) character , pointer :: boxp (:,:) ! The box integer wt , wa ! Char count of title, idth of matrix in characters (wbox = lm + wa + rm) integer wbox , wrow ! Width of box in characters, width of row numbers in characters integer lm ! Left margin integer h , ws ! Height of box in characters, length of column separator integer m1 , n1 , i ! lower bounds (for numbering), index character ( range ( 0 ) + 2 ) sn ( 2 ), row_nums ( m ), col_nums ( n ) character ( 10 ) fmt ! ----------wbox---------    -----------wbox----------     -----wbox------ ! ---lm---                   --wleft-                             --wt- ! ----wleft---                lm wrow    wa       rm       wrow    wa !    wt   wrow    wa         ----====-----------======     ----=========== ! --------====-----------    THIS-IS-A-VERY-LONG-TITLE            TITLE !               1     2                1     2                   1     2 ! MATRIX = 1   4.50  6.80         1   4.50  6.80            1   4.50  6.80 !          2   6.88  9.22         2   6.88  9.22            2   6.88  9.22 !          3  19.44  0.08         3  19.44  0.08            3  19.44  0.08 !          ...                    ...                       ... !         10   6.18  4.22        10   6.18  4.22           10   6.18  4.22 ! rm = 0                     wt = wbox                     lm = rm = 0, wleft = wrow m1 = SE % m1 n1 = SE % n1 ws = SE % lsep wt = len ( title ) wrow = 0 widp = wid if ( SE % number ) then fmt = '(SS,I0)' if ( number_cols ( SE )) then write ( col_nums , fmt ) [ ( i , i = n1 , n1 + n - 1 ) ] widp = max ( wid , len_trim ( col_nums )) endif if ( number_rows ( SE )) then write ( sn , fmt ) m1 , m1 + m - 1 wrow = maxval ( len_trim ( sn )) + ws ! determine max width of row numbers call replace_w ( fmt , wrow - ws ) ! to create e.g. 'I5' from 'I0' write ( row_nums , fmt ) [ ( i , i = m1 , m1 + m - 1 ) ] endif endif wa = max ( 0 , n - 1 ) * ws + sum ( widp ) select case ( upper ( SE % tsty )) case ( 'LEFT' ); lin1 = 1 ; wbox = wt + wrow + wa ; h = max ( 1 , m ); lm = wt case ( 'PAD' ); lin1 = 2 ; wbox = max ( wt , wa + wrow ); h = m + 1 ; lm = max ( 0 , ( wt - wa - wrow ) / 2 ) case ( 'UNDERLINE' ); lin1 = 3 ; wbox = max ( wt , wa + wrow ); h = m + 2 ; lm = max ( 0 , ( wt - wa - wrow ) / 2 ) case default ; lin1 = 1 ; wbox = 0 ; h = 0 ; lm = 0 ! should not happen end select wleft = lm if ( number_cols ( SE )) h = h + 1 call newbox ( SE % lun , h , wbox , boxp ) if ( number_cols ( SE )) then call copycolumnnumberstobox ( col_nums , wleft + wrow , wid , widp , ws , boxp , lin1 ) endif if ( number_rows ( SE )) then call copytobox ( row_nums , lin1 , wrow - ws , wrow - ws , nblj = 0 , boxp = boxp , wleft = wleft ) call copyseptobox ( SE % sep ( 1 : SE % lsep ), m , lin1 , boxp , wleft ) endif end subroutine preparebox !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine copytobox ( s , lin1 , widj , widpj , nblj , boxp , wleft ) ! Copy strings to column in boxp; update wleft to current char column in boxp character ( * ), intent ( in ) :: s (:) ! the strings to copy integer , intent ( in ) :: lin1 , widj ! first line in box to copy to, width of column integer , intent ( in ) :: nblj , widpj ! number of blank characters to trim from left of s, offset to next col character , intent ( inout ) :: boxp (:,:) ! the box to accept the column integer , intent ( inout ) :: wleft ! number of char-columns in box already written to integer i , j wleft = wleft + widpj - widj forall ( i = 1 : widj , j = 1 : size ( s )) boxp ( wleft + i , j + lin1 - 1 ) = s ( j )( i + nblj : i + nblj ) wleft = wleft + widj end subroutine copytobox !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine copyseptobox ( sep , m , lin1 , boxp , wleft ) ! Copy column separator to boxp; update wleft character ( * ), intent ( in ) :: sep integer , intent ( in ) :: m , lin1 character , intent ( inout ) :: boxp (:,:) integer , intent ( inout ) :: wleft integer i , j forall ( i = 1 : len ( sep ), j = 1 : m ) boxp ( wleft + i , j + lin1 - 1 ) = sep ( i : i ) wleft = wleft + len ( sep ) end subroutine copyseptobox !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine copycolumnnumberstobox ( s , wleft , wid , widp , lsep , boxp , lin1 ) character ( * ), intent ( in ) :: s (:) ! strings with left-adjusted column numbers integer , intent ( in ) :: wleft ! char positions on left of 1st col integer , intent ( in ) :: wid (:) ! widths of columns in matrix integer , intent ( in ) :: widp (:) ! widths of columns in box (max(wid, width of col nums)) integer , intent ( in ) :: lsep ! width of column separator character , intent ( inout ) :: boxp (:,:) ! receives the numbers integer , intent ( inout ) :: lin1 ! line number in box to copy to integer ls ( size ( s )), rmargmax , k , i , lmargin , j ! ls = len_trim ( s ) rmargmax = ( max ( 0 , minval ( wid ) - maxval ( ls ))) / 2 ! locate according to narrowest column, widest number k = wleft do i = 1 , size ( wid ) lmargin = max ( 0 , widp ( i ) - ls ( i ) - rmargmax ) k = k + lmargin forall ( j = 1 : ls ( i )) boxp ( k + j , lin1 ) = s ( i )( j : j ) k = k + widp ( i ) - lmargin + lsep enddo lin1 = lin1 + 1 end subroutine copycolumnnumberstobox !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine finishbox ( title , SE , boxp ) ! Finish creating a box and display it if advancing is turned on character ( * ), intent ( in ) :: title ! The title to use for the matrix type ( settings ), intent ( in ) :: SE ! Settings character , intent ( inout ) :: boxp (:,:) ! The box ! integer i , wt , w , wpadright , wpadleft ! index, width of title, width of box and spacing on either side of it integer lin1 ! line to put left title ! wt = len ( title ) w = size ( boxp , 1 ) if ( upper ( SE % tsty ) == 'LEFT' ) then lin1 = 1 if ( number_cols ( SE )) lin1 = min ( 2 , size ( boxp , 2 )) forall ( i = 1 : wt ) boxp ( i , lin1 ) = title ( i : i ) else wpadright = ( w - wt ) / 2 wpadleft = w - wpadright - wt forall ( i = 1 : wt ) boxp ( wpadleft + i , 1 ) = title ( i : i ) if ( upper ( SE % tsty ) == 'PAD' ) then boxp ( 1 : wpadleft , 1 ) = SE % tch boxp ( w - wpadright + 1 : w , 1 ) = SE % tch else ! tsty == 'UNDERLINE' boxp (:, 2 ) = SE % tch endif endif if ( SE % adv >= 1 ) call dispboxlist ( SE % lun , DEFSET % matsep ( 1 : DEFSET % matseplen )) if ( SE % adv >= 2 ) call dispnewline ( SE % lun ) end subroutine finishbox !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine find_editdesc_real ( exp , expm , dmx , edesc , flen , ndec , posit ) ! Subroutine of find_editdesc_sngl and find_editdesc_dble integer , intent ( in ) :: expm , dmx integer , intent ( inout ) :: exp character ( 14 ), intent ( out ) :: edesc integer , intent ( out ) :: flen , ndec logical , intent ( in ) :: posit integer :: neg , nxp exp = max ( exp , expm ) neg = 1 if ( exp < dmx . and . exp >= - 1 ) then if ( posit . or . exp > max ( 0 , expm )) neg = 0 edesc = '(SS,Fxx.yy)' ndec = max ( 0 , dmx - exp - 1 ) flen = neg + 2 + ndec + max ( 0 , exp ) ! -X.YYYYY (2 covers X and .) write ( edesc ( 6 : 10 ), '(SS,I2,\".\",I2)' ) flen , ndec else if ( posit ) neg = 0 if ( abs ( exp ) > 999 ) then ; nxp = 4 elseif ( abs ( exp ) > 99 ) then ; nxp = 3 elseif ( abs ( exp ) > 9 ) then ; nxp = 2 else ; nxp = 1 endif flen = neg + 3 + dmx + nxp edesc = '(SS,ESxx.yyEz)' write ( edesc ( 7 : 13 ), '(SS,I2,\".\",I2,\"E\",I1)' ) flen , dmx - 1 , nxp ndec = dmx - 1 endif end subroutine find_editdesc_real !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine readfmt ( fmt , fmt1 , w , d , gedit ) ! Returns w and d when fmt is (Xw.d) or (Xw) (then d = 0), X = edit descriptor letter ! (I, F, etc). X can also be ES, DS, 1PG or 1PF. Returns w = -1 for illegal fmt. ! Returns gedit = .true. if fmt is Gw.d. How about SS,1PES4.3? character ( * ), intent ( in ) :: fmt ! e.g. fmt = F 8.2 character ( * ), intent ( out ) :: fmt1 ! returns '(SS,F8.2)' character ch integer , intent ( out ) :: w , d logical , intent ( out ) :: gedit integer :: k0 , k1 , k2 , k3 , k4 call sszipfmt ( fmt , fmt1 ) w = - 1 ; d = 0 ; gedit = . false . k1 = verify ( fmt1 ( 2 :), '0123456789' ) + 1 if ( k1 == 0 ) return ! only digits k2 = verify ( fmt1 ( k1 :), 'ABDEFGILNOPSZabdefgilnopsz,' ) + k1 - 1 ! , for \"1P,G12.3\" if ( k2 <= k1 ) return ! no letter or only letters ch = upper ( fmt1 ( k2 - 1 : k2 - 1 )) if ( ch == ',' ) then ! deal with SS,1PG13.5 k0 = k2 k1 = verify ( fmt1 ( k0 :), '0123456789' ) + k0 - 1 if ( k1 == 0 ) return k2 = verify ( fmt1 ( k1 :), 'ABDEFGILNOPSZabdefgilnopsz,' ) + k1 - 1 if ( k2 <= k1 ) return ch = upper ( fmt1 ( k2 - 1 : k2 - 1 )) endif gedit = ch == 'G' . or . ch == 'g' k3 = verify ( fmt1 ( k2 :), '0123456789' ) + k2 - 1 if ( k3 == k2 ) return ! no digits read ( fmt1 ( k2 : k3 - 1 ), * ) w if ( k3 > len ( fmt1 )) return if ( fmt1 ( k3 : k3 ) /= '.' ) return ! not . after w k4 = verify ( fmt1 ( k3 + 1 :), '0123456789' ) + k3 if ( k4 == k3 + 1 ) return ! no digits read ( fmt1 ( k3 + 1 : k4 - 1 ), * ) d end subroutine readfmt !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine replace_w ( fmt , wnew ) ! Change e.g. '(F0.3)' to '(F5.3)'. Works also for '(SS,I0)' to '(SS,I5)'. If wnew > 999, set it to 999 character ( * ), intent ( inout ) :: fmt integer , intent ( in ) :: wnew integer :: k0 , k1 , k2 , k3 character ( 3 ) rw k1 = verify ( fmt ( 2 :), '0123456789' ) + 1 k2 = verify ( fmt ( k1 :), 'ABDEFGILNOPSZabdefgilnopsz,' ) + k1 - 1 if ( k2 == k1 ) return ! no letter if ( fmt ( k2 - 1 : k2 - 1 ) == ',' ) then ! Handle (SS,1PF10.3) k0 = k2 k1 = verify ( fmt ( k0 :), '0123456789' ) + 1 if ( k1 == 0 ) return k2 = verify ( fmt ( k1 :), 'ABDEFGILNOPSZabdefgilnopsz,' ) + k1 - 1 if ( k2 <= k1 ) return endif k3 = verify ( fmt ( k2 :), '0123456789' ) + k2 - 1 if ( k3 == k2 ) return ! no digits write ( rw , '(SS,I0)' ) min ( 999 , wnew ) fmt = fmt ( 1 : k2 - 1 ) // trim ( rw ) // fmt ( k3 :) end subroutine replace_w !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine get_SE ( SE , title , shapex , fmt , advance , lbound , separator , style , trim , unit , orient , zeroas , digmax ) ! Get the settings from the optional parameters fmt...zeroas in to the structure SE. ! Replace absent arguments with corresponding values from the structure DEFSET. type ( settings ), intent ( out ) :: SE character ( * ), intent ( in ) :: title integer , intent ( in ) :: shapex (:) character ( * ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: unit , digmax , lbound (:) character ( * ), intent ( in ), optional :: advance , separator , style , zeroas , trim , orient logical ok ! character ( 22 ) ed character ( 9 ) sep , tsty , zas character ( 1 ) tch character ( 6 ) advchr integer lun , dmx , w , d , lsep , lzas , m1 , n1 , adv logical trm , number , vec , row , is_scalar , gedit ! vec = ( size ( shapex ) == 1 ) is_scalar = size ( shapex ) == 0 if ( vec . and . present ( orient )) then select case ( upper ( orient )) case ( 'ROW' ); row = . true . case ( 'COL' ); row = . false . case default ; ! do not use trim(3f), as using trim as an argument name call disp_errmsg ( 'DISP: error, wrong value of orient: ' // orient (: len_trim ( orient )) // ', using \"COL\"' ) row = . false . end select elseif ( vec ) then row = DEFSET % orient == 'ROW' else row = . false . endif if ( present ( fmt )) then call readfmt ( fmt , ed , w , d , gedit ) else ed = '()' w = - 1 ; d = 0 ; gedit = . false . endif if ( present ( unit )) then lun = unit else lun = DEFSET % unit endif if (. not . present ( digmax )) then dmx = DEFSET % digmax elseif ( present ( fmt )) then call disp_errmsg ( 'DISP: error, both FMT and DIGMAX present, ignoring DIGMAX' ) dmx = 1 elseif ( digmax < 1 . or . digmax > 89 ) then call disp_errmsg ( 'DISP: error, digmax must be >= 1 and < 90, using 6' ) dmx = 6 else dmx = digmax endif if ( present ( advance )) then advchr = upper ( advance ) else advchr = DEFSET % advance endif select case ( trims ( advchr )) case ( 'NO' ); adv = 0 case ( 'YES' ); adv = 1 case ( 'DOUBLE' ); adv = 2 case default call disp_errmsg ( 'DISP: error, illegal advance: ' // trims ( advance ) // ', using \"YES\"' ) adv = 1 end select if ( present ( trim )) then if ( upper ( trim ) /= 'YES' . and . upper ( trim ) /= 'NO' . and . upper ( trim ) /= 'AUTO' ) then call disp_errmsg ( 'DISP: error, illegal trim: ' // trims ( trim ) // ', using \"YES\"' ) trm = . true . else trm = upper ( trim ) == 'YES' . or . upper ( trim ) == 'AUTO' . and . . not . present ( FMT ) endif elseif ( w == 0 ) then trm = . true . else trm = DEFSET % trim == 'YES' . or . DEFSET % trim == 'AUTO' . and . . not . present ( FMT ) endif if ( present ( separator )) then sep = separator lsep = len ( separator ) else sep = DEFSET % sep lsep = DEFSET % seplen endif if ( present ( style )) then call getstyles ( style , tsty , tch , number , ok ) if (. not . ok ) call disp_errmsg ( 'DISP: error, illegal style: ' // style // '. Using default instead' ) else call getstyles ( DEFSET % style , tsty , tch , number , ok ) endif if ( title == '' ) tsty = 'LEFT' if ( is_scalar ) number = . false . if ( present ( zeroas )) then zas = zeroas lzas = len ( zeroas ) else zas = DEFSET % zeroas lzas = DEFSET % zaslen endif if ( w > 0 ) lzas = min ( w , lzas ) zas = zas ( 1 : lzas ) m1 = 1 n1 = 1 if ( present ( lbound )) then number = . true . if ( size ( lbound ) == 1 ) then if ( vec . and . row ) then n1 = lbound ( 1 ) else m1 = lbound ( 1 ) endif elseif ( size ( lbound ) >= 2 ) then m1 = lbound ( 1 ) n1 = lbound ( 2 ) endif endif SE = settings ( ed , sep , tsty , zas , tch , lun , dmx , w , d , lsep , lzas , m1 , n1 , adv , trm , number , vec , row , gedit ) contains function trims ( s ) result ( t ) character ( * ), intent ( in ) :: s character ( len_trim ( s )) :: t intrinsic trim t = trim ( s ) end function trims end subroutine get_SE !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine getstyles ( style , tsty , tch , number , ok ) ! Return tsty = 'LEFT', 'PAD', or 'UNDERLINE', tch = x from xPAD or xUNDERLINE, number = .true. if style includes ! NUMBER. If style has ABOVE, return tsty = 'PAD' and tch = ' '. Return tsty = 'LEFT' if error. See NOTE 1 below. character ( * ), intent ( in ) :: style character ( 9 ), intent ( out ) :: tsty character ( 1 ), intent ( out ) :: tch logical , intent ( out ) :: number , ok integer kamp , i , nsty character ( len ( style )) :: sty ( 2 ) character ( 9 ), parameter :: LPUA ( 4 ) = [ 'LEFT     ' , 'PAD      ' , 'UNDERLINE' , 'ABOVE    ' ] character ( 9 ), parameter :: PU ( 2 ) = [ 'PAD      ' , 'UNDERLINE' ] kamp = scan ( upper ( style ), '&' ) ok = . true . if ( kamp > 0 ) then sty ( 1 ) = adjustl ( upper ( style ( 1 : kamp - 1 ))) sty ( 2 ) = adjustl ( upper ( style ( kamp + 1 :))) nsty = 2 else sty ( 1 ) = adjustl ( upper ( style )) nsty = 1 endif number = . false . tsty = 'LEFT' tch = '-' do i = 1 , nsty if ( sty ( i ) == 'NUMBER' ) then number = . true . elseif ( sty ( i ) == 'ABOVE' ) then tsty = 'PAD' tch = ' ' elseif ( any ( sty ( i ) == LPUA )) then tsty = sty ( i ) elseif ( any ( sty ( i )( 2 :) == PU )) then tsty = sty ( i )( 2 :) tch = sty ( i )( 1 : 1 ) else ok = . false . return endif enddo ok = . true . end subroutine getstyles !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine replace_zeronaninf ( s , zas , maskz , masknan , maskminf , maskinf ) ! replace zeros in s (where maskz is true) with zas (i.e. zero-as string) also replace nans with 'NaN', ! infinities with '+Inf' and minus infinities with '-Inf'. Zeros are aligned with . if zas contains . ! otherwise right-adjusted. Nans, and infs are right adjusted. ! NOTE: There are compiler bugs in current versions of both the Absoft and the Pathscale compilers ! so the merge calls (commented out below) had to be replaced with do loops. character ( * ), intent ( inout ) :: s (:) logical , intent ( in ) :: maskz (:), masknan (:), maskinf (:), maskminf (:) character ( * ), intent ( in ) :: zas optional :: masknan , maskminf , maskinf character ( len ( s )) z , nan , minf , inf integer w , wz , n , i , k , zasdot w = len ( s ) wz = len ( zas ) n = size ( maskz ) if ( wz /= 0 . and . wz <= w ) then ! zas not empty and not too wide zasdot = index ( zas , '.' ) z = '' if ( zasdot > 0 ) then do i = 1 , n if ( maskz ( i )) exit enddo if ( i <= n ) then ! some zeros k = index ( s ( i ), '.' ) if ( k == 0 . or . zasdot > k . or . wz - zasdot > w - k ) then ! cannot align .'s z ( w - wz + 1 :) = zas ! align right else z ( k - zasdot + 1 : k - zasdot + wz ) = zas endif endif else z ( w - wz + 1 :) = zas endif ! s = merge(z, s, maskz) do i = 1 , n if ( maskz ( i )) s ( i ) = z enddo endif if ( present ( masknan )) then if ( w >= 4 ) then nan = repeat ( ' ' , w - 4 ) // ' NaN' minf = repeat ( ' ' , w - 4 ) // '-Inf' inf = repeat ( ' ' , w - 4 ) // '+Inf' elseif ( w == 3 ) then nan = 'NaN' minf = '***' inf = 'Inf' else nan = repeat ( '*' , w ) minf = nan inf = nan endif ! s = merge(nan, s, masknan) ! s = merge(minf, s, maskminf) ! s = merge(inf, s, maskinf) do i = 1 , n if ( masknan ( i )) s ( i ) = nan if ( maskminf ( i )) s ( i ) = minf if ( maskinf ( i )) s ( i ) = inf enddo endif end subroutine replace_zeronaninf !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure function upper ( s ) result ( su ) ! Change string to upper case character ( * ), intent ( in ) :: s character ( len ( s )) su character ( 26 ), parameter :: ll = 'abcdefghijklmnopqrstuvwxyz' , ul = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' integer i , k su = s do i = 1 , len ( s ) k = index ( ll , s ( i : i )) if ( k > 0 ) su ( i : i ) = ul ( k : k ) enddo end function upper !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine sszipfmt ( fmt , fmt1 ) ! Set fmt1 to '(SS,'//removeblanks(fmt)//')'. Caller is responsible that ! fmt1 has sufficient length. character ( * ), intent ( in ) :: fmt character ( * ), intent ( out ) :: fmt1 integer i , j fmt1 = '(SS,' j = 5 do i = 1 , len ( fmt ) if ( fmt ( i : i ) /= ' ' ) then fmt1 ( j : j ) = fmt ( i : i ) j = j + 1 endif enddo fmt1 ( j : j ) = ')' end subroutine sszipfmt !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure function nnblk ( s ) result ( n ) ! count nonblanks in s character ( * ), intent ( in ) :: s integer i , n n = 0 do i = 1 , len ( s ) if ( s ( i : i ) /= ' ' ) n = n + 1 enddo end function nnblk !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine disp_errmsg ( s ) character ( * ), intent ( in ) :: s integer wleft character ( 1 ), pointer :: boxp (:,:) wleft = 0 call newbox ( DEFAULT_UNIT , 1 , len ( s ), boxp ) call copytobox ([ s ], lin1 = 1 , widj = len ( s ), widpj = len ( s ), nblj = 0 , boxp = boxp , wleft = wleft ) call dispboxlist ( DEFAULT_UNIT , sep = '' ) end subroutine disp_errmsg !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! **************************************************** END OF GENERAL PROCEDURES ************************************************** !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! ****************************************************** TOSTRING PROCEDURES ****************************************************** !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine tostring_check_settings ! Sanity check of tostring settings type ( tostring_settings ) ts integer wi , wr , d character ( max ( len ( tosset % rfmt ), len ( tosset % ifmt )) + 5 ) fmt1 logical gedit ts = tosset if ( all ( ts % trimb /= [ 'YES' , 'NO ' ])) tosset % trimb = tosfac % trimb if ( all ( ts % trimz /= [ 'NONE' , 'ALL ' , 'G   ' ])) tosset % trimz = tosfac % trimz call readfmt ( tosset % rfmt , fmt1 , wr , d , gedit ) call readfmt ( tosset % ifmt , fmt1 , wi , d , gedit ) if ( wr < 0 ) tosset % rfmt = tosfac % rfmt if ( wi < 0 ) tosset % ifmt = tosfac % ifmt if ( all ( ts % trimb /= [ 'YES ' , 'NO  ' , 'AUTO' ])) call disp_errmsg ( & 'TOSTRING_SET: error, illegal trimb: ' // trim ( ts % trimb ) // ', set to ' // trim ( tosfac % trimb )) if ( all ( ts % trimz /= [ 'NONE' , 'ALL ' , 'G   ' ])) call disp_errmsg ( & 'TOSTRING_SET: error, illegal trimz: ' // trim ( ts % trimz ) // ', set to ' // trim ( tosfac % trimz )) if ( wr < 0 ) call disp_errmsg ( & 'TOSTRING_SET: error, illegal rfmt: ' // trim ( ts % rfmt ) // ', set to ' // trim ( tosfac % rfmt )) if ( wi < 0 ) call disp_errmsg ( & 'TOSTRING_SET: error, illegal ifmt: ' // trim ( ts % ifmt ) // ', set to ' // trim ( tosfac % ifmt )) end subroutine tostring_check_settings !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine trim_s_real ( sa , gedit , w ) ! Trim trailing zeros and possibly decimal point from fractional part. ! If sa = '52.2000E12' on entry then it is returned as '52.2E12   '. ! Whether trimming is actually done depends on tosset, gedit and w. character ( * ), intent ( inout ) :: sa logical , intent ( in ) :: gedit integer , intent ( in ) :: w integer k , k2 , k3 if ( tosset % trimb == 'YES' . or . w == 0 ) sa = adjustl ( sa ) if ( tosset % trimz == 'ALL' . or . tosset % trimz == 'G' . and . gedit ) then k = scan ( sa , '.' ) if ( k > 0 ) then k2 = verify ( sa ( k + 1 :), '0123456789' ) + k if ( k2 == k ) k2 = len ( sa ) + 1 k3 = verify ( sa ( k : k2 - 1 ), '0.' , back = . true .) + k - 1 sa ( k3 + 1 :) = sa ( k2 :) endif endif end subroutine trim_s_real !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine trim_real ( sa , gedit , w ) ! Trim trailing zeros and possibly decimal point from fractional part. ! If sa = '52.2000E12' on entry then it is returned as '52.2E12   '. ! Whether trimming is actually done depends on tosset, gedit and w. character ( * ), intent ( inout ) :: sa (:) logical , intent ( in ) :: gedit integer , intent ( in ) :: w integer i if ( tosset % trimb == 'YES' . or . w == 0 ) sa = adjustl ( sa ) if ( tosset % trimz == 'ALL' . or . tosset % trimz == 'G' . and . gedit ) then do i = 1 , size ( sa ) ! trim trailing zeros from fractional part call trim_s_real ( sa ( i ), gedit , w ) enddo endif end subroutine trim_real !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine tostring_get ( sa , st ) ! Copy trimmed elements of sa (containing individual elements as strings) to the final ! tostring result st, separated by tosset % sep strings. character ( * ), intent ( in ) :: sa (:) character ( * ), intent ( out ) :: st integer :: i , k , n , sepl sepl = tosset % seplen k = 0 do i = 1 , size ( sa ) if ( k > 0 ) st ( k + 1 : k + sepl ) = tosset % sep ( 1 : sepl ) if ( k > 0 ) k = k + sepl n = len_trim ( sa ( i )) st ( k + 1 : k + n ) = trim ( sa ( i )) k = k + n enddo end subroutine tostring_get !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine tostring_get_complex ( sar , sgn , sai , st ) ! Version of tostring_get for complex numbers character ( * ), intent ( in ) :: sar (:), sai (:), sgn ( * ) character ( * ), intent ( out ) :: st integer :: i , k , n , sepl sepl = tosset % seplen k = 0 do i = 1 , size ( sar ) if ( k > 0 ) st ( k + 1 : k + sepl ) = tosset % sep ( 1 : sepl ) if ( k > 0 ) k = k + sepl n = len_trim ( sar ( i )) st ( k + 1 : k + n ) = trim ( sar ( i )) st ( k + n + 1 : k + n + 3 ) = ' ' // sgn ( i ) // ' ' k = k + n + 3 n = len_trim ( sai ( i )) st ( k + 1 : k + n ) = trim ( sai ( i )) st ( k + n + 1 : k + n + 1 ) = 'i' k = k + n + 1 enddo end subroutine tostring_get_complex !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! ********************************* END OF TOSTRING PROCEDURES ********************************* ! *********************************** BOX-PACKAGE ********************************************** ! ! A \"box\" is a variable dimension character matrix that can be created dynamically. There are ! linked lists of boxes, one for each logical unit. When disp is called the item to be displayed ! is written to a box. If advance = 'no' is in effect, the writing out of the items is delayed ! until disp is called on the same unit with advance = 'yes' in effect; then all the boxes in ! the relevant list are written to the unit. There are two subroutines that are meant to be ! called from outside the Box-package: NEWBOX and DISPBOXLIST: ! ! CALL NEWBOX(UNIT, M, N, BOXP) creates a box on unit UNIT. BOXP returns a pointer to the ! created box which is of type CHARACTER and DIMENSION (M,N). ! ! CALL DISPBOXLIST(UNIT, SEP) writes all the boxes in the list associated with UNIT to the file ! on UNIT, separated with the string SEP. The following example makes this clear: let SEP = ' : ' ! and let the first box contain XXX and the second have two rows, both equal to YYYY. Then the ! text written will be: XXX : YYYY : YYYY ! ! To obtain tab-separated boxes when using ASCII, let SEP = char(9). After writing the boxes, ! the complete list is deallocated. If UNIT = -3 the asterisk unit (usually command window) is ! written to. If UNIT = -2 the routine putstr from the disp_where unit is used for writing. If ! UNIT = -1 all output will be discarded. With the iso_fortran_env module of Fortran 2003, unit ! may also equal OUTPUT_UNIT, unless the compiler sets that to -2. !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function getboxlist ( unit ) result ( p ) ! Return boxlist associated with specified unit. If this list does not exist a new list is started. integer , intent ( in ) :: unit type ( boxlist ), pointer :: p p => firstboxlist do while ( associated ( p )) if ( p % unit == unit ) return p => p % nextboxlist enddo allocate ( p ) p % nextboxlist => firstboxlist ! put at head of list p % unit = unit firstboxlist => p end function getboxlist !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine clearboxlist ( unit ) ! Deallocate all boxes associated with unit integer , intent ( in ) :: unit type ( boxnode ), pointer :: p , q type ( boxlist ), pointer :: blp blp => firstboxlist do while ( associated ( blp )) if ( blp % unit == unit ) exit blp => blp % nextboxlist enddo if (. not . associated ( blp )) return p => blp % firstbox do while ( associated ( p )) q => p p => p % nextbox deallocate ( q % box ) deallocate ( q ) enddo if ( associated ( firstboxlist , blp )) then firstboxlist => blp % nextboxlist endif deallocate ( blp ) end subroutine clearboxlist !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine newbox ( unit , m , n , boxp ) ! Create a new box character , pointer :: boxp (:,:) integer , intent ( in ) :: unit , m , n type ( boxnode ), pointer :: p type ( boxlist ), pointer :: blp allocate ( p ) allocate ( p % box ( n , m )) blp => getboxlist ( unit ) if (. not . associated ( blp % firstbox )) then blp % firstbox => p else blp % lastbox % nextbox => p endif blp % lastbox => p boxp => p % box boxp = ' ' end subroutine newbox !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function tostr ( a ) result ( s ) ! Copy char array to string character , intent ( in ) :: a (:) character ( size ( a )) s integer i do i = 1 , size ( a ) s ( i : i ) = a ( i ) enddo end function tostr !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine dispboxlist ( unit , sep ) ! Display the list of boxes associated with unit integer , intent ( in ) :: unit type ( boxnode ), pointer :: pfirst , p type ( boxlist ), pointer :: blp integer k , nlines , h , w , ns character ( * ), intent ( in ) :: sep blp => getboxlist ( unit ) pfirst => blp % firstbox nlines = 0 p => pfirst do while ( associated ( p )) nlines = max ( nlines , size ( p % box , 2 )) p => p % nextbox enddo do k = 1 , nlines p => pfirst ns = 0 do while ( associated ( p )) h = size ( p % box , 2 ) w = size ( p % box , 1 ) if ( k <= h ) then select case ( unit ) case ( - 1 ) continue case ( - 2 ) call putstr ( sep ( 1 : ns ) // tostr ( p % box (:, k ))) case ( - 3 ) write ( * , '(2A)' , advance = 'no' ) sep ( 1 : ns ), tostr ( p % box (:, k )) case default write ( unit , '(2A)' , advance = 'no' ) sep ( 1 : ns ), tostr ( p % box (:, k )) end select else select case ( unit ) case ( - 1 ) continue case ( - 2 ) call putstr ( sep ( 1 : ns ) // repeat ( ' ' , w )) case ( - 3 ) write ( * , '(2A)' , advance = 'no' ) sep ( 1 : ns ), repeat ( ' ' , w ) case default write ( unit , '(2A)' , advance = 'no' ) sep ( 1 : ns ), repeat ( ' ' , w ) end select endif p => p % nextbox ns = len ( sep ) enddo call dispnewline ( unit ) enddo call clearboxlist ( unit ) end subroutine dispboxlist !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine dispnewline ( unit ) integer , intent ( in ) :: unit select case ( unit ) case ( - 1 ); continue case ( - 2 ); call putnl case ( - 3 ); write ( * , * ) case default ; write ( unit , * ) end select end subroutine dispnewline !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !   subroutine print_boxes !     ! Print info on all boxes (used for debug purposes) !     integer :: k !     type(boxlist), pointer :: bl !     type(boxnode), pointer :: p !     bl => firstboxlist !     write(*,'(\"BOXES:\")') !     do while (associated(bl)) !       write(*,'(\"UNIT=\",SS,I0,\":\")') bl % unit !       p => bl % firstbox !       k = 1 !       do while(associated(p)) !         write(*,'(\"  box \",SS,I0,\", size=(\",I0,\",\",I0,\")\")') k, shape(p % box) !         k = k+1 !         p => p % nextbox !       enddo !       bl => bl % nextboxlist !     enddo !   end subroutine print_boxes !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! ******************************** END OF BOX-PACKAGE ******************************* END MODULE M_display__UTIL !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== MODULE M_display use M_display__util implicit none private ! everything not explicitly declared public will be private (including entities from M_display__util) ! ********************************** PUBLIC DECLARATIONS ************************************* PUBLIC DISP ! Main routine of package, \"pretty-prints\" vectors and matrices PUBLIC DISP_SET ! Subroutine to change default settings for DISP PUBLIC DISP_GET ! Obtain current default settings PUBLIC DISP_SET_FACTORY ! Call (without parameters) to restore original default settings PUBLIC TOSTRING ! Convert numbers to strings PUBLIC TOSTRING_SET ! Change settings for tostring PUBLIC TOSTRING_SET_FACTORY ! Restore original default settings for tostring ! PUBLIC DISP_SETTINGS ! Derived type with settings ! PUBLIC ASTERISK_UNIT ! Constant to specify displaying on asterisk unit (normally the screen) PUBLIC PUTSTR_UNIT ! Constant to specify the use of subroutines putstr and putnl to display PUBLIC NULL_UNIT ! Constant to specify discarding of all displayed output ! ********************************** INTERFACE DECLARATIONS ************************************* interface disp_set module procedure disp_set , disp_set_ds end interface !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!       disp(3f) - [M_display] pretty-print a matrix !! !!##DESCRIPTION !! !! This is the principal subroutine of the package. It has various control !! arguments that specify the exact format of the output. Most of these !! may also be used as arguments of the subroutine DISP_SET. When used !! with DISP, a control argument affects only the item being displayed with !! the current call, but when used with DISP_SET, the default settings for !! subsequent DISP calls are affected. The default values for individual !! arguments given below are used unless they have been changed by a call !! to DISP_SET. All character arguments should be of type default character. !! !! Simple Calls: !! !!       call disp !!       call disp(x) !!       call disp(title, x) !!       call disp(x, fmt) !!       call disp(title, x, fmt) !! !! The first call advances to the next line, and the other calls display X !! on the default unit (the unit may be changed with the UNIT argument). The !! default putstrmodule (see section 2) sets the asterisk unit (usually the !! screen) to be default. The purpose of individual arguments is as follows: !! !! X      The item to be displayed. X may be scalar, vector or matrix !!        (i.e. of rank <= 2) and the following kinds of data are supported: !! !!           default integer !!           default real (or single precision, real(kind(1.0))) !!           double precision real (or real(kind(1d0))) !!           default complex (or complex(kind(1.0))) !!           double precision complex (or complex(kind(1d0))) !!           default logical !!           default character !! !!        With the add-on modules described in section 2.3 other kinds may !!        be displayed. Matrices are displayed in traditional mathematical !!        order, so the rows displayed are X(1,:), X(2,:) etc. Vectors are !!        by default displayed as column vectors (but a row orientation may !!        be specified with the ORIENT argument). An SS edit descriptor is !!        applied automatically so positive elements are not prefixed with !!        a + sign (the Fortran standard makes outputting a + sign optional). !! !! TITLE  Provides a label for X. The label prefixes X by default but this !!        may be changed with the STYLE argument (see examples in section !!        3.2). When X is absent TITLE must also be absent. !! !! FMT    When present, FMT should contain an edit descriptor that will be !!        used to format each element of X (or the real parts of X in case !!        X is complex and FMT_IMAG is present; see below). The possible !!        edit descriptors are: !! !!           Fw.d, Dw.d, Ew.dEe, ENw.dEe, ESw.dEe: real data (the Ee suffixes are optional) !!           Iw, Bw, Ow, Zw: integer data (all may be suffixed with .m) !!           Lw: logical data !!           A, Aw: character data !!           Gw.d, Gw.dEe: any data !! !!        Example calls for numeric X are CALL DISP(X,'ES11.4') and CALL !!        DISP('X=',X,'F8.4'). If X is a scalar string (i.e. of rank 0) and !!        TITLE is absent FMT must be specified with a keyword (otherwise !!        the call is taken to have TITLE and X): CALL DISP('str',FMT='A4') !!        displays \"str\" but CALL DISP('str','A4') displays \"strA4\"). !! !!        If FMT is absent, each element of X is formatted with a default !!        edit descriptor. When X is of type logical the default is L1 and !!        when it is of type character the default is A (which is equivalent !!        to Aw where w = LEN(X)). For integer data the default is Iw where !!        w is exactly big enough to accommodate both the largest positive !!        and the largest negative values in X. For real and complex data !!        the default also depends on the largest absolute values in X, !!        as detailed in the DIGMAX-paragraph in section 3.2. The format !!        used for complex numbers is demonstrated in the introduction above. !! !!##CALL WITH COMPLETE LIST OF ARGUMENTS !! !!       CALL DISP(TITLE, X, FMT, FMT_IMAG, ADVANCE, DIGMAX, LBOUND, ORIENT, !!       SEP, STYLE, TRIM, UNIT, ZEROAS) !! !! All dummy arguments are optional and some of them are incompatible !! with some data types of X. The arguments control how X is displayed, !! as described in section 3.1 and below. For the character arguments !! ADVANCE and ORIENT the case of letters is ignored (so e.g. ADVANCE = !! 'yes' and ADVANCE = 'YES' are equivalent). Normally argument association !! for arguments after FMT (or FMT_IMAG) will be realized with argument !! keywords, e.g. CALL DISP('X=', X, DIGMAX=3, ORIENT='ROW'). When X is a !! scalar string FMT must also be associated with keyword, as mentioned in !! section 3.1. The most useful application of calling DISP with X absent is !! to advance to the next line or display an empty line. For this purpose, !! the only relevant arguments are UNIT, and ADVANCE with the value 'YES' !! or 'DOUBLE'. !! !! FMT_IMAG = edit-descriptor-imag  An edit descriptor for imaginary parts !!        of complex X. The statement CALL DISP((1.31,2.47),'F0.1','F0.2') !!        will display \"1.3 + 2.47i\". If FMT_IMAG is absent and FMT !!        is present then both real and imaginary parts are edited with !!        FMT. If both are absent, separate defaults are used, as explained !!        in the DIGMAX-paragraph below. FMT_IMAG must be absent if X is !!        not complex. !! !! ADVANCE = adv  The value for ADVANCE may be 'yes', 'no' or 'double'. If !!       the value is 'yes' then X is written out immediately, if it is !!       'double' then X is written out followed by an empty line (thus !!       giving double spacing), and if it is 'no' then X is not written !!       out until the next DISP call on the same unit with advancing turned !!       on (either by default, via a call to DISP_SET, or via the ADVANCE !!       keyword). When this occurs, all the items displayed with DISP since !!       the last output occurred on the unit are written out side by side, !!       separated by three spaces unless a different separation has been !!       specified via the MATSEP argument of DISP_SET. Default value of !!       ADVANCE is 'yes'. !! !! DIGMAX = n  Controls the format used for real and complex data in the !!       absence of FMT. For real items the format is chosen so that the !!       displayed number of largest absolute magnitude (say xmax) has n !!       significant decimal digits. If 0.1 <= |xmax| < 10**n an F edit !!       descriptor is used, otherwise an E edit descriptor. For complex !!       items these rules are applied separately to the real parts and !!       imaginary parts, and thus two different formats are used. When X !!       is not of real or complex type the argument DIGMAX is ignored. When !!       DIGMAX is present FMT should be absent. The default is n = 6. !! !! LBOUND = lbound  This argument is a default integer vector with the !!       numbers of the first row / column to show when displaying with !!       numbered style. When calling subroutines in Fortran, only the !!       shape of matrix arguments is passed with the arguments, but matrix !!       lower bounds are assumed to be 1 unless declared explicitly in !!       the routine. To compensate for this deficiency LBOUND may be !!       set to the declared lower bound(s) of X. To take an example, let !!       aij = exp(i + j - 1) as in section 1, but let A be declared with !!       REAL::A(0:3,0:3). Then CALL DISP(A, STYLE = 'NUMBER', LBOUND = !!       LBOUND(A)) will display: !! !!         >        0       1        2        3 !!         >  0   1.000   2.718    7.389   20.086 !!         >  1   2.718   7.389   20.086   54.598 !!         >  2   7.389  20.086   54.598  148.413 !!         >  3  20.086  54.598  148.413  403.429. !! !!       In fact the call may be shortened to CALL DISP(A, LBOUND = !!       LBOUND(A)) because numbering is default when LBOUND is present. !! !! ORIENT = ori  This argument can only be used when X is a vector (i.e. has !!       rank 1). If ORIENT is 'col' (the default) a column vector is !!       displayed, and if ORIENT is 'row' a row vector results. !! !! SEP = sep  Specifies a string which is written out between columns of !!       displayed matrices. If X has rows (-1, 3) and (5, 10) and SEP is ', !!       ' then the output will be: !! !!         >  -1,  5 !!         >   5, 10 !! !!       The length of the string must be at most 9. Default is '  ' !!       (character string with two spaces). !! !! STYLE = style  There are five possible styles: !! !!       'left'       Title is immediately to the left of the first line !!                    of the displayed item. !!       'above'      Title is centered immediately above the item. !!       'pad'        Title is centered above the item, padded with hyphens (-). !!       'underline'  Title is centered above the item, underlined with hyphens. !!       'number'     Each matrix or vector row and / or column is numbered. !! !!       Any of the four title position styles can also be combined with the !!       number style by specifying for example STYLE = 'pad & number'. Any !!       character except space may be used instead of hyphen by prefixing !!       it to the style. STYLE = '*underline' will thus underline the title !!       with asterisks. Both row and column numbers appear for numbered !!       matrices, but for vectors only row numbers appear (or column numbers !!       when ORIENT is 'col'). The five styles are illustrated below, !!       accompanied by an example of combined padded title and numbering. !! !!         > Matr = 1.2   4.2       Matr      ---Matr--       Matr          1     2     ____Matr____ !!         >        5.6  18.3    1.2   4.2    1.2   4.2    ---------    1  1.2   4.2        1     2 !!         >                     5.6  18.3    5.6  18.3    1.2   4.2    2  5.6  18.3    1  1.2   4.2 !!         >                                               5.6  18.3                    2  5.6  18.3 !! !!       The default value of STYLE is 'left' if LBOUND is absent, 'number' !!       if it is present, and 'left & number' if both TITLE and LBOUND !!       are present. !! !! TRIM = trim  This argument can take three values, 'YES', 'NO' and !!       'AUTO'. When YES is specified, each column of displayed items is !!       trimmed from the left, with 'NO' the items are not trimmed and if !!       TRIM is 'AUTO' the items are trimmed when FMT is absent but not when !!       it is present. In the following example, X and U are displayed !!       with TRIM = 'yes', but Y and V with TRIM = 'no'. In all cases the !!       edit descriptor is the default (I4). The default is TRIM = 'AUTO'. !! !!         > ----X----   -------Y------   -----U-----   -------V------ !!         > 1  2    4      1    2    3   333 22 4444    333   22 4444 !!         > 2 22   34      2   22   34 !!         > 3 32 1234      3   32 1234 !! !!       One application of trimming is to display matrices with a fixed !!       number of fractional digits but variable effective field width. Then !!       Fw.d editing with w big enough is accompanied by TRIM = 'yes'. An !!       example is the following display of a matrix with (i, k) element !!       exp(k**i) using F20.2 and 'yes': !! !!         >  power exponentials !!         > 2.72   7.39    20.09 !!         > 2.72  54.60  8103.08 !! !!       Similar output may be obtained using I and F edit descriptors !!       with w = 0 as discussed in section 3.5. Apart from I and F edited !!       displays, it is possible to trim A-edited displays as well as !!       E-edited displays with some negative elements, but the first column !!       all positive: !! !!           With TRIM='yes':X=1.2e+5 -4.1e-2   With TRIM='no':X= 1.2e+5 -4.1e-2 !!                             2.3e-3  8.6e+1                     2.3e-3  8.6e+1 !! !! UNIT = external-file-unit  The unit which the output is sent to. There !!       are three special units, which may be referred to either with !!       constants or parameters (named constants) as follows: !! !!           Constant  Parameter      Preconnected unit !!             -3      ASTERISK_UNIT  The asterisk unit (often the screen) !!             -2      PUTSTR_UNIT    The subroutines PUTSTR and PUTNL !!             -1      NULL_UNIT      Null device (all output to this is discarded) !! !!       These units are further described in sections 3.3 and 3.4. Other !!       unit numbers correspond to external files that should have been !!       connected with open-statements. The default unit depends on the !!       named constant DEFAULT_UNIT, defined in PUTSTRMODULE. The default !!       PUTSTRMODULE sets it to -3 (see sections 2 and 3.4). !! !! ZEROAS = zerostring  Supported for integer and real X (not complex) !!       Any element that compares equal to 0 will be displayed as !!       zerostring. If, for example, A is a 4 by 4 upper triangular !!       matrix with aij = 1/max(0,j - i + 1) then CALL DISP('A = ', A, !!       'F0.3', ZEROAS = '0', ADVANCE = 'NO') and CALL DISP('B = ', A, !!       'F0.3', ZEROAS = '.') will display: !! !!           A = 1.000  0.500  0.333  0.250   B = 1.000  0.500  0.333  0.250 !!                   0  1.000  0.500  0.333        .     1.000  0.500  0.333 !!                   0      0  1.000  0.500        .      .     1.000  0.500 !!                   0      0      0  1.000        .      .      .     1.000 !! !!       Notice that when zerostring contains a decimal point it is lined !!       up with other decimal points in the column. If zerostring has !!       length 0, the default behavior of not treating zeros specially is !!       re-established, in case an earlier DISP_SET call has been used to !!       set ZEROAS. !! !! !!##ASTERISK_UNIT AND NULL_UNIT !! !! As already mentioned in section 3.2 there are three special units, !! ASTERISK_UNIT = -3, PUTSTR_UNIT = -2 and NULL_UNIT = -1. These public !! named constants (parameters) are defined by M_display. !! !! Selecting ASTERISK_UNIT channels all output to the unit that !! WRITE(*,...) statements use. The ISO_FORTRAN_ENV intrinsic module of !! Fortran 2003 defines the named constant OUTPUT_UNIT and this may be !! used instead, unless its value is set to -2 by the compiler (which would !! clash with PUTSTR_UNIT). !! !! Selecting NULL_UNIT causes all output via DISP to be discarded. This !! feature makes it simple to turn the output on and off, which may be !! useful for debugging and testing purposes. If UNIT = U is specified !! in all DISP-calls, it is enough to change the value of U to -1 to turn !! off output. !! !! !! PUTSTR_UNIT: Output with user written subroutines !! !! One of the purposes of the PUTSTR_UNIT is to make displaying possible in !! situations where ordinary print- and write-statements do not work. This !! is for example the case in Matlab mex-files (in fact the execution !! of a write statement on the asterisk unit crashes Matlab). To use the !! PUTSTR_UNIT it is necessary to write two subroutines with interfaces: !! !!       SUBROUTINE PUTSTR(S) !!       CHARACTER(*), INTENT(IN) :: S !! !!       SUBROUTINE PUTNL() !! !! The first of these should output the string S, and the second one should !! advance output to the next line. These subroutines should be placed !! in a module PUTSTRMODULE as explained in section 2. The module should !! also define a named constant DEFAULT_UNIT, which could be set to -2 to !! make the PUTSTR_UNIT default. An example that works with g95 and Matlab !! mex-files is: !! !!       module M_display__putstrmodule !!         integer, parameter :: default_unit = -2 !! !!       contains !!         subroutine putstr(s) !!           character(*), intent(in) :: s !!           call mexprintf(s//char(0)) !!         end subroutine putstr !! !!         subroutine putnl() !!           call mexprintf(char(10)//char(0)) !!         end subroutine putnl !! !!       end module M_display__putstrmodule !! !! At the beginning of the file M_display.f90 there is a slightly longer !! version which works with both g95 and gfortran. Testing this module is !! discussed in section 6.2 below. !! !!##USING W=0 EDITING !! !! The Fortran standard stipulates that writing a single element with !! I0 editing results in the smallest field width that accommodates the !! value, and the same applies to B0, O0, Z0 and F0.d editing. With DISP, !! the width of a displayed column will be the width of the widest field !! in the column, and each element is right-adjusted in the column. This !! gives exactly the same output as using TRIM='yes' and a specified field !! width bigger than the largest occurring. Note that with F0.d editing, !! there is no limit on the width of a column, but with Fw.d and TRIM='yes' !! any element wider than w will be displayed as w asterisks: !! !!       ------------------F0.2------------------    -----F13.2, TRIM='yes'---- !!       14.28  142857142857142857142857.14  0.47    14.28  *************  0.47 !!        1.42                1414213562.37  0.69     1.42  1414213562.37  0.69 !! !! !!##NOT-A-NUMBER AND INFINITE VALUES !! !! If the compiler supports not-a-number and infinite values as defined by !! the IEEE exceptional values of Fortran 2003, these are displayed as NaN, !! +Inf or Inf. A not-a-number value X is identified as being not equal to !! itself, and an infinite value is either greater than HUGE(X) or smaller !! than -HUGE(X). On all the compilers tried the sequence BIG=1E20; CALL !! DISP(EXP(BIG)) displays +Inf, and the program segment: !! !!     > real :: z = 0, big = 1e20 !!     > call disp([z, z/z, big, -exp(big)]) !! !! displays !!     >  0.00000E+00 !!     >          NaN !!     >  1.00000E+20 !!     >         -Inf !! !!##AUTHOR !!   Based on dispmodule(3f), !!   \"A Fortran 95 module for pretty-printing matrices\". !!   Version number 1.02 6-Sept-2008, !!   Kristjan Jonasson, !!   Dept. of Computer Science, !!   University of Iceland (jonasson@hi.is). interface disp module procedure disp_scalar_int , disp_title_scalar_int , & disp_vector_int , disp_title_vector_int , & disp_matrix_int , disp_title_matrix_int module procedure disp_s_sngl , disp_ts_sngl , disp_v_sngl , disp_tv_sngl , disp_m_sngl , disp_tm_sngl module procedure disp_s_dble , disp_ts_dble , disp_v_dble , disp_tv_dble , disp_m_dble , disp_tm_dble module procedure disp_s_cplx , disp_ts_cplx , disp_v_cplx , disp_tv_cplx , disp_m_cplx , disp_tm_cplx module procedure disp_s_cpld , disp_ts_cpld , disp_v_cpld , disp_tv_cpld , disp_m_cpld , disp_tm_cpld module procedure disp_s_dlog , disp_ts_dlog , disp_v_dlog , disp_tv_dlog , disp_m_dlog , disp_tm_dlog module procedure disp_ts_dchr , disp_v_dchr , disp_tv_dchr , disp_m_dchr , disp_tm_dchr end interface interface tostring module procedure tostring_dint , tostring_f_dint , tostring_s_dint , tostring_sf_dint module procedure tostring_dlog , tostring_f_dlog , tostring_s_dlog , tostring_sf_dlog module procedure tostring_sngl , tostring_f_sngl , tostring_s_sngl , tostring_sf_sngl module procedure tostring_dble , tostring_f_dble , tostring_s_dble , tostring_sf_dble module procedure tostring_cplx , tostring_f_cplx , tostring_s_cplx , tostring_sf_cplx module procedure tostring_cpld , tostring_f_cpld , tostring_s_cpld , tostring_sf_cpld end interface ! *********************** DEFINITION OF TYPED CONSTANTS: UNITS AND KIND PARAMETERS ******************** integer , parameter :: & ASTERISK_UNIT = - 3 ,& PUTSTR_UNIT = - 2 ,& NULL_UNIT = - 1 integer , parameter :: dint = kind ( 0 ) ! default integer integer , parameter :: sngl = kind ( 0.0 ) ! single precision (default real) integer , parameter :: dble = kind ( 0 d0 ) ! double precision integer , parameter :: dlog = kind (. false .) ! default logical ! The above are also used as specific procedure (i.e. module procedure) name extensions, together ! with the following: !        cplx = complex single precision (default complex) !        cpld = complex double precision CONTAINS ! ******************************* SETTING AND GETTING PROCEDURES ************************************* !> !!##NAME !!       disp_set(3f) - [M_display] set default options for disp(3f) !! !!##DESCRIPTION !! !! The subroutine DISP_SET may be used to change default values of all !! the arguments of DISP except TITLE, X, FMT and LBOUND. In addition the !! default separator between items that are displayed side-by-side (using !! ADVANCE='no') may be changed with the MATSEP argument. !! !!##THE DERIVED TYPE DISP_SETTINGS !! !! M_display contains the following definition of the data type !!##DISP_SETTINGS. !! !!       type disp_settings !!         character(3)  :: advance   = 'YES' !!         character(9)  :: matsep    = '   ' !!         character(3)  :: orient    = 'COL' !!         character(9)  :: sep       = '  ' !!         character(19) :: style     = 'LEFT' !!         character(4)  :: trim      = 'AUTO' !!         character(9)  :: zeroas    = '' !!         integer       :: digmax    = 6 !!         integer       :: matseplen = 3 !!         integer       :: seplen    = 2 !!         integer       :: unit      = -3 !!         integer       :: zaslen    = 0 !!       end type disp_settings !! !! Structures of type DISP_SETTINGS may be used to save and later restore !! format control settings of DISP. As shown, new variables of this type !! will automatically have default values for all components. !! !! !!##CALLING SYNTAX FOR DISP_SET !! !! There are two ways to call DISP_SET: !! !!       call disp_set(settings) !!       call disp_set(advance, digmax, matsep, orient, sep, style, unit, zeroas) !! !! Both calls change the default format control used in subsequent calls !! to DISP. In the first call, SETTINGS is of type DISP_SETTINGS and the !! default values for all arguments is changed. In the second call all !! the arguments are optional. If an argument is absent the corresponding !! default setting is not changed. An example call is !! !!       call disp_set(style = 'pad', sep = ' '). !! !! The effect is that titles will be written padded above matrices, and !! matrix column will be separated by one blank. The type and purpose of !! all the arguments except MATSEP has been described in section 3.2. !! !! MATSEP = ms  Specifies a character string of length <= 9 that is written !!              out between items (matrices) when they are displayed !!              side-by-side. An example is: !! !!                   call disp(x, advance='no') !!                   call disp(y, advance='no') !!                   call disp_set(matsep=' | ') !!                   call disp(z, advance='yes') !! !!              The output from these calls might be: !! !!                   12.2 |  1.3 | 1 !!                    9.6 | 13.0 | 3 !!                   -2.0 |  4.0 | 4 !! !!              Note that MATSEP affects the separation of all items that !!              have been placed in the output queue of the unit being !!              displayed on. !!##AUTHOR !!   Based on dispmodule(3f), !!   \"A Fortran 95 module for pretty-printing matrices\". !!   Version number 1.02 6-Sept-2008, !!   Kristjan Jonasson, Dept. of Computer Science, !!   University of Iceland (jonasson@hi.is). subroutine disp_set ( advance , digmax , matsep , orient , sep , style , unit , zeroas ) ! Change display settings according to individual parameters character ( * ), optional , intent ( in ) :: advance , sep , matsep , orient , style , zeroas integer , optional , intent ( in ) :: digmax , unit if ( present ( advance )) DEFSET % advance = upper ( advance ) if ( present ( sep )) DEFSET % sep = sep if ( present ( sep )) DEFSET % seplen = min ( 9 , len ( sep )) if ( present ( zeroas )) DEFSET % zeroas = zeroas if ( present ( zeroas )) DEFSET % zaslen = min ( 9 , len ( zeroas )) if ( present ( matsep )) DEFSET % matsep = matsep if ( present ( matsep )) DEFSET % matseplen = min ( 9 , len ( matsep )) if ( present ( orient )) DEFSET % orient = upper ( orient ) if ( present ( style )) DEFSET % style = style if ( present ( digmax )) DEFSET % digmax = digmax if ( present ( unit )) DEFSET % unit = unit call check_settings end subroutine disp_set !> !!##NAME !!    disp_set_factory(3f) - [M_display] set DISP(3f) output back to original defaults !! !!##DESCRIPTION !!    The subroutine disp_set_factory (which has no arguments) may be called !!    to restore all settings of DISP(3f) to the original default values. !! !!##AUTHOR !!   Based on dispmodule(3f), !!   \"A Fortran 95 module for pretty-printing matrices\". !!   Version number 1.02 6-Sept-2008, !!   Kristjan Jonasson, !!   Dept. of Computer Science, University of Iceland (jonasson@hi.is). subroutine disp_set_factory () ! Change display settings to the original default DEFSET = FACTORY_SETTINGS end subroutine disp_set_factory subroutine avoid_compiler_warnings ! Routine that exists only to avoid compiler warnings (due to compiler bugs) type ( boxlist ), pointer :: boxl_dummy1 => null (), boxl_dummy2 => null () type ( boxnode ), pointer :: boxn_dummy1 => null (), boxn_dummy2 => null () type ( tostring_settings ), pointer :: ts1 => null (), ts2 => null () ts1 => ts2 ts2 => ts1 boxl_dummy2 => boxl_dummy1 boxl_dummy1 => boxl_dummy2 boxn_dummy2 => boxn_dummy1 boxn_dummy1 => boxn_dummy2 end subroutine avoid_compiler_warnings !> !!##NAME !!    tostring_set(3f) - [M_display] set modes for TOSTRING(3f) !! !!##DESCRIPTION !! !! The subroutine TOSTRING_SET has five arguments, all of which are !! optional. Argument association will normally be realized using argument !! keywords, e.g. CALL TOSTRING_SET(SEP='; '). The examples in section 5.4 !! clarify how to use this subroutine. The five arguments are: !! !! SEP     Character string used to separate elements of displayed !!         vectors. Original default value is ', '. !! !! RFMT    Character string containing default edit descriptor to use to !!         display real items. The original default value is '1PG12.5' !! !! IFMT    Character string containing default edit descriptor to use to !!         display integer items. The original default value is 'I0'. !! !! TRIMB   Controls whether leading and trailing blanks are trimmed from !!         individual displayed elements. Possible values are 'YES' !!         (to trim blanks) and 'NO' (for no trimming). Default is 'YES'. !! !! TRIMZ   Controls whether trailing zeros are trimmed from the fractional !!         part of displayed items. Possible values are 'NONE' (for no !!         zero trimming), 'G' (to trim fractional trailing zeros only when !!         G editing is used), and 'ALL' (to trim zeros with all types !!         of editing). Trailing decimal points are also removed when !!         zero-trimming is active. Default value is 'G'. !! !!##EXAMPLES !! !! !! When the original (factory) defaults are in effect, the result of invoking !! TOSTRING will usually be as follows. !! !!     Invocation                             Returned String !!     ----------                             --------------- !!     tostring(atan(1.0))                    '0.785398' !!     tostring(exp([-3.,-1.,0.,1.]))         '4.97871E-02, 0.36788, 1, 2.7183' !!     tostring(real([(i,i=1,5)])**8)         '1, 256, 6561, 65536, 3.90625E+05' !!     tostring([1.23456,1.2300,1.23456e6])   '1.2346, 1.23, 1.23456E+06' !!     tostring(real([(i,i=1,5)])**8,'f0.1')  '1.0, 256.0, 6561.0, 65536.0, 390625.0' !!     tostring(real([(i,i=1,5)])**8,'f6.1')  '1.0, 256.0, 6561.0, ******, ******' !!     tostring([1200000.,-1.2e-9])           '1.2E+06, -1.2E-09' !!     ! !!     tostring(1.200d103)                    '1.2+103' !!     tostring([1.1d0,2.2d10,3.3d20])        '1.1E+00, 2.2E+10, 3.3E+20' !!     ! !!     tostring(-77)                          '-77' !!     tostring([(i,i=-3,3)]**11)             '-177147, -2048, -1, 0, 1, 2048, 177147' !!     tostring([(i,i=-3,3)]**11, 'i7')       '-177147, -2048, -1, 0, 1, 2048, 177147' !!     tostring([(i,i=-3,3)]**11, 'i4')       '****, ****, -1, 0, 1, 2048, ****' !!     ! !!     tostring((1,3)/(4,2))                  '0.5 + 0.5i' !!     tostring(cmplx([-1,-2])**0.25)       '0.70711 + 0.70711i, 0.8409 + 0.8409i' !!     ! !!     tostring([.true., .false., .false.])   'T, F, F' !!     tostring(.true., 'L2')                 'T' !! !! The returned strings may be slightly different from the ones shown, !! because some compilers (at least some versions of g95) will produce one !! more decimal place in a few cases, and because the Fortran standard allows !! G editing to give exponent fields in the form 0dd instead of Edd. The !! examples make use of brackets to construct vector constants (a Fortran !! 2003 feature). If the compiler being used does not support this, [ and !! ] must be used instead. Notice that trimming is on by default so there !! is not much purpose in specifying the format for integers and logicals. !! Notice also that (usually) 5 significant digits are displayed when the !! default G editing results in F edited output, but 6 digits for the numbers !! of small or large magnitude, displayed with E editing. This discrepancy !! is present in the Fortran standard; the presence of the scale factor 1P in !! the edit descriptor increases the number of displayed significant digits. !! !! Examples of using TOSTRING_SET follow (again the returned string may be !! slightly different). !! !!       Invocation                              Returned String !!       ----------                              --------------- !!       call tostring_set(sep=';') !!       tostring([1,2,30])                      '1;2;30' !!       ! !!       call tostring_set(trimb='NO') !!       tostring(real([(i,i=1,5)])**8,'f6.1')   '   1.0; 256.0;6561.0;******;******' !!       tostring([1,2,30],'i3')                 '  1;  2; 30' !!       tostring([(i,i=-3,3)]**11, 'i4')        '****;****;  -1;   0;   1;2048;****' !!       tostring([1,2,30],'i0')                 '1;2;30' !!       tostring(.true.,'L3')                   '  T' !!       ! !!       call tostring_set(trimz='NONE',sep=', ',trimb='YES') !!       tostring(real([(i,i=1,4)])**8)          '1.0000, 256.00, 6561.0, 65536.' !!       tostring([1.23456,1.2300,1.23456e6])    '1.2346, 1.2300, 1.23456E+06' !!       tostring(1.200d103)                     '1.20000+103' !!       ! !!       call tostring_set(trimz='ALL') !!       tostring(real([(i,i=1,5)])**8,'f0.1')   '1, 256, 6561, 65536, 390625' !!       ! !!       call tostring_set(rfmt='G12.4') !!       tostring(real([(i,i=0,5)])**8)          '1, 256, 6561, 0.6554E+05, 0.3906E+06' !!       tostring([1200000.,-1.2e-9])            '0.12E+07, -0.12E-08' !!       ! !!       call tostring_set_factory() !! !!##AUTHOR !!   Based on dispmodule(3f), !!   \"A Fortran 95 module for pretty-printing matrices\". !!   Version number 1.02 6-Sept-2008, !!   Kristjan Jonasson, Dept. of Computer Science, !!   University of Iceland (jonasson@hi.is). subroutine tostring_set ( sep , rfmt , ifmt , trimb , trimz ) character ( * ), optional , intent ( in ) :: sep , rfmt , ifmt , trimb , trimz if ( present ( sep )) tosset % sep = upper ( sep ) if ( present ( sep )) tosset % seplen = min ( 9 , len ( sep )) if ( present ( rfmt )) tosset % rfmt = upper ( rfmt ) if ( present ( ifmt )) tosset % ifmt = upper ( ifmt ) if ( present ( trimb )) tosset % trimb = upper ( trimb ) if ( present ( trimz )) tosset % trimz = upper ( trimz ) call tostring_check_settings end subroutine tostring_set !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    tostring_set_factory(3f) - [M_display] set TOSTRING(3f) output back !!    to original defaults !! !!##DESCRIPTION !! The subroutine TOSTRING_SET_FACTORY (which has no arguments) may be !! called to restore all settings of TOSTRING(3f) to the original default !! values (the factory defaults): SEP=',', RFMT = '1PG12.5', IFMT= 'I0', !! TRIMB='YES' and TRIMZ='G'. !! !!##AUTHOR !!   Based on dispmodule(3f), !!   \"A Fortran 95 module for pretty-printing matrices\". !!   Version number 1.02 6-Sept-2008, !!   Kristjan Jonasson, Dept. of Computer Science, !!   University of Iceland (jonasson@hi.is). subroutine tostring_set_factory () logical dummy dummy = . false . if ( dummy ) call avoid_compiler_warnings tosset = tosfac end subroutine tostring_set_factory subroutine disp_set_ds ( settings ) ! Change display settings according to the structure \"settings\" type ( disp_settings ), intent ( in ) :: settings DEFSET = settings call check_settings end subroutine disp_set_ds !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !! !! disp_get(3f) - [M_display] return default settings in a structure of !!                DISP(3f) settings !! !!##DESCRIPTION !! !! The argumentless function DISP_GET returns the current default settings !! in a structure of type DISP_SETTINGS. If a subroutine changes the default !! settings with DISP_SET it is possible to save the settings that are in !! effect when the routine is entered, and restore these settings before !! returning from the routine. !! !!##EXAMPLE !! !! !! An example is: !! !!    program demo_disp_get !!    real :: xx(2,3), yy(2,3) !!       xx(1,:)=[ 1.0, 6.0, 5.0  ] !!       xx(2,:)=[ 2.4, 4.0, 6.0  ] !!       yy(1,:)=[ 0.0, 3.5, 2.0  ] !!       yy(2,:)=[ 7.0, 4.0, 8.22 ] !!       call disp_xy(xx,yy) !!    contains !! !!    subroutine disp_xy(x,y) !!    use M_display !!    real x(:,:), y(:,:) !!    type(disp_settings) ds !!       ds = disp_get() !!       call disp_set(digmax=4, sep=',') !!       call disp('x=',x) !!       write(*,*) !!       call disp('y=',y) !!       call disp_set(ds) !!    end subroutine disp_xy !! !!    end program demo_disp_get !! !! Expected: !! !!    x=1.000,6.000,5.000 !!      2.400,4.000,6.000 !! !!    y=0.000,3.500,2.000 !!      7.000,4.000,8.220 !! !!##AUTHOR !!     Based on dispmodule(3f), !!     \"A Fortran 95 module for pretty-printing matrices\". !!     Version number 1.02 6-Sept-2008, !!     Kristjan Jonasson, !!     Dept. of Computer Science, !!     University of Iceland (jonasson@hi.is). function disp_get () result ( defs ) ! Return current display settings type ( disp_settings ) :: defs defs = DEFSET end function disp_get !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! *********************************************** DEFAULT INTEGER PROCEDURES ****************************************************** !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine disp_scalar_int ( x , fmt , advance , sep , trim , unit , zeroas ) ! ident_2=\"@(#) M_disp disp_scalar_int(3f) integer scalar without title (call disp_title_scalar_int(3f) with title='')\" character ( * ), intent ( in ), optional :: fmt , advance , sep , trim , zeroas integer ( dint ), intent ( in ) :: x integer , intent ( in ), optional :: unit call disp_title_scalar_int ( '' , x , fmt , advance , sep , 'left' , trim , unit , zeroas ) end subroutine disp_scalar_int !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine disp_title_scalar_int ( title , x , fmt , advance , sep , style , trim , unit , zeroas ) ! ident_3=\"@(#) M_display disp_scalar_int(3f) Default integer scalar with title\" character ( * ), intent ( in ) :: title character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim , zeroas integer ( dint ), intent ( in ) :: x integer , intent ( in ), optional :: unit call disp_title_matrix_int ( title , reshape ([ x ],[ 1 , 1 ]), fmt , advance , sep = sep , style = style , trim = trim , unit = unit , zeroas = zeroas ) end subroutine disp_title_scalar_int !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine disp_vector_int ( x , fmt , advance , lbound , sep , style , trim , unit , orient , zeroas ) ! ident_4=\"@(#) M_display disp_vector_int(3f) Default integer vector without title\" character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim , zeroas , orient integer ( dint ), intent ( in ) :: x (:) integer , intent ( in ), optional :: unit , lbound (:) call disp_title_vector_int ( '' , x , fmt , advance , lbound , sep , style , trim , unit , orient , zeroas ) end subroutine disp_vector_int !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine disp_title_vector_int ( title , x , fmt , advance , lbound , sep , style , trim , unit , orient , zeroas ) ! Default integer vector with title character ( * ), intent ( in ) :: title character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim , zeroas , orient integer ( dint ), intent ( in ) :: x (:) integer , intent ( in ), optional :: unit , lbound (:) type ( settings ) :: SE call get_SE ( SE , title , shape ( x ), fmt , advance , lbound , sep , style , trim , unit , orient , zeroas ) if ( SE % row ) then call disp_dint ( title , reshape ( x , [ 1 , size ( x )]), SE ) else call disp_dint ( title , reshape ( x , [ size ( x ), 1 ]), SE ) endif end subroutine disp_title_vector_int !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine disp_matrix_int ( x , fmt , advance , lbound , sep , style , trim , unit , zeroas ) ! Default integer matrix without title character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim , zeroas integer ( dint ), intent ( in ) :: x (:,:) integer , intent ( in ), optional :: unit , lbound (:) call disp_title_matrix_int ( '' , x , fmt , advance , lbound , sep , style , trim , unit , zeroas ) end subroutine disp_matrix_int !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine disp_title_matrix_int ( title , x , fmt , advance , lbound , sep , style , trim , unit , zeroas ) ! Default integer matrix with title character ( * ), intent ( in ) :: title ! The title to use for the matrix integer ( dint ), intent ( in ) :: x (:,:) ! The matrix to be written character ( * ), intent ( in ), optional :: fmt ! Format edit descriptor to use for each matrix element (e.g.'I4') integer , intent ( in ), optional :: unit ! Unit to display on character ( * ), intent ( in ), optional :: advance ! 'No' to print next matrix to right of current, otherwise 'Yes' character ( * ), intent ( in ), optional :: sep ! Separator between matrix columns (e.g. \", \") character ( * ), intent ( in ), optional :: zeroas ! Zeros are replaced by this string character ( * ), intent ( in ), optional :: style ! Style(s): See NOTE 1 below character ( * ), intent ( in ), optional :: trim ! 'Auto' (the default) to trim if fmt absent, 'no' for no trimming, !                                                ! trimming, 'yes' for trimming integer , intent ( in ), optional :: lbound (:) ! Lower bounds of x type ( settings ) :: SE call get_SE ( SE , title , shape ( x ), fmt , advance , lbound , sep , style , trim , unit , zeroas = zeroas ) call disp_dint ( title , x , SE ) end subroutine disp_title_matrix_int !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine disp_dint ( title , x , SE ) ! Default integer item character ( * ), intent ( in ) :: title integer ( dint ), intent ( in ) :: x (:,:) type ( settings ), intent ( inout ) :: SE integer wid ( size ( x , 2 )), nbl ( size ( x , 2 )) call find_editdesc_dint ( x , SE , wid , nbl ) ! determine also SE % w call tobox_dint ( title , x , SE , wid , nbl ) end subroutine disp_dint !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine tobox_dint ( title , x , SE , wid , nbl ) ! Write default integer matrix to box character ( * ), intent ( in ) :: title integer ( dint ), intent ( in ) :: x (:,:) type ( settings ), intent ( inout ) :: SE integer , intent ( inout ) :: wid (:) integer , intent ( inout ) :: nbl (:) character ( SE % w ) :: s ( size ( x , 1 )) integer :: lin1 , j , wleft , m , n , widp ( size ( wid )) character , pointer :: boxp (:,:) m = size ( x , 1 ) n = size ( x , 2 ) call preparebox ( title , SE , m , n , wid , widp , lin1 , wleft , boxp ) do j = 1 , n if ( m > 0 ) write ( s , SE % ed ) x (:, j ) if ( SE % lzas > 0 ) call replace_zeronaninf ( s , SE % zas ( 1 : SE % lzas ), x (:, j ) == 0 ) call copytobox ( s , lin1 , wid ( j ), widp ( j ), nbl ( j ), boxp , wleft ) if ( j < n ) call copyseptobox ( SE % sep ( 1 : SE % lsep ), m , lin1 , boxp , wleft ) enddo call finishbox ( title , SE , boxp ) end subroutine tobox_dint !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine find_editdesc_dint ( x , SE , wid , nbl ) ! Determine SE % ed, SE % w (unless specified) and wid integer ( dint ), intent ( in ) :: x (:,:) type ( settings ), intent ( inout ) :: SE integer , intent ( out ) :: wid ( size ( x , 2 )), nbl ( size ( x , 2 )) ! integer ( dint ) xmaxv ( size ( x , 2 )), xminv ( size ( x , 2 )), xp , xm logical xzero ( size ( x , 2 )), xallz ( size ( x , 2 )) character ( 22 ) s integer ww ! if ( SE % w == 0 ) then xp = maxval ( x ) xm = minval ( x ) write ( s , '(SS,I0)' ) xp ; ww = len_trim ( s ) write ( s , '(SS,I0)' ) xm ; ww = max ( ww , len_trim ( s )) SE % w = max ( SE % lzas , ww ) call replace_w ( SE % ed , ww ) elseif ( SE % w < 0 ) then ! obtain max-width of x if ( size ( x ) == 0 ) then SE % ed = '()' SE % w = 0 wid = 0 return endif xp = maxval ( x ) xm = minval ( x ) write ( s , '(SS,I0)' ) xp ; ww = len_trim ( s ) write ( s , '(SS,I0)' ) xm ; ww = max ( ww , len_trim ( s )) ww = max ( SE % lzas , ww ) SE % ed = '(SS,Ixx)' write ( SE % ed ( 6 : 7 ), '(SS,I2)' ) ww SE % w = ww endif if ( SE % trm ) then xmaxv = maxval ( x , 1 ) ! max in each column xminv = minval ( x , 1 ) ! min xzero = any ( x == 0_dint , 1 ) ! true where column has some zeros xallz = all ( x == 0_dint , 1 ) ! true where column has only zeros call getwid_dint ( xmaxv , xminv , xzero , xallz , SE , wid , nbl ) else wid = SE % w nbl = 0 endif end subroutine find_editdesc_dint !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine getwid_dint ( xmaxv , xminv , xzero , xallz , SE , wid , nbl ) integer ( dint ), intent ( in ) :: xmaxv (:), xminv (:) logical , intent ( in ) :: xzero (:), xallz (:) ! True for columns with some/all zeros type ( settings ), intent ( in ) :: SE ! Settings integer , intent ( out ) :: wid (:) ! Widths of columns integer , intent ( out ) :: nbl (:) ! n of blanks to peel from left (w-wid) character ( SE % w ) :: stmax ( size ( xmaxv )), stmin ( size ( xminv )) integer w w = SE % w write ( stmax , SE % ed ) xmaxv write ( stmin , SE % ed ) xminv nbl = mod ( verify ( stmin , ' ' ) + w , w + 1 ) ! loc. of first nonblank nbl = min ( nbl , mod ( verify ( stmax , ' ' ) + w , w + 1 )) wid = w - nbl if ( SE % lzas > 0 ) then wid = merge ( SE % lzas , wid , xallz ) wid = max ( wid , merge ( SE % lzas , 0 , xzero )) nbl = w - wid endif end subroutine getwid_dint !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!      tostring(3f) - [M_display] change numbers to a string !! !!##INTRODUCTION !! !! Many programming languages have built-in functions that change numbers !! to strings. It is possible to achieve a similar effect in Fortran !! using internal files and list-directed output: !! !!       character(100) s !!       real :: x = 1.5 !!       write(s, *) 'The square of', x, 'is', x*x !!       print *, trim(s) !! !! but this is cumbersome, and also there is the disadvantage that the !! result is compiler-dependent. M_display has a function, TOSTRING, which !! overcomes this disadvantage and offers additional flexibility. With x = !! 1.5 the following statement will produce the same output as Matlab and !! Java give: !! !!       CALL DISP('The square of '//TOSTRING(X)//' is '//TOSTRING(X*X)) !! !! TOSTRING accepts integer, logical or real scalars or vectors. The !! subroutine TOSTRING_SET may be used to change settings for TOSTRING. !! !!##THE FUNCTION TOSTRING !! !! Apart from the item to be turned into a string, an edit descriptor to !! use can optionally be supplied as the second argument to TOSTRING. The !! two ways to invoke TOSTRING are: !! !!       TOSTRING(X) !!       TOSTRING(X, FMT) !! !! These invocations return a character string representing the value of !! the argument X. When X is a vector individual elements are separated !! by a string, with the original (or factory) default value \", \". By !! (original) default G editing is used to convert real numbers, I editing !! integers, and blanks are trimmed from (each element of) X, both from !! the left and the right. In addition trailing zeroes are trimmed from !! the fractional part of real X-elements, as well as a trailing decimal !! point. The separating string, trimming behavior, and default editing !! may be changed by calling TOSTRING_SET !! !! X     The item to be changed to a string. X may be a scalar or a vector !!       (i.e. of rank 0 or 1) and of one of the following kinds: !! !!         default integer !!         default real (i.e. real(1.0), single precision) !!         double precision real (i.e. real(1d0)) !!         default logical !! !! FMT   Character string with an edit descriptor used to format each !!       element of X. The possible edit descriptors are given in section !!       3.1, except that A and Aw can of course not be used. When FMT is !!       absent, a default edit descriptor is used. The default may be set !!       by calling TOSTRING_SET but the original (or factory) defaults !!       are I0 for integers, L1 for logicals and 1PG12.5 for reals. !! !!##AUTHOR !!     Based on dispmodule(3f), !!     \"A Fortran 95 module for pretty-printing matrices\". !!     Version number 1.02 6-Sept-2008, !!     Kristjan Jonasson, !!     Dept. of Computer Science, !!     University of Iceland (jonasson@hi.is). !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! ********* DEFAULT INTEGER TOSTRING PROCEDURES ********* pure function widthmax_dint ( x , fmt ) result ( w ) ! Maximum width of string representation of an element in x integer ( dint ), intent ( in ) :: x (:) character ( * ), intent ( in ) :: fmt character ( range ( x ) + 2 ) sx ( 2 ) integer w , d logical gedit character ( nnblk ( fmt ) + 5 ) :: fmt1 call readfmt ( fmt , fmt1 , w , d , gedit ) if ( w <= 0 ) then write ( sx , '(SS,I0)' ) maxval ( x ), minval ( x ) w = maxval ( len_trim ( sx )) endif end function widthmax_dint pure function len_f_dint ( x , fmt ) result ( wtot ) ! Total width of tostring representation of x integer ( dint ), intent ( in ) :: x (:) character ( * ), intent ( in ) :: fmt character ( widthmax_dint ( x , fmt )) :: sa ( size ( x )) integer :: wtot , w , d logical :: gedit character ( nnblk ( fmt ) + 5 ) :: fmt1 integer :: iostat call readfmt ( fmt , fmt1 , w , d , gedit ) if ( w < 0 ) then ; wtot = len ( errormsg ); return ; endif write ( sa , fmt1 , iostat = iostat ) x if ( tosset % trimb == 'YES' . or . w == 0 ) sa = adjustl ( sa ) wtot = sum ( len_trim ( sa )) + ( size ( x ) - 1 ) * ( tosset % seplen ) end function len_f_dint function tostring_s_dint ( x ) result ( st ) ! Scalar to string integer ( dint ), intent ( in ) :: x character ( len_f_dint ([ x ], tosset % ifmt )) :: st st = tostring_f_dint ([ x ], tosset % ifmt ) end function tostring_s_dint function tostring_sf_dint ( x , fmt ) result ( st ) ! Scalar with specified format to string integer ( dint ), intent ( in ) :: x character ( * ), intent ( in ) :: fmt character ( len_f_dint ([ x ], fmt )) :: st st = tostring_f_dint ([ x ], fmt ) end function tostring_sf_dint function tostring_dint ( x ) result ( st ) ! Vector to string integer ( dint ), intent ( in ) :: x (:) character ( len_f_dint ( x , tosset % ifmt )) :: st st = tostring_f_dint ( x , tosset % ifmt ) end function tostring_dint function tostring_f_dint ( x , fmt ) result ( st ) ! Vector with specified format to string integer ( dint ), intent ( in ) :: x (:) character ( * ), intent ( in ) :: fmt character ( len_f_dint ( x , fmt )) :: st character ( widthmax_dint ( x , fmt )) :: sa ( size ( x )) integer :: w , d logical :: gedit character ( nnblk ( fmt ) + 5 ) :: fmt1 integer :: iostat call readfmt ( fmt , fmt1 , w , d , gedit ) if ( w < 0 ) then ; st = errormsg ; return ; endif write ( sa , fmt1 , iostat = iostat ) x if ( tosset % trimb == 'YES' . or . w == 0 ) sa = adjustl ( sa ) call tostring_get ( sa , st ) end function tostring_f_dint !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! ************************************* END OF DEFAULT INTEGER PROCEDURES ****************************************** ! **************************************** SINGLE PRECISION PROCEDURES ********************************************* !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine disp_s_sngl ( x , fmt , advance , digmax , sep , trim , unit , zeroas ) ! Single precision scalar without title character ( * ), intent ( in ), optional :: fmt , advance , sep , trim , zeroas real ( sngl ), intent ( in ) :: x integer , intent ( in ), optional :: unit , digmax call disp_ts_sngl ( '' , x , fmt , advance , digmax , sep , 'left' , trim , unit , zeroas ) end subroutine disp_s_sngl subroutine disp_v_sngl ( x , fmt , advance , digmax , lbound , sep , style , trim , unit , orient , zeroas ) ! Single precision vector without title character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim , zeroas , orient real ( sngl ), intent ( in ) :: x (:) integer , intent ( in ), optional :: unit , lbound (:), digmax call disp_tv_sngl ( '' , x , fmt , advance , digmax , lbound , sep , style , trim , unit , orient , zeroas ) end subroutine disp_v_sngl subroutine disp_m_sngl ( x , fmt , advance , lbound , sep , style , trim , unit , digmax , zeroas ) ! Single precision matrix without title character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim , zeroas real ( sngl ), intent ( in ) :: x (:,:) integer , intent ( in ), optional :: unit , digmax , lbound (:) call disp_tm_sngl ( '' , x , fmt , advance , digmax , lbound , sep , style , trim , unit , zeroas ) end subroutine disp_m_sngl subroutine disp_ts_sngl ( title , x , fmt , advance , digmax , sep , style , trim , unit , zeroas ) ! Single precision scalar with title character ( * ), intent ( in ) :: title character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim , zeroas real ( sngl ), intent ( in ) :: x integer , intent ( in ), optional :: unit , digmax call disp_tm_sngl ( title , reshape ([ x ], [ 1 , 1 ]), fmt , advance , digmax , sep = sep , style = style , trim = trim , & unit = unit , zeroas = zeroas ) end subroutine disp_ts_sngl subroutine disp_tv_sngl ( title , x , fmt , advance , digmax , lbound , sep , style , trim , unit , orient , zeroas ) ! Single precision vector with title character ( * ), intent ( in ) :: title character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim , zeroas , orient real ( sngl ), intent ( in ) :: x (:) integer , intent ( in ), optional :: unit , lbound (:), digmax type ( settings ) :: SE call get_SE ( SE , title , shape ( x ), fmt , advance , lbound , sep , style , trim , unit , orient , zeroas , digmax ) if ( SE % row ) then call disp_sngl ( title , reshape ( x , [ 1 , size ( x )]), SE ) else call disp_sngl ( title , reshape ( x , [ size ( x ), 1 ]), SE ) endif end subroutine disp_tv_sngl subroutine disp_tm_sngl ( title , x , fmt , advance , digmax , lbound , sep , style , trim , unit , zeroas ) ! Single precision matrix with title character ( * ), intent ( in ) :: title ! The title to use for the matrix real ( sngl ), intent ( in ) :: x (:,:) ! The matrix to be written character ( * ), intent ( in ), optional :: fmt ! Editdit descriptor to use for each matrix element (e.g. 'F5.2') integer , intent ( in ), optional :: unit ! Unit to display on integer , intent ( in ), optional :: digmax ! Nbr of significant digits for largest abs value in x character ( * ), intent ( in ), optional :: advance ! 'No' to print next matrix to right of current, otherwise 'Yes' character ( * ), intent ( in ), optional :: sep ! Separator between matrix columns (e.g. \", \") character ( * ), intent ( in ), optional :: zeroas ! Zeros are replaced with this string if it is not empty character ( * ), intent ( in ), optional :: style ! Style(s): See NOTE 1 below character ( * ), intent ( in ), optional :: trim ! 'Auto' (the default) to trim if fmt absent, 'no' for no !                                                ! trimming, 'yes' for trimming integer , intent ( in ), optional :: lbound (:) ! Lower bounds of x type ( settings ) :: SE ! call get_SE ( SE , title , shape ( x ), fmt , advance , lbound , sep , style , trim , unit , zeroas = zeroas , digmax = digmax ) call disp_sngl ( title , x , SE ) end subroutine disp_tm_sngl subroutine disp_sngl ( title , x , SE ) ! Single precision item character ( * ), intent ( in ) :: title real ( sngl ), intent ( in ) :: x (:,:) type ( settings ), intent ( inout ) :: SE integer wid ( size ( x , 2 )), nbl ( size ( x , 2 )) call find_editdesc_sngl ( x , SE , wid , nbl ) ! determine also SE % w call tobox_sngl ( title , x , SE , wid , nbl ) end subroutine disp_sngl subroutine tobox_sngl ( title , x , SE , wid , nbl ) ! Write single precision matrix to box character ( * ), intent ( in ) :: title ! title real ( sngl ), intent ( in ) :: x (:,:) ! item type ( settings ), intent ( inout ) :: SE ! settings integer , intent ( inout ) :: wid (:) ! widths of columns integer , intent ( inout ) :: nbl (:) ! number of blanks to trim from left character ( SE % w ) :: s ( size ( x , 1 )) integer :: lin1 , j , wleft , m , n , widp ( size ( wid )) character , pointer :: boxp (:,:) real ( sngl ) :: xj ( size ( x , 1 )), h integer :: iostat m = size ( x , 1 ) n = size ( x , 2 ) h = huge ( x ) call preparebox ( title , SE , m , n , wid , widp , lin1 , wleft , boxp ) do j = 1 , n xj = x (:, j ) if ( m > 0 ) write ( s , SE % ed , iostat = iostat ) xj call replace_zeronaninf ( s , SE % zas ( 1 : SE % lzas ), xj == 0 , xj /= xj , xj < - h , xj > h ) call copytobox ( s , lin1 , wid ( j ), widp ( j ), nbl ( j ), boxp , wleft ) if ( j < n ) call copyseptobox ( SE % sep ( 1 : SE % lsep ), m , lin1 , boxp , wleft ) enddo call finishbox ( title , SE , boxp ) end subroutine tobox_sngl pure function maxw_sngl ( x , d ) result ( w ) ! Find max field width needed (F0.d editing is specified) real ( sngl ), intent ( in ) :: x (:) integer , intent ( in ) :: d integer expmax , expmin , w logical xfinite ( size ( x )) real ( sngl ) xmax , xmin , h character ( 12 ) :: f1 , s ( 2 ) character ( len = :), allocatable :: temp (:) xmin = 0 ; xmax = 0 ; h = huge ( h ) xfinite = x == x . and . x >= - h . and . x <= h ! neither NaN, Inf nor -Inf if (. not . any ( xfinite )) then w = 4 else xmax = maxval ( x , mask = xfinite ) xmin = minval ( x , mask = xfinite ) f1 = '(SS,ES9.0E4)' write ( s , f1 ) xmax , xmin temp = s (:)( 5 : 9 ) read ( temp , '(I5)' ) expmax , expmin w = max ( 0 , expmax , expmin ) + d + 4 endif if (. not . all ( xfinite )) w = max ( w , 4 ) end function maxw_sngl subroutine find_editdesc_sngl ( x , SE , wid , nbl ) ! Determine SE % ed, SE % w (unless specified) and wid. ! The if-block (*) is for safety: make f wider in case xm is written ok with the ! ES format in fmt but overflows with F format (the feature has been tested through ! manual changes to the program). real ( sngl ), intent ( in ) :: x (:,:) ! Item to be written type ( settings ), intent ( inout ) :: SE ! Settings integer , intent ( out ) :: wid ( size ( x , 2 )) ! Widths of individual columns integer , intent ( out ) :: nbl ( size ( x , 2 )) ! Blanks to trim from left of individual columns integer :: expmax , expmin , ww , dd , dmx real ( sngl ) xmaxv ( size ( x , 2 )), xminv ( size ( x , 2 )), xp , xm , h character ( 14 ) :: f1 = '(SS,ESxx.xxE4)' ! could be ES99.89E4; default is ES14.05E4 character ( 99 ) s logical xzero ( size ( x , 2 )), xallz ( size ( x , 2 )), xfinite ( size ( x , 1 ), size ( x , 2 )), xnonn ( size ( x , 2 )), xalln ( size ( x , 2 )) ! dmx = SE % dmx h = huge ( h ) xfinite = x == x . and . x >= - h . and . x <= h ! neither NaN, Inf nor -Inf if ( SE % w == 0 ) then ! Edit descriptor 'F0.d' specified ww = maxw_sngl ( reshape ( x , [ size ( x )]), SE % d ) if ( SE % lzas > 0 . and . any ( x == 0._sngl )) ww = max ( ww , SE % lzas ) call replace_w ( SE % ed , ww ) SE % w = ww elseif ( SE % w < 0 ) then ! No edit descriptor specified if ( size ( x ) == 0 ) then SE % w = 0 wid = 0 nbl = 0 return endif if ( any ( xfinite )) then xp = maxval ( x , mask = xfinite ) xm = minval ( x , mask = xfinite ) write ( f1 ( 7 : 11 ), '(SS,I2,\".\",I2.2)' ) dmx + 8 , dmx - 1 write ( s , f1 ) xp ; read ( s ( dmx + 4 : dmx + 8 ), '(I5)' ) expmax write ( s , f1 ) xm ; read ( s ( dmx + 4 : dmx + 8 ), '(I5)' ) expmin call find_editdesc_real ( expmax , expmin , dmx , SE % ed , ww , dd , xm >= 0 ) if (. not . all ( xfinite )) ww = max ( ww , 4 ) if ( SE % lzas > 0 . and . any ( x == 0._sngl )) ww = max ( ww , SE % lzas ) if ( SE % ed ( 5 : 5 ) == 'F' ) then ! (*) write ( s , SE % ed ) xp ; if ( s ( 1 : 1 ) == '*' ) ww = ww + 1 write ( s , SE % ed ) xm ; if ( s ( 1 : 1 ) == '*' ) ww = ww + 1 write ( SE % ed ( 6 : 10 ), '(SS,I2,\".\",I2)' ) ww , dd endif else ww = 4 SE % ed = '(F4.0)' endif SE % w = ww endif if ( SE % trm ) then xmaxv = maxval ( x , 1 , mask = xfinite ) ! max in each column xminv = minval ( x , 1 , mask = xfinite ) ! min xzero = any ( x == 0._sngl , 1 ) ! true where column has some zeros xallz = all ( x == 0._sngl , 1 ) ! true where column has only zeros xnonn = any ( x > h . or . x < - h . or . x /= x , 1 ) ! true where column has some nonnormals (inf, -inf, nan) xalln = all ( x > h . or . x < - h . or . x /= x , 1 ) ! true where column has only nonnormals (inf, -inf, nan) call getwid_sngl ( xmaxv , xminv , xzero , xallz , xnonn , xalln , SE , wid , nbl ) else wid = SE % w nbl = 0 endif end subroutine find_editdesc_sngl subroutine getwid_sngl ( xmaxv , xminv , xzero , xallz , xnonn , xalln , SE , wid , nbl ) ! determine length of the strings that result when writing with edit descriptor SE%ed a ! vector v where v(i) is xmaxv(i) or xminv(i) depending on which gives longer output real ( sngl ), intent ( in ) :: xmaxv (:), xminv (:) ! max and min values in each column logical , intent ( in ) :: xzero (:), xallz (:) ! true for columns with some/all zeros logical , intent ( in ) :: xnonn (:), xalln (:) ! true for columns with some/all nonnormals type ( settings ), intent ( in ) :: SE ! settings integer , intent ( out ) :: wid (:) ! widths of columns integer , intent ( out ) :: nbl (:) ! number of blanks to peel from left (w-wid) character ( SE % w ) :: stmax ( size ( xmaxv )), stmin ( size ( xminv )) integer :: w integer :: iostat w = SE % w write ( stmin , SE % ed , iostat = iostat ) xminv write ( stmax , SE % ed , iostat = iostat ) xmaxv nbl = mod ( verify ( stmin , ' ' ) + w , w + 1 ) ! loc. of first nonblank nbl = min ( nbl , mod ( verify ( stmax , ' ' ) + w , w + 1 )) if ( SE % gedit ) then wid = w else wid = len_trim ( adjustl ( stmin )) wid = max ( wid , len_trim ( adjustl ( stmax ))) endif if ( SE % lzas > 0 ) then wid = merge ( SE % lzas , wid , xallz ) wid = max ( wid , merge ( SE % lzas , 0 , xzero )) endif wid = merge ( 4 , wid , xalln ) wid = max ( wid , merge ( 4 , 0 , xnonn )) nbl = w - wid end subroutine getwid_sngl !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! ******** TOSTRING SINGLE PRECISION PROCEDURES *********** pure function widthmax_sngl ( x , fmt ) result ( w ) ! Maximum width of an element of x real ( sngl ), intent ( in ) :: x (:) character ( * ), intent ( in ) :: fmt character ( nnblk ( fmt ) + 5 ) :: fmt1 integer w , d logical gedit call readfmt ( fmt , fmt1 , w , d , gedit ) if ( w < 0 ) then ! illegal format, use 1 w = 1 elseif ( w == 0 ) then w = maxw_sngl ( x , d ) endif end function widthmax_sngl pure function len_f_sngl ( x , fmt ) result ( wtot ) ! Total length of returned string, vector s real ( sngl ), intent ( in ) :: x (:) character ( * ), intent ( in ) :: fmt character ( widthmax_sngl ( x , fmt )) :: sa ( size ( x )) integer :: wtot , w , d , ww logical :: gedit character ( nnblk ( fmt ) + 8 ) :: fmt1 !(5 for readfmt and 3 for replace_w) integer :: iostat call readfmt ( fmt , fmt1 , w , d , gedit ) if ( w < 0 ) then ; wtot = len ( errormsg ); return ; endif if ( w == 0 ) then ww = maxw_sngl ( x , d ) call replace_w ( fmt1 , ww ) endif write ( sa , fmt1 , iostat = iostat ) x call trim_real ( sa , gedit , w ) wtot = sum ( len_trim ( sa )) + ( size ( x ) - 1 ) * ( tosset % seplen ) end function len_f_sngl function tostring_s_sngl ( x ) result ( st ) ! Scalar to string real ( sngl ), intent ( in ) :: x character ( len_f_sngl ([ x ], tosset % rfmt )) :: st st = tostring_f_sngl ([ x ], tosset % rfmt ) end function tostring_s_sngl function tostring_sf_sngl ( x , fmt ) result ( st ) ! Scalar with specified format to string real ( sngl ), intent ( in ) :: x character ( * ), intent ( in ) :: fmt character ( len_f_sngl ([ x ], fmt )) :: st st = tostring_f_sngl ([ x ], fmt ) end function tostring_sf_sngl function tostring_sngl ( x ) result ( st ) ! Vector to string real ( sngl ), intent ( in ) :: x (:) character ( len_f_sngl ( x , tosset % rfmt )) :: st st = tostring_f_sngl ( x , tosset % rfmt ) end function tostring_sngl function tostring_f_sngl ( x , fmt ) result ( st ) ! Vector with specified format to string real ( sngl ) , intent ( in ) :: x (:) character ( * ), intent ( in ) :: fmt character ( len_f_sngl ( x , fmt )) :: st character ( widthmax_sngl ( x , fmt )) :: sa ( size ( x )) character ( nnblk ( fmt ) + 8 ) :: fmt1 !(5 for readfmt and 3 for replace_w) integer :: w , d , ww logical :: gedit integer :: iostat call readfmt ( fmt , fmt1 , w , d , gedit ) if ( w < 0 ) then st = errormsg return elseif ( w == 0 ) then ww = maxw_sngl ( x , d ) call replace_w ( fmt1 , ww ) endif write ( sa , fmt1 , iostat = iostat ) x call trim_real ( sa , gedit , w ) call tostring_get ( sa , st ) end function tostring_f_sngl ! *************************************** END OF SINGLE PRECISION PROCEDURES *************************************** !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! *************************************** SINGLE PRECISION COMPLEX PROCEDURES ************************************** subroutine disp_s_cplx ( x , fmt , fmt_imag , advance , digmax , sep , trim , unit ) ! single precision complex scalar without title character ( * ), intent ( in ), optional :: fmt , fmt_imag , advance , sep , trim complex ( sngl ), intent ( in ) :: x integer , intent ( in ), optional :: unit , digmax call disp_ts_cplx ( '' , x , fmt , fmt_imag , advance , digmax , sep , 'left' , trim , unit ) end subroutine disp_s_cplx subroutine disp_v_cplx ( x , fmt , fmt_imag , advance , digmax , lbound , sep , style , trim , unit , orient ) ! single precision complex vector without title character ( * ), intent ( in ), optional :: fmt , fmt_imag , advance , sep , style , trim , orient complex ( sngl ), intent ( in ) :: x (:) integer , intent ( in ), optional :: unit , lbound (:), digmax call disp_tv_cplx ( '' , x , fmt , fmt_imag , advance , digmax , lbound , sep , style , trim , unit , orient ) end subroutine disp_v_cplx subroutine disp_m_cplx ( x , fmt , fmt_imag , advance , digmax , lbound , sep , style , trim , unit ) ! single precision complex matrix without title character ( * ), intent ( in ), optional :: fmt , fmt_imag , advance , sep , style , trim complex ( sngl ), intent ( in ) :: x (:,:) integer , intent ( in ), optional :: unit , digmax , lbound (:) call disp_tm_cplx ( '' , x , fmt , fmt_imag , advance , digmax , lbound , sep , style , trim , unit ) end subroutine disp_m_cplx subroutine disp_ts_cplx ( title , x , fmt , fmt_imag , advance , digmax , sep , style , trim , unit ) ! single precision complex scalar with title character ( * ), intent ( in ) :: title character ( * ), intent ( in ), optional :: fmt , fmt_imag , advance , sep , style , trim complex ( sngl ), intent ( in ) :: x integer , intent ( in ), optional :: unit , digmax call disp_tm_cplx ( title , reshape ([ x ], [ 1 , 1 ]), fmt , fmt_imag , advance , digmax , sep = sep , style = style , & trim = trim , unit = unit ) end subroutine disp_ts_cplx subroutine disp_tv_cplx ( title , x , fmt , fmt_imag , advance , digmax , lbound , sep , style , trim , unit , orient ) ! single precision complex vector with title character ( * ), intent ( in ) :: title character ( * ), intent ( in ), optional :: fmt , fmt_imag , advance , sep , style , trim , orient complex ( sngl ), intent ( in ) :: x (:) integer , intent ( in ), optional :: unit , lbound (:), digmax type ( settings ) SE , SEim call get_SE ( SE , title , shape ( x ), fmt , advance , lbound , sep , style , trim , unit , orient , digmax = digmax ) if ( present ( fmt_imag )) then if (. not . present ( fmt )) then call disp_errmsg ( 'DISP: error, FMT must be present if FMT_IMAG is present' ); return ; endif call get_SE ( SEim , title , shape ( x ), fmt_imag ) else SEim = SE endif if ( SE % row ) then call disp_cplx ( title , reshape ( x , [ 1 , size ( x )]), SE , SEim , n = size ( x )) else call disp_cplx ( title , reshape ( x , [ size ( x ), 1 ]), SE , SEim , n = 1 ) endif end subroutine disp_tv_cplx subroutine disp_tm_cplx ( title , x , fmt , fmt_imag , advance , digmax , lbound , sep , style , trim , unit ) ! single precision complex matrix with title character ( * ), intent ( in ) :: title ! The title to use for the matrix complex ( sngl ), intent ( in ) :: x (:,:) ! The matrix to be written character ( * ), intent ( in ), optional :: fmt ! Edit descriptor for each element (real element when fmt_imag & !                                                ! is present) character ( * ), intent ( in ), optional :: fmt_imag ! Edit descriptor for each imaginary element integer , intent ( in ), optional :: unit ! Unit to display on integer , intent ( in ), optional :: digmax ! Nbr of significant digits for largest abs value in real(x) & !                                                ! and aimag(x) character ( * ), intent ( in ), optional :: advance ! 'No' to print next matrix to right of current, otherwise 'Yes' character ( * ), intent ( in ), optional :: sep ! Separator between matrix columns (e.g. \", \") character ( * ), intent ( in ), optional :: style ! Style(s): See NOTE 1 below character ( * ), intent ( in ), optional :: trim ! 'Auto' (the default) to trim if fmt absent, 'no' for no !                                                ! trimming, 'yes' for trimming integer , intent ( in ), optional :: lbound (:) ! Lower bounds of x ! type ( settings ) :: SE , SEim call get_SE ( SE , title , shape ( x ), fmt , advance , lbound , sep , style , trim , unit , digmax = digmax ) if ( present ( fmt_imag )) then if (. not . present ( fmt )) then call disp_errmsg ( 'DISP: error, FMT must be present if FMT_IMAG is present' ); return endif call get_SE ( SEim , title , shape ( x ), fmt_imag ) else SEim = SE endif call disp_cplx ( title , x , SE , SEim , n = size ( x , 2 )) end subroutine disp_tm_cplx subroutine disp_cplx ( title , x , SE , SEim , n ) ! Single precision item character ( * ), intent ( in ) :: title complex ( sngl ), intent ( in ) :: x (:,:) type ( settings ), intent ( inout ) :: SE , SEim integer , intent ( in ) :: n integer , dimension ( n ) :: widre ( n ), widim ( n ), nblre ( n ), nblim ( n ) call find_editdesc_sngl ( real ( x ), SE , widre , nblre ) ! determine also SE % w call find_editdesc_sngl ( abs ( aimag ( x )), SEim , widim , nblim ) ! determine also SEim % w call tobox_cplx ( title , x , SE , SEim , widre , widim , nblre , nblim , m = size ( x , 1 ), n = size ( x , 2 )) end subroutine disp_cplx subroutine tobox_cplx ( title , x , SE , SEim , widre , widim , nblre , nblim , m , n ) ! Write single precision complex matrix to box character ( * ), intent ( in ) :: title complex ( sngl ), intent ( in ) :: x (:,:) integer , intent ( in ) :: m , n , widre (:), widim (:), nblre (:), nblim (:) type ( settings ), intent ( inout ) :: SE , SEim character ( SE % w ) :: s ( m ) character ( SEim % w ) :: sim ( m ) character ( 3 ) :: sgn ( m ) integer :: lin1 , i , j , wleft , wid ( n ), widp ( n ) character , pointer :: boxp (:,:) SE % zas = '' SEim % zas = '' wid = widre + widim + 4 call preparebox ( title , SE , m , n , wid , widp , lin1 , wleft , boxp ) do j = 1 , n if ( m > 0 ) write ( s , SE % ed ) ( real ( x ( i , j )), i = 1 , m ) call copytobox ( s , lin1 , widre ( j ), widp ( j ) - widim ( j ) - 4 , nblre ( j ), boxp , wleft ) do i = 1 , m if ( aimag ( x ( i , j )) < 0 ) then ; sgn ( i ) = ' - ' ; else ; sgn ( i ) = ' + ' ; endif enddo call copytobox ( sgn , lin1 , 3 , 3 , 0 , boxp , wleft ) if ( m > 0 ) write ( sim , SEim % ed ) ( abs ( aimag ( x ( i , j ))), i = 1 , m ) call copytobox ( sim , lin1 , widim ( j ), widim ( j ), nblim ( j ), boxp , wleft ) call copyseptobox ( 'i' , m , lin1 , boxp , wleft ) if ( j < n ) call copyseptobox ( SE % sep ( 1 : SE % lsep ), m , lin1 , boxp , wleft ) enddo call finishbox ( title , SE , boxp ) end subroutine tobox_cplx !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! ******* TOSTRING SINGLE PRECISION COMPLEX PROCEDURES ******** pure function len_s_cplx ( x , fmt ) result ( wtot ) complex ( sngl ), intent ( in ) :: x character ( * ), intent ( in ) :: fmt integer :: wtot , w , d logical :: gedit character ( nnblk ( fmt ) + 8 ) :: fmt1 call readfmt ( fmt , fmt1 , w , d , gedit ) if ( w < 0 ) then ; wtot = len ( errormsg ); return ; endif wtot = len_f_sngl ([ real ( x )], fmt ) + len_f_sngl ([ abs ( aimag ( x ))], fmt ) + 4 end function len_s_cplx pure function len_f_cplx ( x , fmt ) result ( wtot ) complex ( sngl ), intent ( in ) :: x (:) character ( * ), intent ( in ) :: fmt integer :: wtot , w , d logical :: gedit character ( nnblk ( fmt ) + 8 ) :: fmt1 call readfmt ( fmt , fmt1 , w , d , gedit ) if ( w < 0 ) then ; wtot = len ( errormsg ); return ; endif wtot = len_f_sngl ( real ( x ), fmt ) + len_f_sngl ( abs ( aimag ( x )), fmt ) + size ( x ) * 4 - ( size ( x ) - 1 ) * ( tosset % seplen ) ! subtract seplen because it has been added twice in len_f_sngl end function len_f_cplx function tostring_s_cplx ( x ) result ( st ) complex ( sngl ), intent ( in ) :: x character ( len_s_cplx ( x , tosset % rfmt )) :: st st = tostring_f_cplx ([ x ], tosset % rfmt ) end function tostring_s_cplx function tostring_sf_cplx ( x , fmt ) result ( st ) complex ( sngl ), intent ( in ) :: x character ( * ), intent ( in ) :: fmt character ( len_s_cplx ( x , fmt )) :: st st = tostring_f_cplx ([ x ], fmt ) end function tostring_sf_cplx function tostring_cplx ( x ) result ( st ) complex ( sngl ), intent ( in ) :: x (:) character ( len_f_cplx ( x , tosset % rfmt )) :: st st = tostring_f_cplx ( x , tosset % rfmt ) end function tostring_cplx function tostring_f_cplx ( x , fmt ) result ( st ) complex ( sngl ), intent ( in ) :: x (:) character ( * ), intent ( in ) :: fmt character ( len_f_cplx ( x , fmt )) :: st character ( widthmax_sngl ( real ( x ), fmt )) :: sar ( size ( x )) character ( widthmax_sngl ( abs ( x - real ( x )), fmt )) :: sai ( size ( x )) ! x-real(x) instead of aimag(x) to enable the function character ( 1 ) :: sgn ( size ( x )) ! to pass -stand:f95 switch of the ifort compiler. integer :: w , d , wr , wi , i logical :: gedit character ( nnblk ( fmt ) + 8 ) :: fmt1 !(5 for readfmt and 3 for replace_w) real ( sngl ) :: xre ( size ( x )), xim ( size ( x )), h call readfmt ( fmt , fmt1 , w , d , gedit ) xre = real ( x ) xim = aimag ( x ) h = huge ( h ) if ( w < 0 ) then st = errormsg return elseif ( w == 0 ) then wr = maxw_sngl ( xre , d ) wi = maxw_sngl ( xim , d ) call replace_w ( fmt1 , max ( wr , wi )) endif write ( sar , fmt1 ) real ( x ) write ( sai , fmt1 ) abs ( aimag ( x )) call trim_real ( sar , gedit , w ) call trim_real ( sai , gedit , w ) do i = 1 , size ( x ); if ( aimag ( x ( i )) < 0 ) then ; sgn ( i ) = '-' ; else ; sgn ( i ) = '+' ; endif ; enddo call tostring_get_complex ( sar , sgn , sai , st ) end function tostring_f_cplx ! *************************************** END OF SINGLE PRECISION COMPLEX PROCEDURES ******************************** !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! ************************************* DOUBLE PRECISION PROCEDURES (SEE NOTE 2 BELOW) ****************************** subroutine disp_s_dble ( x , fmt , advance , digmax , sep , trim , unit , zeroas ) ! Double precision scalar without title character ( * ), intent ( in ), optional :: fmt , advance , sep , trim , zeroas real ( dble ), intent ( in ) :: x integer , intent ( in ), optional :: unit , digmax call disp_ts_dble ( '' , x , fmt , advance , digmax , sep , 'left' , trim , unit , zeroas ) end subroutine disp_s_dble subroutine disp_v_dble ( x , fmt , advance , digmax , lbound , sep , style , trim , unit , orient , zeroas ) ! Double precision vector without title character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim , zeroas , orient real ( dble ), intent ( in ) :: x (:) integer , intent ( in ), optional :: unit , lbound (:), digmax call disp_tv_dble ( '' , x , fmt , advance , digmax , lbound , sep , style , trim , unit , orient , zeroas ) end subroutine disp_v_dble subroutine disp_m_dble ( x , fmt , advance , lbound , sep , style , trim , unit , digmax , zeroas ) ! Double precision matrix without title character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim , zeroas real ( dble ), intent ( in ) :: x (:,:) integer , intent ( in ), optional :: unit , digmax , lbound (:) call disp_tm_dble ( '' , x , fmt , advance , digmax , lbound , sep , style , trim , unit , zeroas ) end subroutine disp_m_dble subroutine disp_ts_dble ( title , x , fmt , advance , digmax , sep , style , trim , unit , zeroas ) ! Double precision scalar with title character ( * ), intent ( in ) :: title character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim , zeroas real ( dble ), intent ( in ) :: x integer , intent ( in ), optional :: unit , digmax call disp_tm_dble ( title , reshape ([ x ], [ 1 , 1 ]), fmt , advance , digmax , sep = sep , style = style , trim = trim , & unit = unit , zeroas = zeroas ) end subroutine disp_ts_dble subroutine disp_tv_dble ( title , x , fmt , advance , digmax , lbound , sep , style , trim , unit , orient , zeroas ) ! Double precision vector with title character ( * ), intent ( in ) :: title character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim , zeroas , orient real ( dble ), intent ( in ) :: x (:) integer , intent ( in ), optional :: unit , lbound (:), digmax type ( settings ) :: SE call get_SE ( SE , title , shape ( x ), fmt , advance , lbound , sep , style , trim , unit , orient , zeroas , digmax ) if ( SE % row ) then call disp_dble ( title , reshape ( x , [ 1 , size ( x )]), SE ) else call disp_dble ( title , reshape ( x , [ size ( x ), 1 ]), SE ) endif end subroutine disp_tv_dble subroutine disp_tm_dble ( title , x , fmt , advance , digmax , lbound , sep , style , trim , unit , zeroas ) ! Double precision matrix with title character ( * ), intent ( in ) :: title ! The title to use for the matrix real ( dble ), intent ( in ) :: x (:,:) ! The matrix to be written character ( * ), intent ( in ), optional :: fmt ! Editdit descriptor to use for each matrix element (e.g. 'F5.2') integer , intent ( in ), optional :: unit ! Unit to display on integer , intent ( in ), optional :: digmax ! Nbr of significant digits for largest abs value in x character ( * ), intent ( in ), optional :: advance ! 'No' to print next matrix to right of current, otherwise 'Yes' character ( * ), intent ( in ), optional :: sep ! Separator between matrix columns (e.g. \", \") character ( * ), intent ( in ), optional :: zeroas ! Zeros are replaced with this string if it is not empty character ( * ), intent ( in ), optional :: style ! Style(s): See NOTE 1 below character ( * ), intent ( in ), optional :: trim ! 'Auto' (the default) to trim if fmt absent, 'no' for no !                                                ! trimming, 'yes' for trimming integer , intent ( in ), optional :: lbound (:) ! Lower bounds of x type ( settings ) :: SE ! call get_SE ( SE , title , shape ( x ), fmt , advance , lbound , sep , style , trim , unit , zeroas = zeroas , digmax = digmax ) call disp_dble ( title , x , SE ) end subroutine disp_tm_dble subroutine disp_dble ( title , x , SE ) ! Double precision item character ( * ), intent ( in ) :: title real ( dble ), intent ( in ) :: x (:,:) type ( settings ), intent ( inout ) :: SE integer wid ( size ( x , 2 )), nbl ( size ( x , 2 )) call find_editdesc_dble ( x , SE , wid , nbl ) ! determine also SE % w call tobox_dble ( title , x , SE , wid , nbl ) end subroutine disp_dble subroutine tobox_dble ( title , x , SE , wid , nbl ) ! Write double precision matrix to box character ( * ), intent ( in ) :: title ! title real ( dble ), intent ( in ) :: x (:,:) ! item type ( settings ), intent ( inout ) :: SE ! settings integer , intent ( inout ) :: wid (:) ! widths of columns integer , intent ( inout ) :: nbl (:) ! number of blanks to trim from left character ( SE % w ) :: s ( size ( x , 1 )) integer :: lin1 , j , wleft , m , n , widp ( size ( wid )) character , pointer :: boxp (:,:) real ( dble ) :: xj ( size ( x , 1 )), h m = size ( x , 1 ) n = size ( x , 2 ) h = huge ( x ) call preparebox ( title , SE , m , n , wid , widp , lin1 , wleft , boxp ) do j = 1 , n xj = x (:, j ) if ( m > 0 ) write ( s , SE % ed ) xj call replace_zeronaninf ( s , SE % zas ( 1 : SE % lzas ), xj == 0 , xj /= xj , xj < - h , xj > h ) call copytobox ( s , lin1 , wid ( j ), widp ( j ), nbl ( j ), boxp , wleft ) if ( j < n ) call copyseptobox ( SE % sep ( 1 : SE % lsep ), m , lin1 , boxp , wleft ) enddo call finishbox ( title , SE , boxp ) end subroutine tobox_dble pure function maxw_dble ( x , d ) result ( w ) ! Find max field width needed (F0.d editing is specified) real ( dble ), intent ( in ) :: x (:) integer , intent ( in ) :: d integer expmax , expmin , w logical xfinite ( size ( x )) real ( dble ) xmax , xmin , h character ( 12 ) :: f1 , s ( 2 ) character ( len = :), allocatable :: temp (:) xmin = 0 ; xmax = 0 ; h = huge ( h ) xfinite = x == x . and . x >= - h . and . x <= h ! neither NaN, Inf nor -Inf if (. not . any ( xfinite )) then w = 4 else xmax = maxval ( x , mask = xfinite ) xmin = minval ( x , mask = xfinite ) f1 = '(SS,ES9.0E4)' write ( s , f1 ) xmax , xmin temp = s (:)( 5 : 9 ) read ( temp , '(I5)' ) expmax , expmin w = max ( 0 , expmax , expmin ) + d + 4 endif if (. not . all ( xfinite )) w = max ( w , 4 ) end function maxw_dble subroutine find_editdesc_dble ( x , SE , wid , nbl ) ! Determine SE % ed, SE % w (unless specified) and wid. ! The if-block (*) is for safety: make f wider in case xm is written ok with the ! ES format in fmt but overflows with F format (the feature has been tested through ! manual changes to the program). real ( dble ), intent ( in ) :: x (:,:) ! Item to be written type ( settings ), intent ( inout ) :: SE ! Settings integer , intent ( out ) :: wid ( size ( x , 2 )) ! Widths of individual columns integer , intent ( out ) :: nbl ( size ( x , 2 )) ! Blanks to trim from left of individual columns integer :: expmax , expmin , ww , dd , dmx real ( dble ) xmaxv ( size ( x , 2 )), xminv ( size ( x , 2 )), xp , xm , h character ( 14 ) :: f1 = '(SS,ESxx.xxE4)' ! could be ES99.89E4; default is ES14.05E4 character ( 99 ) s logical xzero ( size ( x , 2 )), xallz ( size ( x , 2 )), xfinite ( size ( x , 1 ), size ( x , 2 )), xnonn ( size ( x , 2 )), xalln ( size ( x , 2 )) ! dmx = SE % dmx h = huge ( h ) xfinite = x == x . and . x >= - h . and . x <= h ! neither NaN, Inf nor -Inf if ( SE % w == 0 ) then ! Edit descriptor 'F0.d' specified ww = maxw_dble ( reshape ( x , [ size ( x )]), SE % d ) if ( SE % lzas > 0 . and . any ( x == 0._dble )) ww = max ( ww , SE % lzas ) call replace_w ( SE % ed , ww ) SE % w = ww elseif ( SE % w < 0 ) then ! No edit descriptor specified if ( size ( x ) == 0 ) then SE % w = 0 wid = 0 nbl = 0 return endif if ( any ( xfinite )) then xp = maxval ( x , mask = xfinite ) xm = minval ( x , mask = xfinite ) write ( f1 ( 7 : 11 ), '(SS,I2,\".\",I2.2)' ) dmx + 8 , dmx - 1 write ( s , f1 ) xp ; read ( s ( dmx + 4 : dmx + 8 ), '(I5)' ) expmax write ( s , f1 ) xm ; read ( s ( dmx + 4 : dmx + 8 ), '(I5)' ) expmin call find_editdesc_real ( expmax , expmin , dmx , SE % ed , ww , dd , xm >= 0 ) if (. not . all ( xfinite )) ww = max ( ww , 4 ) if ( SE % lzas > 0 . and . any ( x == 0._dble )) ww = max ( ww , SE % lzas ) if ( SE % ed ( 5 : 5 ) == 'F' ) then ! (*) write ( s , SE % ed ) xp ; if ( s ( 1 : 1 ) == '*' ) ww = ww + 1 write ( s , SE % ed ) xm ; if ( s ( 1 : 1 ) == '*' ) ww = ww + 1 write ( SE % ed ( 6 : 10 ), '(SS,I2,\".\",I2)' ) ww , dd endif else ww = 4 SE % ed = '(F4.0)' endif SE % w = ww endif if ( SE % trm ) then xmaxv = maxval ( x , 1 , mask = xfinite ) ! max in each column xminv = minval ( x , 1 , mask = xfinite ) ! min xzero = any ( x == 0._dble , 1 ) ! true where column has some zeros xallz = all ( x == 0._dble , 1 ) ! true where column has only zeros xnonn = any ( x > h . or . x < - h . or . x /= x , 1 ) ! true where column has some nonnormals (inf, -inf, nan) xalln = all ( x > h . or . x < - h . or . x /= x , 1 ) ! true where column has only nonnormals (inf, -inf, nan) call getwid_dble ( xmaxv , xminv , xzero , xallz , xnonn , xalln , SE , wid , nbl ) else wid = SE % w nbl = 0 endif end subroutine find_editdesc_dble subroutine getwid_dble ( xmaxv , xminv , xzero , xallz , xnonn , xalln , SE , wid , nbl ) ! determine length of the strings that result when writing with edit descriptor SE%ed a ! vector v where v(i) is xmaxv(i) or xminv(i) depending on which gives longer output real ( dble ), intent ( in ) :: xmaxv (:), xminv (:) ! max and min values in each column logical , intent ( in ) :: xzero (:), xallz (:) ! true for columns with some/all zeros logical , intent ( in ) :: xnonn (:), xalln (:) ! true for columns with some/all nonnormals type ( settings ), intent ( in ) :: SE ! settings integer , intent ( out ) :: wid (:) ! widths of columns integer , intent ( out ) :: nbl (:) ! number of blanks to peel from left (w-wid) character ( SE % w ) :: stmax ( size ( xmaxv )), stmin ( size ( xminv )) integer w , iostat w = SE % w write ( stmin , SE % ed , iostat = iostat ) xminv write ( stmax , SE % ed , iostat = iostat ) xmaxv nbl = mod ( verify ( stmin , ' ' ) + w , w + 1 ) ! loc. of first nonblank nbl = min ( nbl , mod ( verify ( stmax , ' ' ) + w , w + 1 )) if ( SE % gedit ) then wid = w else wid = len_trim ( adjustl ( stmin )) wid = max ( wid , len_trim ( adjustl ( stmax ))) endif if ( SE % lzas > 0 ) then wid = merge ( SE % lzas , wid , xallz ) wid = max ( wid , merge ( SE % lzas , 0 , xzero )) endif wid = merge ( 4 , wid , xalln ) wid = max ( wid , merge ( 4 , 0 , xnonn )) nbl = w - wid end subroutine getwid_dble !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! ******** TOSTRING DOUBLE PRECISION PROCEDURES *********** pure function widthmax_dble ( x , fmt ) result ( w ) ! Maximum width of an element of x real ( dble ), intent ( in ) :: x (:) character ( * ), intent ( in ) :: fmt character ( nnblk ( fmt ) + 5 ) :: fmt1 integer w , d logical gedit call readfmt ( fmt , fmt1 , w , d , gedit ) if ( w < 0 ) then ! illegal format, use 1 w = 1 elseif ( w == 0 ) then w = maxw_dble ( x , d ) endif end function widthmax_dble pure function len_f_dble ( x , fmt ) result ( wtot ) ! Total length of returned string, vector s real ( dble ), intent ( in ) :: x (:) character ( * ), intent ( in ) :: fmt character ( widthmax_dble ( x , fmt )) :: sa ( size ( x )) integer :: wtot , w , d , ww logical :: gedit character ( nnblk ( fmt ) + 8 ) :: fmt1 !(5 for readfmt and 3 for replace_w) call readfmt ( fmt , fmt1 , w , d , gedit ) if ( w < 0 ) then ; wtot = len ( errormsg ); return ; endif if ( w == 0 ) then ww = maxw_dble ( x , d ) call replace_w ( fmt1 , ww ) endif write ( sa , fmt1 ) x call trim_real ( sa , gedit , w ) wtot = sum ( len_trim ( sa )) + ( size ( x ) - 1 ) * ( tosset % seplen ) end function len_f_dble function tostring_s_dble ( x ) result ( st ) ! Scalar to string real ( dble ), intent ( in ) :: x character ( len_f_dble ([ x ], tosset % rfmt )) :: st st = tostring_f_dble ([ x ], tosset % rfmt ) end function tostring_s_dble function tostring_sf_dble ( x , fmt ) result ( st ) ! Scalar with specified format to string real ( dble ), intent ( in ) :: x character ( * ), intent ( in ) :: fmt character ( len_f_dble ([ x ], fmt )) :: st st = tostring_f_dble ([ x ], fmt ) end function tostring_sf_dble function tostring_dble ( x ) result ( st ) ! Vector to string real ( dble ), intent ( in ) :: x (:) character ( len_f_dble ( x , tosset % rfmt )) :: st st = tostring_f_dble ( x , tosset % rfmt ) end function tostring_dble function tostring_f_dble ( x , fmt ) result ( st ) ! Vector with specified format to string real ( dble ) , intent ( in ) :: x (:) character ( * ), intent ( in ) :: fmt character ( len_f_dble ( x , fmt )) :: st character ( widthmax_dble ( x , fmt )) :: sa ( size ( x )) character ( nnblk ( fmt ) + 8 ) :: fmt1 !(5 for readfmt and 3 for replace_w) integer :: w , d , ww logical :: gedit call readfmt ( fmt , fmt1 , w , d , gedit ) if ( w < 0 ) then st = errormsg return elseif ( w == 0 ) then ww = maxw_dble ( x , d ) call replace_w ( fmt1 , ww ) endif write ( sa , fmt1 ) x call trim_real ( sa , gedit , w ) call tostring_get ( sa , st ) end function tostring_f_dble ! *************************************** END OF DOUBLE PRECISION PROCEDURES *************************************** !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! *************************************** DOUBLE PRECISION COMPLEX PROCEDURES ************************************** subroutine disp_s_cpld ( x , fmt , fmt_imag , advance , digmax , sep , trim , unit ) ! double precision complex scalar without title character ( * ), intent ( in ), optional :: fmt , fmt_imag , advance , sep , trim complex ( dble ), intent ( in ) :: x integer , intent ( in ), optional :: unit , digmax call disp_ts_cpld ( '' , x , fmt , fmt_imag , advance , digmax , sep , 'left' , trim , unit ) end subroutine disp_s_cpld subroutine disp_v_cpld ( x , fmt , fmt_imag , advance , digmax , lbound , sep , style , trim , unit , orient ) ! double precision complex vector without title character ( * ), intent ( in ), optional :: fmt , fmt_imag , advance , sep , style , trim , orient complex ( dble ), intent ( in ) :: x (:) integer , intent ( in ), optional :: unit , lbound (:), digmax call disp_tv_cpld ( '' , x , fmt , fmt_imag , advance , digmax , lbound , sep , style , trim , unit , orient ) end subroutine disp_v_cpld subroutine disp_m_cpld ( x , fmt , fmt_imag , advance , digmax , lbound , sep , style , trim , unit ) ! double precision complex matrix without title character ( * ), intent ( in ), optional :: fmt , fmt_imag , advance , sep , style , trim complex ( dble ), intent ( in ) :: x (:,:) integer , intent ( in ), optional :: unit , digmax , lbound (:) call disp_tm_cpld ( '' , x , fmt , fmt_imag , advance , digmax , lbound , sep , style , trim , unit ) end subroutine disp_m_cpld subroutine disp_ts_cpld ( title , x , fmt , fmt_imag , advance , digmax , sep , style , trim , unit ) ! double precision complex scalar with title character ( * ), intent ( in ) :: title character ( * ), intent ( in ), optional :: fmt , fmt_imag , advance , sep , style , trim complex ( dble ), intent ( in ) :: x integer , intent ( in ), optional :: unit , digmax call disp_tm_cpld ( title , reshape ([ x ], [ 1 , 1 ]), fmt , fmt_imag , advance , digmax , sep = sep , style = style , & trim = trim , unit = unit ) end subroutine disp_ts_cpld subroutine disp_tv_cpld ( title , x , fmt , fmt_imag , advance , digmax , lbound , sep , style , trim , unit , orient ) ! double precision complex vector with title character ( * ), intent ( in ) :: title character ( * ), intent ( in ), optional :: fmt , fmt_imag , advance , sep , style , trim , orient complex ( dble ), intent ( in ) :: x (:) integer , intent ( in ), optional :: unit , lbound (:), digmax type ( settings ) SE , SEim call get_SE ( SE , title , shape ( x ), fmt , advance , lbound , sep , style , trim , unit , orient , digmax = digmax ) if ( present ( fmt_imag )) then if (. not . present ( fmt )) then call disp_errmsg ( 'DISP: error, FMT must be present if FMT_IMAG is present' ); return ; endif call get_SE ( SEim , title , shape ( x ), fmt_imag ) else SEim = SE endif if ( SE % row ) then call disp_cpld ( title , reshape ( x , [ 1 , size ( x )]), SE , SEim , n = size ( x )) else call disp_cpld ( title , reshape ( x , [ size ( x ), 1 ]), SE , SEim , n = 1 ) endif end subroutine disp_tv_cpld subroutine disp_tm_cpld ( title , x , fmt , fmt_imag , advance , digmax , lbound , sep , style , trim , unit ) ! double precision complex matrix with title character ( * ), intent ( in ) :: title ! The title to use for the matrix complex ( dble ), intent ( in ) :: x (:,:) ! The matrix to be written character ( * ), intent ( in ), optional :: fmt ! Edit descriptor for each element (real element when fmt_imag & !                                                ! is present) character ( * ), intent ( in ), optional :: fmt_imag ! Edit descriptor for each imaginary element integer , intent ( in ), optional :: unit ! Unit to display on integer , intent ( in ), optional :: digmax ! Nbr of significant digits for largest abs value in real(x) & !                                                ! and aimag(x) character ( * ), intent ( in ), optional :: advance ! 'No' to print next matrix to right of current, otherwise 'Yes' character ( * ), intent ( in ), optional :: sep ! Separator between matrix columns (e.g. \", \") character ( * ), intent ( in ), optional :: style ! Style(s): See NOTE 1 below character ( * ), intent ( in ), optional :: trim ! 'Auto' (the default) to trim if fmt absent, 'no' for no !                                                ! trimming, 'yes' for trimming integer , intent ( in ), optional :: lbound (:) ! Lower bounds of x ! type ( settings ) :: SE , SEim call get_SE ( SE , title , shape ( x ), fmt , advance , lbound , sep , style , trim , unit , digmax = digmax ) if ( present ( fmt_imag )) then if (. not . present ( fmt )) then call disp_errmsg ( 'DISP: error, FMT must be present if FMT_IMAG is present' ); return endif call get_SE ( SEim , title , shape ( x ), fmt_imag ) else SEim = SE endif call disp_cpld ( title , x , SE , SEim , n = size ( x , 2 )) end subroutine disp_tm_cpld subroutine disp_cpld ( title , x , SE , SEim , n ) ! Double precision item character ( * ), intent ( in ) :: title complex ( dble ), intent ( in ) :: x (:,:) type ( settings ), intent ( inout ) :: SE , SEim integer , intent ( in ) :: n integer , dimension ( n ) :: widre ( n ), widim ( n ), nblre ( n ), nblim ( n ) call find_editdesc_dble ( real ( x ), SE , widre , nblre ) ! determine also SE % w call find_editdesc_dble ( abs ( aimag ( x )), SEim , widim , nblim ) ! determine also SEim % w call tobox_cpld ( title , x , SE , SEim , widre , widim , nblre , nblim , m = size ( x , 1 ), n = size ( x , 2 )) end subroutine disp_cpld subroutine tobox_cpld ( title , x , SE , SEim , widre , widim , nblre , nblim , m , n ) ! Write double precision complex matrix to box character ( * ), intent ( in ) :: title complex ( dble ), intent ( in ) :: x (:,:) integer , intent ( in ) :: m , n , widre (:), widim (:), nblre (:), nblim (:) type ( settings ), intent ( inout ) :: SE , SEim character ( SE % w ) :: s ( m ) character ( SEim % w ) :: sim ( m ) character ( 3 ) :: sgn ( m ) integer :: lin1 , i , j , wleft , wid ( n ), widp ( n ) character , pointer :: boxp (:,:) SE % zas = '' SEim % zas = '' wid = widre + widim + 4 call preparebox ( title , SE , m , n , wid , widp , lin1 , wleft , boxp ) do j = 1 , n if ( m > 0 ) write ( s , SE % ed ) ( real ( x ( i , j )), i = 1 , m ) call copytobox ( s , lin1 , widre ( j ), widp ( j ) - widim ( j ) - 4 , nblre ( j ), boxp , wleft ) do i = 1 , m if ( aimag ( x ( i , j )) < 0 ) then ; sgn ( i ) = ' - ' ; else ; sgn ( i ) = ' + ' ; endif enddo call copytobox ( sgn , lin1 , 3 , 3 , 0 , boxp , wleft ) if ( m > 0 ) write ( sim , SEim % ed ) ( abs ( aimag ( x ( i , j ))), i = 1 , m ) call copytobox ( sim , lin1 , widim ( j ), widim ( j ), nblim ( j ), boxp , wleft ) call copyseptobox ( 'i' , m , lin1 , boxp , wleft ) if ( j < n ) call copyseptobox ( SE % sep ( 1 : SE % lsep ), m , lin1 , boxp , wleft ) enddo call finishbox ( title , SE , boxp ) end subroutine tobox_cpld !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! ******* TOSTRING DOUBLE PRECISION COMPLEX PROCEDURES ******** pure function len_s_cpld ( x , fmt ) result ( wtot ) complex ( dble ), intent ( in ) :: x character ( * ), intent ( in ) :: fmt integer :: wtot , w , d logical :: gedit character ( nnblk ( fmt ) + 8 ) :: fmt1 call readfmt ( fmt , fmt1 , w , d , gedit ) if ( w < 0 ) then ; wtot = len ( errormsg ); return ; endif wtot = len_f_dble ([ real ( x )], fmt ) + len_f_dble ([ abs ( aimag ( x ))], fmt ) + 4 end function len_s_cpld pure function len_f_cpld ( x , fmt ) result ( wtot ) complex ( dble ), intent ( in ) :: x (:) character ( * ), intent ( in ) :: fmt integer :: wtot , w , d logical :: gedit character ( nnblk ( fmt ) + 8 ) :: fmt1 call readfmt ( fmt , fmt1 , w , d , gedit ) if ( w < 0 ) then ; wtot = len ( errormsg ); return ; endif wtot = len_f_dble ( real ( x ), fmt ) + len_f_dble ( abs ( aimag ( x )), fmt ) + size ( x ) * 4 - ( size ( x ) - 1 ) * ( tosset % seplen ) ! subtract seplen because it has been added twice in len_f_dble end function len_f_cpld function tostring_s_cpld ( x ) result ( st ) complex ( dble ), intent ( in ) :: x character ( len_s_cpld ( x , tosset % rfmt )) :: st st = tostring_f_cpld ([ x ], tosset % rfmt ) end function tostring_s_cpld function tostring_sf_cpld ( x , fmt ) result ( st ) complex ( dble ), intent ( in ) :: x character ( * ), intent ( in ) :: fmt character ( len_s_cpld ( x , fmt )) :: st st = tostring_f_cpld ([ x ], fmt ) end function tostring_sf_cpld function tostring_cpld ( x ) result ( st ) complex ( dble ), intent ( in ) :: x (:) character ( len_f_cpld ( x , tosset % rfmt )) :: st st = tostring_f_cpld ( x , tosset % rfmt ) end function tostring_cpld function tostring_f_cpld ( x , fmt ) result ( st ) complex ( dble ), intent ( in ) :: x (:) character ( * ), intent ( in ) :: fmt character ( len_f_cpld ( x , fmt )) :: st character ( widthmax_dble ( real ( x ), fmt )) :: sar ( size ( x )) character ( widthmax_dble ( abs ( x - real ( x )), fmt )) :: sai ( size ( x )) ! x-real(x) instead of aimag(x) to enable the function character ( 1 ) :: sgn ( size ( x )) ! to pass -stand:f95 switch of the ifort compiler. integer :: w , d , wr , wi , i logical :: gedit character ( nnblk ( fmt ) + 8 ) :: fmt1 !(5 for readfmt and 3 for replace_w) real ( dble ) :: xre ( size ( x )), xim ( size ( x )), h call readfmt ( fmt , fmt1 , w , d , gedit ) xre = real ( x ) xim = aimag ( x ) h = huge ( h ) if ( w < 0 ) then st = errormsg return elseif ( w == 0 ) then wr = maxw_dble ( xre , d ) wi = maxw_dble ( xim , d ) call replace_w ( fmt1 , max ( wr , wi )) endif write ( sar , fmt1 ) real ( x ) write ( sai , fmt1 ) abs ( aimag ( x )) call trim_real ( sar , gedit , w ) call trim_real ( sai , gedit , w ) do i = 1 , size ( x ); if ( aimag ( x ( i )) < 0 ) then ; sgn ( i ) = '-' ; else ; sgn ( i ) = '+' ; endif ; enddo call tostring_get_complex ( sar , sgn , sai , st ) end function tostring_f_cpld ! *************************************** END OF DOUBLE PRECISION COMPLEX PROCEDURES ******************************** !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! ********************************************** DEFAULT LOGICAL PROCEDURES ***************************************** subroutine disp_s_dlog ( x , fmt , advance , sep , trim , unit ) ! Default logical scalar without title character ( * ), intent ( in ), optional :: fmt , advance , sep , trim logical ( dlog ), intent ( in ) :: x integer , intent ( in ), optional :: unit call disp_ts_dlog ( '' , x , fmt , advance , sep , 'left' , trim , unit ) end subroutine disp_s_dlog subroutine disp_v_dlog ( x , fmt , advance , lbound , sep , style , trim , unit , orient ) ! Default logical vector without title character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim , orient logical ( dlog ), intent ( in ) :: x (:) integer , intent ( in ), optional :: unit , lbound (:) call disp_tv_dlog ( '' , x , fmt , advance , lbound , sep , style , trim , unit , orient ) end subroutine disp_v_dlog subroutine disp_m_dlog ( x , fmt , advance , lbound , sep , style , trim , unit ) ! Default logical matrix without title character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim logical ( dlog ), intent ( in ) :: x (:,:) integer , intent ( in ), optional :: unit , lbound (:) call disp_tm_dlog ( '' , x , fmt , advance , lbound , sep , style , trim , unit ) end subroutine disp_m_dlog subroutine disp_ts_dlog ( title , x , fmt , advance , sep , style , trim , unit ) ! Default logical scalar with title character ( * ), intent ( in ) :: title character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim logical ( dlog ), intent ( in ) :: x integer , intent ( in ), optional :: unit call disp_tm_dlog ( title , reshape ([ x ], [ 1 , 1 ]), fmt , advance , sep = sep , style = style , trim = trim , unit = unit ) end subroutine disp_ts_dlog subroutine disp_tv_dlog ( title , x , fmt , advance , lbound , sep , style , trim , unit , orient ) ! Default logical vector with title character ( * ), intent ( in ) :: title character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim , orient logical ( dlog ), intent ( in ) :: x (:) integer , intent ( in ), optional :: unit , lbound (:) type ( settings ) :: SE call get_SE ( SE , title , shape ( x ), fmt , advance , lbound , sep , style , trim , unit , orient ) if ( SE % row ) then call disp_dlog ( title , reshape ( x , [ 1 , size ( x )]), SE ) else call disp_dlog ( title , reshape ( x , [ size ( x ), 1 ]), SE ) endif end subroutine disp_tv_dlog subroutine disp_tm_dlog ( title , x , fmt , advance , lbound , sep , style , trim , unit ) ! Default logical matrix with title character ( * ), intent ( in ) :: title ! The title to use for the matrix logical ( dlog ), intent ( in ) :: x (:,:) ! The matrix to be written character ( * ), intent ( in ), optional :: fmt ! Format edit descriptor to use for each matrix element (e.g. 'L1') integer , intent ( in ), optional :: unit ! Unit to display on character ( * ), intent ( in ), optional :: advance ! 'No' to print next matrix to right of current, otherwise 'Yes' character ( * ), intent ( in ), optional :: sep ! Separator between matrix columns (e.g. \", \") character ( * ), intent ( in ), optional :: style ! Style(s): See NOTE 1 below character ( * ), intent ( in ), optional :: trim ! 'Auto' (the default) to trim if fmt absent, 'no' for no trimming, !                                               ! 'yes' for trimming integer , intent ( in ), optional :: lbound (:) ! Lower bounds of x type ( settings ) :: SE ! call get_SE ( SE , title , shape ( x ), fmt , advance , lbound , sep , style , trim , unit ) call disp_dlog ( title , x , SE ) end subroutine disp_tm_dlog subroutine disp_dlog ( title , x , SE ) ! Write default logical to box or unit character ( * ), intent ( in ) :: title logical ( dlog ), intent ( in ) :: x (:,:) type ( settings ), intent ( inout ) :: SE integer wid ( size ( x , 2 )), nbl ( size ( x , 2 )) if ( SE % w <= 0 . or . SE % trm ) then SE % ed = '(L1)' if ( size ( x ) == 0 ) then wid = 0 else wid = 1 endif SE % w = 1 nbl = SE % w - wid else wid = SE % w nbl = 0 endif call tobox_dlog ( title , x , SE , wid , nbl ) end subroutine disp_dlog subroutine tobox_dlog ( title , x , SE , wid , nbl ) character ( * ), intent ( in ) :: title logical ( dlog ), intent ( in ) :: x (:,:) type ( settings ), intent ( inout ) :: SE integer , intent ( inout ) :: wid (:) integer , intent ( inout ) :: nbl (:) character ( SE % w ) :: s ( size ( x , 1 )) integer :: m , n , lin1 , i , j , wleft , widp ( size ( wid )) character , pointer :: boxp (:,:) m = size ( x , 1 ) n = size ( x , 2 ) call preparebox ( title , SE , m , n , wid , widp , lin1 , wleft , boxp ) do j = 1 , n if ( m > 0 ) write ( s , SE % ed ) ( x ( i , j ), i = 1 , m ) call copytobox ( s , lin1 , wid ( j ), widp ( j ), nbl ( j ), boxp , wleft ) if ( j < n ) call copyseptobox ( SE % sep ( 1 : SE % lsep ), m , lin1 , boxp , wleft ) enddo call finishbox ( title , SE , boxp ) end subroutine tobox_dlog ! ********** DEFAULT LOGICAL TOSTRING PROCEDURES ********* pure function len_f_dlog ( x , fmt ) result ( wtot ) logical ( dlog ), intent ( in ) :: x (:) character ( * ), intent ( in ) :: fmt integer :: wtot , w , d logical :: gedit character ( nnblk ( fmt ) + 5 ) :: fmt1 call readfmt ( fmt , fmt1 , w , d , gedit ) if ( w <= 0 ) then ; wtot = len ( errormsg ); return ; endif if ( tosset % trimb == 'YES' ) wtot = size ( x ) if ( tosset % trimb == 'NO' ) wtot = w * size ( x ) wtot = wtot + ( size ( x ) - 1 ) * ( tosset % seplen ) end function len_f_dlog pure function widthmax_dlog ( fmt ) result ( w ) character ( * ), intent ( in ) :: fmt integer w , d logical gedit character ( nnblk ( fmt ) + 5 ) :: fmt1 call readfmt ( fmt , fmt1 , w , d , gedit ) if ( w <= 0 ) w = 1 end function widthmax_dlog function tostring_s_dlog ( x ) result ( st ) logical ( dlog ), intent ( in ) :: x character ( 1 ) :: st st = tostring_f_dlog ([ x ], 'L1' ) end function tostring_s_dlog function tostring_sf_dlog ( x , fmt ) result ( st ) logical ( dlog ), intent ( in ) :: x character ( * ), intent ( in ) :: fmt character ( len_f_dlog ([ x ], fmt )) :: st st = tostring_f_dlog ([ x ], fmt ) end function tostring_sf_dlog function tostring_dlog ( x ) result ( st ) logical ( dlog ), intent ( in ) :: x (:) character ( 1 + ( size ( x ) - 1 ) * ( 1 + tosset % seplen )) :: st st = tostring_f_dlog ( x , 'L1' ) end function tostring_dlog function tostring_f_dlog ( x , fmt ) result ( st ) logical ( dlog ), intent ( in ) :: x (:) character ( * ), intent ( in ) :: fmt character ( len_f_dlog ( x , fmt )) :: st character ( widthmax_dlog ( fmt )) :: sa ( size ( x )) integer :: w , d logical :: gedit character ( nnblk ( fmt ) + 5 ) :: fmt1 call readfmt ( fmt , fmt1 , w , d , gedit ) if ( w <= 0 ) then ; st = errormsg ; return ; endif write ( sa , fmt1 ) x if ( tosset % trimb == 'YES' ) sa = adjustl ( sa ) call tostring_get ( sa , st ) end function tostring_f_dlog ! ****************************** END OF DEFAULT LOGICAL PROCEDURES ******************************* ! ******************************* DEFAULT CHARACTER PROCEDURES ********************************** subroutine disp_v_dchr ( x , fmt , advance , lbound , sep , style , trim , unit , orient ) ! Default character vector without title character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim , orient character ( * ), intent ( in ) :: x (:) integer , intent ( in ), optional :: unit , lbound (:) call disp_tv_dchr ( '' , x , fmt , advance , lbound , sep , style , trim , unit , orient ) end subroutine disp_v_dchr subroutine disp_m_dchr ( x , fmt , advance , lbound , sep , style , trim , unit ) ! Default character matrix without title character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim character ( * ), intent ( in ) :: x (:,:) integer , intent ( in ), optional :: unit , lbound (:) call disp_tm_dchr ( '' , x , fmt , advance , lbound , sep , style , trim , unit ) end subroutine disp_m_dchr subroutine disp_ts_dchr ( title , x , fmt , advance , sep , style , trim , unit ) ! Default character scalar with title character ( * ), intent ( in ), optional :: title , x , fmt , advance , sep , style , trim character ( 0 ) empty ( 1 , 0 ) integer , intent ( in ), optional :: unit empty = '' if ( present ( title ). and . present ( x )) then call disp_nonopt_dchr ( title , x , fmt , advance , sep = sep , style = style , trim = trim , unit = unit ) elseif ( present ( x )) then call disp_nonopt_dchr ( '' , x , fmt , advance , sep = sep , style = 'left' , trim = trim , unit = unit ) elseif ( present ( title )) then call disp_nonopt_dchr ( '' , title , fmt , advance , sep = sep , style = 'left' , trim = trim , unit = unit ) else call disp_tm_dchr ( '' , empty , fmt , advance , sep = sep , style = style , trim = trim , unit = unit ) endif end subroutine disp_ts_dchr subroutine disp_nonopt_dchr ( title , x , fmt , advance , sep , style , trim , unit ) ! This routine exists to circumvent bug in gfortran, that made it not possible to change scalar strings ! to matrices with reshape in calls of disp_tm_dchr. This intermediate routine provides work-around. character ( * ), intent ( in ) :: title , x , fmt , advance , sep , style , trim optional fmt , advance , sep , style , trim integer , intent ( in ), optional :: unit character ( len ( x )) :: xm ( 1 , 1 ) xm ( 1 , 1 ) = x call disp_tm_dchr ( title , xm , fmt , advance , sep = sep , style = style , trim = trim , unit = unit ) end subroutine disp_nonopt_dchr subroutine disp_tv_dchr ( title , x , fmt , advance , lbound , sep , style , trim , unit , orient ) ! Default character vector with title character ( * ), intent ( in ) :: title , x (:) character ( * ), intent ( in ), optional :: fmt , advance , sep , style , trim , orient integer , intent ( in ), optional :: unit , lbound (:) type ( settings ) :: SE call get_SE ( SE , title , shape ( x ), fmt , advance , lbound , sep , style , trim , unit , orient ) if ( SE % row ) then call disp_dchr ( title , reshape ( x , [ 1 , size ( x )]), SE ) else call disp_dchr ( title , reshape ( x , [ size ( x ), 1 ]), SE ) endif end subroutine disp_tv_dchr subroutine disp_tm_dchr ( title , x , fmt , advance , lbound , sep , style , trim , unit ) ! Default character matrix with title character ( * ), intent ( in ) :: title ! The title to use for the matrix character ( * ), intent ( in ) :: x (:,:) ! The matrix to be written character ( * ), intent ( in ), optional :: fmt ! Format edit descriptor to use for each matrix element (e.g.'A4') integer , intent ( in ), optional :: unit ! Unit to display on character ( * ), intent ( in ), optional :: advance ! 'No' to print next matrix to right of current, otherwise 'Yes' character ( * ), intent ( in ), optional :: sep ! Separator between matrix columns (e.g. \", \") character ( * ), intent ( in ), optional :: style ! Style(s): see NOTE 1 below character ( * ), intent ( in ), optional :: trim ! 'Auto' (the default) to trim if fmt absent, 'no' for no !                                                ! trimming, 'yes' for trimming integer , intent ( in ), optional :: lbound (:) ! Lower bounds of x ! type ( settings ) :: SE call get_SE ( SE , title , shape ( x ), fmt , advance , lbound , sep , style , trim , unit ) call disp_dchr ( title , x , SE ) end subroutine disp_tm_dchr subroutine disp_dchr ( title , x , SE ) ! Default character item to box character ( * ), intent ( in ) :: title , x (:,:) type ( settings ), intent ( inout ) :: SE character ( 13 ) :: edesc character , pointer :: boxp (:,:) integer :: m , n , j , lin1 , wleft , lx , w integer , dimension ( size ( x , 2 )) :: wid , nbl , n1 , n2 , widp m = size ( x , 1 ) n = size ( x , 2 ) lx = len ( x ) w = SE % w if ( w <= 0 ) then w = lx if ( w < 0 ) then edesc = '(A__________)' write ( edesc ( 3 : 12 ), '(SS,I10)' ) w SE % ed = edesc endif endif if ( SE % trm . and . size ( x ) > 0 ) then n1 = minval ( mod ( verify ( x , ' ' ) - w - 1 , w + 1 ), 1 ) + w + 1 n2 = maxval ( verify ( x , ' ' , back = . true .), 1 ) wid = n2 - n1 + 1 nbl = w - wid else n1 = 1 n2 = w wid = w nbl = 0 endif if ( all ( wid == 0 )) n = 0 SE % w = w call preparebox ( title , SE , m , n , wid , widp , lin1 , wleft , boxp ) do j = 1 , n if ( SE % trm ) then call copytobox ( ( x (:, j )( n1 ( j ): n2 ( j ))), lin1 , wid ( j ), widp ( j ), nbl ( j ), boxp , wleft ) else if ( widp ( j ) > lx ) call copyseptobox ( repeat ( ' ' , widp ( j ) - lx ), m , lin1 , boxp , wleft ) call copytobox ( x (:, j ), lin1 , lx , lx , 0 , boxp , wleft ) endif if ( j < n ) call copyseptobox ( SE % sep ( 1 : SE % lsep ), m , lin1 , boxp , wleft ) enddo call finishbox ( title , SE , boxp ) end subroutine disp_dchr ! ************************* END OF DEFAULT CHARACTER PROCEDURES ******************************** ! NOTE 1: STYLES !   Styles can be LEFT, ABOVE, PAD, UNDERLINE or NUMBER. Padding is by default done with hyphen !   characters (e.g. ---title---), but can be changed for example to asterisks with style='*PAD'. !   Underlining is also with hyphens and can also be changed, e.g. with style='*UNDERLINE'. Lower !   or mixed case is acceptable: style='above' or style='Above'. It is also possible to specify !   both NUMBER and one of the other styles, with e.g. style='ABOVE & NUMBER'. ! ! NOTE 2: DOUBLE PRECISION !   The double precision functions and subroutines above (the sections marked DOUBLE PRECISION !   PROCEDURES and DOUBLE PRECISION COMPLEX PROCEDURES) are copies of the sections marked SINGLE !   PRECISION PROCEDURES and SINGLE PRECISION COMPLEX PROCEDURES, with the kind parameter sngl !   changed to dble, the procedure name suffixes _sngl and _cplx changed to _dble and _cpld, and !   single changed to double (only appears in comments). The add-on module DISP_R16MOD is another !   copy of these procedures (for quad precision). ! Something to do an HTML table !   <table BORDER=\"1\"> !     <tr><td> !     AAA</td><td> AAA</td><td> AAA</td><td> AAA</td><td> AAA</td><td> AAA</td><td> AAA</td><td> AAA</td><td> AAA !     </td></tr> !   </table> ! option for row suffix and prefix, maybe as elements of SEP=[ \",\", \"[\", \"]\" ] ! [ 1,2,3 ] ! [ 4,5,6 ] ! output negative values as (val) instead of -val, which is common in financial tables !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== END MODULE M_display !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !===================================================================================================================================","tags":"","url":"sourcefile/m_display.f90.html"},{"title":"test_naninf.f90 – M_display","text":"Source Code PROGRAM TEST_NANINF ! PROGRAM TO TEST DISPLAY OF NOT-A-NUMBER-S AND INFINITIES BY M_display ! (Appropriate for compilers that support IEEE-arithmetic as described in the Fortran 2003 standard) USE TEST_NANINF_MOD ! USE DISP_R16MOD ! uncomment this line if testing of disp_r16mod (quad precision) is required ! ! Copyright (c) 2008, Kristj n J nasson, Dept. of Computer Science, University of ! Iceland (jonasson@hi.is). This software is free. For details see the file README. implicit none real ( srk ) :: zero = 0._srk , big = 1.e20 , nan , inf , minf nan = zero / zero inf = exp ( big ) minf = - inf call test_ni ( nan , inf , minf ) END PROGRAM TEST_NANINF","tags":"","url":"sourcefile/test_naninf.f90.html"},{"title":"test_naninf_mod.f90 – M_display","text":"Source Code MODULE TEST_NANINF_MOD implicit none integer , parameter :: verbose = 0 ! 0 = quiet !                                  ! 1 = report only names of test routines !                                  ! 2 = report also what the tests display integer , parameter :: srk = kind ( 0 d0 ) integer :: compare_no = 0 character ( 30 ) :: assert_string = '' character ( 3 ) :: adv = 'no' character ( 90 ) :: fmt = '(\"  Testing display of nan and -inf and inf, real kind=\",I0,\"...\")' CONTAINS subroutine test_ni ( nan , inf , minf ) USE M_display !use, intrinsic :: ieee_arithmetic real ( srk ), intent ( in ) :: nan , inf , minf real ( srk ) :: & zero = 0._srk , & d1 ( 3 , 2 ) = reshape (( /- 2.146_srk , 0._srk , 1._srk , 0._srk , 2 0.33_srk , 0._srk / ), ( / 3 , 2 / )), & d2 ( 2 ) = ( / 0._srk , 0._srk / ), & d3 ( 2 ) = ( / 1 2e20_srk , 0._srk / ), & d4 = 0._srk logical :: mask1 ( 3 , 2 ), mask2 ( 2 ), mask3 ( 2 ) character ( 12 ) :: s1 ( 3 ) character ( 9 ) :: s2 ( 1 ) character ( 16 ) :: s3 ( 2 ) character ( 9 ) :: s4 ( 2 ) ! call open_8 if ( verbose > 0 ) adv = 'yes' write ( * , fmt , advance = adv ) srk mask1 = d1 == zero mask2 = d2 == zero mask3 = d3 == zero d1 = merge ( nan , d1 , mask1 ) d2 = merge ( nan , d2 , mask2 ) d3 = merge ( nan , d3 , mask3 ) d4 = nan ! s1 = ( / '-2.15    NaN' ,& & '  NaN  20.33' ,& & ' 1.00    NaN' / ) ! s2 = ' NaN, NaN' ! s3 ( 1 ) = 'A = 1.20000E+21' s3 ( 2 ) = '            NaN' ! s4 ( 1 ) = 'Longtitle' s4 ( 2 ) = '   NaN   ' ! call assert_init ( 'TEST_NAN' ) call disp_set ( unit = 8 , style = 'PAD' ) call disp ( d1 , digmax = 4 ); call compare ( s1 , 'NaN-1' ) call disp ( d1 , digmax = 4 , zeroas = '0.' ); call compare ( s1 , 'NaN-1' ) call disp ( d2 , sep = ',' , orient = 'row' ); call compare ( s2 , 'NaN-2' ) call disp ( 'A = ' , d3 , style = 'left' ); call compare ( s3 , 'NaN-3' ) call disp ( 'Longtitle' , d4 ); call compare ( s4 , 'NaN-4' ) d1 = merge ( inf , d1 , mask1 ) d2 = merge ( inf , d2 , mask2 ) d3 = merge ( inf , d3 , mask3 ) d4 = inf s1 ( 1 ) = '-2.15   +Inf' s1 ( 2 ) = ' +Inf  20.33' s1 ( 3 ) = ' 1.00   +Inf' s2 = '+Inf,+Inf' s3 ( 2 ) = '           +Inf' s4 ( 2 ) = '  +Inf   ' call disp ( d1 , digmax = 4 ); call compare ( s1 , 'Inf-1' ) call disp ( d1 , digmax = 4 , zeroas = '0.' ); call compare ( s1 , 'Inf-1' ) call disp ( d2 , sep = ',' , orient = 'row' ); call compare ( s2 , 'Inf-2' ) call disp ( 'A = ' , d3 , style = 'left' ); call compare ( s3 , 'Inf-3' ) call disp ( 'Longtitle' , d4 ); call compare ( s4 , 'Inf-4' ) d1 ( 1 ,:) = merge ( minf , d1 ( 1 ,:), mask1 ( 1 ,:)) d1 ( 2 ,:) = merge ( nan , d1 ( 2 ,:), mask1 ( 2 ,:)) d1 ( 3 ,:) = merge ( inf , d1 ( 3 ,:), mask1 ( 3 ,:)) d2 = merge ( minf , d2 , mask2 ) d3 = merge ( minf , d3 , mask3 ) d4 = minf s1 ( 1 ) = '-2.15   -Inf' s1 ( 2 ) = '  NaN  20.33' s1 ( 3 ) = ' 1.00   +Inf' s2 = '-Inf,-Inf' s3 ( 2 ) = '           -Inf' s4 ( 2 ) = '  -Inf   ' call disp ( d1 , digmax = 4 ); call compare ( s1 , '-Inf-1' ) call disp ( d2 , sep = ',' , orient = 'row' ); call compare ( s2 , '-Inf-2' ) call disp ( 'A = ' , d3 , style = 'left' ); call compare ( s3 , '-Inf-3' ) call disp ( 'Longtitle' , d4 ); call compare ( s4 , '-Inf-4' ) s1 ( 1 ) = ' -2.  -Inf' s1 ( 2 ) = ' NaN   20.' s1 ( 3 ) = '  1.  +Inf' call disp ( d1 , digmax = 2 ); call compare ( s1 , 'Mixed-1' ) call disp ( d1 , 'F4.0' ); call compare ( s1 , 'Mixed-2' ) call disp ( d1 , 'F4.0' , trim = 'yes' ); call compare ( s1 , 'Mixed-3' ) s1 ( 1 ) = '-2.  ***' s1 ( 2 ) = 'NaN  20.' s1 ( 3 ) = ' 1.  Inf' call disp ( d1 , 'F3.0' ); call compare ( s1 , 'Field-overflow-1' ) call disp ( d2 , 'F2.0' ); call compare (( / '**' , '**' / ), 'Field-overflow-2' ) call disp_set_factory write ( * , '(\"  OK\")' ) call close_8 end subroutine test_ni subroutine msg1 ( st ) ! Print st if verbose is >= 1 character ( * ) st if ( verbose >= 1 ) write ( * , '(2x,a)' ) trim ( st ) end subroutine msg1 subroutine msg2 ( st ) ! Print st if verbose is >= 2 character ( * ) st if ( verbose >= 2 ) write ( * , '(4x,a)' ) trim ( st ) end subroutine msg2 subroutine compare ( sok , message , sok1 ) ! Utility for all the test routines. Print to the screen what the last disp calls ! displayed, and assert that what was displayed matches either sok or sok1. character ( * ) :: sok (:), sok1 (:), message optional :: message , sok1 character ( 100 ) :: s , mess integer ios1 , i rewind ( 8 ) compare_no = compare_no + 1 if ( present ( message )) then mess = message else write ( mess , '(a,\"-\",i0)' ) trim ( assert_string ), compare_no endif do i = 1 , 9999 read ( 8 , 1 , iostat = ios1 ) s if ( ios1 < 0 ) exit call msg2 ( s ) call assert ( i <= size ( sok ), message ) if ( present ( sok1 )) call assert ( sok ( i ) == s . or . sok1 ( i ) == s , mess ) if (. not . present ( sok1 )) call assert ( sok ( i ) == s , mess ) enddo call assert ( i == size ( sok ) + 1 , mess ) call reopen_8 1 format ( A ) end subroutine compare subroutine open_8 open ( 8 , file = 'testtmp.dat' , status = 'replace' ) end subroutine open_8 subroutine close_8 close ( 8 ) end subroutine close_8 subroutine reopen_8 call close_8 call open_8 end subroutine reopen_8 subroutine assert_init ( st ) ! Set assert-string (used by subroutine compare) to st, compare_no to zero and display st ! if verbose is true. If st is absent, set assert_string to '' character ( * ), optional :: st if ( present ( st )) then assert_string = st call msg2 ( '' ) call msg1 ( st ) else assert_string = '' endif compare_no = 0 end subroutine assert_init subroutine assert ( s , msg ) ! Assert that s is true. If not print \"assertion failed\" and msg if it is present logical s character ( * ), optional :: msg if (. not . s ) then if ( present ( msg )) then print '(a, \": assertion failed\")' , trim ( msg ) else print '(\"assertion failed\")' end if stop endif end subroutine assert END MODULE TEST_NANINF_MOD","tags":"","url":"sourcefile/test_naninf_mod.f90.html"},{"title":"demo_M_display.f90 – M_display","text":"Source Code program demo_M_display use M_display implicit none integer , parameter :: rk = selected_real_kind ( 6 ), n = 3 real ( rk ) :: a ( n , n ), b ( n , n ), x integer i , j , k ( 5 ) call disp_set ( advance = 'double' ) forall ( i = 1 : n , j = 1 : n ) a ( i , j ) = exp ( real ( i + j - 1 , rk )) b ( i , j ) = exp ( real ( i ** j , rk )) end forall call disp ( 'A = ' , a ) call disp ( b ) call disp ( a ( 1 : 2 ,:), 'f0.5' ) call disp ( 'MATRIX' , a , style = 'UNDERLINE & NUMBER' , unit =- 3 , digmax = 4 ) k = [ - 3 , 0 , 12 , 14 , 0 ] call disp ( 'K' , k , style = 'pad' , orient = 'row' , sep = ' ' , zeroas = '.' ) x = 1.5 call disp ( 'The square of ' // tostring ( x ) // ' is ' // tostring ( x * x )) call disp_set ( matsep = ' | ' ) call disp ([ 11 , 12 , 13 ], advance = 'no' ) call disp ([. true ., . false ., . true .], advance = 'no' ) call disp ([ 'A' , 'B' , 'C' ]) end program demo_M_display","tags":"","url":"sourcefile/demo_m_display.f90.html"},{"title":"demo_disp_get.f90 – M_display","text":"Source Code program demo_disp_get real :: xx ( 2 , 3 ), yy ( 2 , 3 ) xx ( 1 ,:) = [ 1.0 , 6.0 , 5.0 ] xx ( 2 ,:) = [ 2.4 , 4.0 , 6.0 ] yy ( 1 ,:) = [ 0.0 , 3.5 , 2.0 ] yy ( 2 ,:) = [ 7.0 , 4.0 , 8.22 ] call disp_xy ( xx , yy ) contains subroutine disp_xy ( x , y ) use M_display real x (:,:), y (:,:) type ( disp_settings ) ds ds = disp_get () call disp_set ( digmax = 4 , sep = ',' ) call disp ( 'x=' , x ) write ( * , * ) call disp ( 'y=' , y ) call disp_set ( ds ) end subroutine disp_xy end program demo_disp_get","tags":"","url":"sourcefile/demo_disp_get.f90.html"},{"title":"test_suite_M_display.f90 – M_display","text":"Source Code PROGRAM TEST_M_display use M_framework__verify , only : unit_check , unit_check_start , unit_check_good , unit_check_bad ! MAIN TEST PROGRAM FOR M_display. SEE ALSO test_M_display_fpp.F90 USE M_display ! USE DISP_I1MOD  ! uncomment this line if testing of disp_i1mod (1 byte integers) is required ! USE DISP_I2MOD  ! uncomment this line if testing of disp_i2mod (2 byte integers) is required ! USE DISP_I4MOD  ! uncomment this line if testing of disp_i4mod (4 byte integers) is required ! USE DISP_I8MOD  ! uncomment this line if testing of disp_i8mod (8 byte integers) is required ! USE DISP_L1MOD  ! uncomment this line if testing of disp_l1mod (1 byte logicals) is required ! USE DISP_R16MOD ! uncomment this line if testing of disp_r16mod (quad precision) is required ! ! Note that default integers are often 4 (sometimes 8) bytes, Note also that many computers/compilers do not ! support quad precision, and some support 10 byte reals (at least g95 on x86 platforms, it uses kind=10) ! ! Copyright (c) 2008, Kristjan Jonasson, Dept. of Computer Science, University of ! Iceland (jonasson@hi.is). This software is free. For details see the file README. implicit none integer , parameter :: verbose = 2 ! 0 = quiet !                                  ! 1 = report only names of test routines !                                  ! 2 = report also what the tests display integer , parameter :: irange = 9 ! Run for irange = 2, 4, 9 and 18 for test of 1, 2, 4 and 8 byte integers !                                  ! (most likely) integer , parameter :: logikind = kind (. false .) ! Run for logikind = 1 (probably) for test of 1 byte logicals integer , parameter :: sik = selected_int_kind ( irange ) ! Usually either 0, 1, 2, 3 or 1, 2, 4, 8 integer , parameter :: srk = kind ( 0.0 ) ! Run (at least) for srk = kind(0.0) and kind(0d0) integer :: compare_no = 0 character ( 30 ) :: assert_string = '' character ( 3 ) :: adv = 'no' character ( 90 ) :: fmt = '(\"  Testing M_display, int kind=\",I0,\", real kind=\",I0,\", logical kind=\",I0,\"...\")' write ( * , '(a)' ) 'STARTED M_display' ! Use goodbad(1) to indicate the test sequence was begun call unit_check_start ( 'M_display' , ' & & -section 3  & & -library libGPF  & & -filename `pwd`/M_display.FF & & -documentation y & &  -prep         y & &  -ccall        n & &  -archive      GPF.a & & ' ) if ( verbose > 0 ) adv = 'yes' write ( * , fmt , advance = adv ) sik , srk , logikind call open_8 call tests_from_manual call test_disp_set1 call test_disp_set2 call test_integer call test_real call test_complex call test_logical call test_char call test_scalar_string call test_numbering call test_zeroas call test_advance_double call test_advance_no call test_empty call test_tostring call test_error_messages call close_8 write ( * , '(\"  OK\")' ) call unit_check_good ( 'M_display' ) write ( * , '(a)' ) 'COMPLETED M_display' CONTAINS !=================================================================================================================================== subroutine msg1 ( st ) ! Print st if verbose is >= 1 character ( * ), intent ( in ) :: st if ( verbose >= 1 ) write ( * , '(2x,a)' ) trim ( st ) end subroutine msg1 !=================================================================================================================================== subroutine msg2 ( st ) ! Print st if verbose is >= 2 character ( * ), intent ( in ) :: st if ( verbose >= 2 ) write ( * , '(4x,a)' ) trim ( st ) end subroutine msg2 !=================================================================================================================================== subroutine w4blnk ! Write 4 blanks write ( * , '(\"    \")' , advance = 'no' ) end subroutine w4blnk !=================================================================================================================================== subroutine test_disp_set1 ! Check default values of disp_settings type ( disp_settings ) ds ds = disp_get () call assert ( ds % advance == 'YES' , '1A' ) call assert ( ds % trim == 'AUTO' , '1B' ) call assert ( ds % sep == '  ' , '1C' ) call assert ( ds % matsep == '   ' , '1D' ) call assert ( ds % orient == 'COL' , '1E' ) call assert ( ds % style == 'LEFT' , '1F' ) call assert ( ds % seplen == 2 , '1H' ) call assert ( ds % matseplen == 3 , '1I' ) call assert ( ds % digmax == 6 , '1J' ) call assert ( ds % zeroas == '' , '1K' ) call assert ( ds % zaslen == 0 , '1L' ) call assert ( ds % unit == - 3 , '1M' ) call assert ( ds % unit == ASTERISK_UNIT , '1M' ) end subroutine test_disp_set1 !=================================================================================================================================== subroutine test_disp_set2 ! Set, retrieve settings with disp_get and check contents of retrieved settings type ( disp_settings ) ds call disp_set ( advance = 'yes' ) call disp_set ( matsep = 'ss' ) call disp_set ( sep = 'cc' ) call disp_set ( orient = 'row' ) call disp_set ( style = 'xpad' ) call disp_set ( unit = 7 ) call disp_set ( digmax = 13 ) call disp_set ( zeroas = '**' ) ds = disp_get () call assert ( ds % advance == 'YES' , '2A' ) call assert ( ds % matsep == 'ss' , '2B' ) call assert ( ds % sep == 'cc' , '2C' ) call assert ( ds % orient == 'ROW' , '2D' ) call assert ( ds % style == 'xpad' , '2E' ) call assert ( ds % unit == 7 , '2G' ) call assert ( ds % digmax == 13 , '2H' ) call assert ( ds % zeroas == '**' , '2I' ) call assert ( ds % zaslen == 2 , '2J' ) call disp_set ( orient = 'col' ) call disp_set ( style = 'UNDERLINE' ) ds = disp_get () call assert ( ds % orient == 'COL' , '2K' ) call assert ( ds % style == 'UNDERLINE' , '2L' ) call disp_set_factory end subroutine test_disp_set2 !=================================================================================================================================== subroutine test_error_messages if ( verbose < 1 ) return call msg2 ( '' ) call msg1 ( 'TEST_ERROR_MESSAGES' ) call msg1 ( '  (Following should print 17 error messages,' ) call msg1 ( '  5 for disp_set, 8 for disp and 4 for tostring_set)' ) call disp_set ( unit = NULL_UNIT ) call w4blnk ; call disp_set ( advance = 'abc' ) call w4blnk ; call disp_set ( style = 'xyz' ) call w4blnk ; call disp_set ( digmax = 0 ) call w4blnk ; call disp_set ( digmax = 90 ) call w4blnk ; call disp_set ( orient = 'xyz' ) call disp_set ( digmax = 1 ) ! should not give error call disp_set ( digmax = 89 ) ! should not give error call disp ( 0.17 , digmax = 89 ) ! should not give error call w4blnk ; call disp ( 0.17 , digmax = 0 ) call w4blnk ; call disp ( 0.17 , digmax = 90 ) call w4blnk ; call disp ( 0.17 , digmax = 2 , fmt = 'f0.1' ) call w4blnk ; call disp ( 0.17 , advance = 'xyz' ) call w4blnk ; call disp ( 0.17 , trim = 'xyz' ) call w4blnk ; call disp ( 'x=' , 0.17 , style = 'xyz' ) call w4blnk ; call disp (( / 0.17 / ), orient = 'xyz' ) call w4blnk ; call disp (( 1 , 1 ), fmt_imag = 'F10.2' ) call w4blnk ; call tostring_set ( trimb = 'xyz' ) call w4blnk ; call tostring_set ( trimz = 'xyz' ) call w4blnk ; call tostring_set ( rfmt = 'xyz' ) call w4blnk ; call tostring_set ( ifmt = 'xyz' ) call disp_set_factory end subroutine test_error_messages !=================================================================================================================================== subroutine test_integer ! Check that disp works with integers integer ( sik ) :: i1 ( 1 , 2 ) = reshape (( /- 9_sik * 10_sik ** ( irange - 1 ) + 1 , 9_sik * 10_sik ** ( irange - 1 ) - 1 / ), ( / 1 , 2 / )) integer ( sik ) :: i2 ( 2 , 2 ) = reshape (( / 100 , - 99 , - 99 , 0 / ), ( / 2 , 2 / )) integer ( sik ) :: i3 ( 2 , 2 ) = reshape (( / 12 , 1 , - 12 , 0 / ), ( / 2 , 2 / )) integer ( sik ) :: i4 ( 2 ) = ( / 1 , - 2 / ) integer ( sik ) :: i5 ( 1 ) = ( / 0 / ) integer ( sik ) :: i6 ( 1 , 2 ) = reshape (( / 13 , - 12 / ), ( / 1 , 2 / )) integer ( sik ) :: i7 ( 2 ), i8 character ( 2 * irange + 3 ) :: s1 ( 1 ) character ( 9 ) :: s2 ( 3 ), s3 ( 2 ), s3a ( 2 ), s4 ( 3 ), s4a ( 2 ) character ( 2 ) :: s5 ( 1 ) character ( 7 ) :: s6 ( 3 ) character ( 10 ) :: s7 ( 1 ) character ( 13 ) :: s7a ( 1 ) character ( 3 ) :: fmt , s8 ( 2 ) character ( 10 ) :: st integer k500 , k5000 ! call assert_init ( 'TEST_INTEGER' ) st = '' if ( sik == kind ( 0 )) st = ' (default)' call msg1 ( '  (' // tostring ( bit_size ( i1 )) // ' bit' // trim ( st ) // ' integers)' ) s1 ( 1 ) = '-8' // repeat ( '9' , irange - 1 ) // ', 8' // repeat ( '9' , irange - 1 ) ! s2 ( 1 ) = '----AB---' s2 ( 2 ) = '100,  -99' s2 ( 3 ) = '-99,    0' ! s3 ( 1 ) = 'a=12::-12' s3 ( 2 ) = '   1::  0' s3a ( 1 ) = 'a= 12,-12' s3a ( 2 ) = '    1,  0' ! s4 ( 1 ) = 'Longtitle' s4 ( 2 ) = '    1    ' s4 ( 3 ) = '   -2    ' ! s4a ( 1 ) = 'Longtitle' s4a ( 2 ) = '   1;-2  ' ! s5 ( 1 ) = 'X0' ! s6 ( 1 ) = '  XY  ' s6 ( 2 ) = '======' s6 ( 3 ) = ' 13-12' ! s7 ( 1 ) = 'ab=5  5000' s7a ( 1 ) = 'ab=   5  5000' ! s8 ( 1 ) = 'abc' s8 ( 2 ) = '500' ! ! Tests with default format call disp_set ( unit = 8 ) call disp ( i1 , sep = ', ' ); call compare ( s1 ) call disp ( 'AB' , i2 , style = 'pad' , sep = ',  ' ); call compare ( s2 ) call disp ( 'a=' , i3 , sep = '::' ); call compare ( s3 ) call disp ( 'Longtitle' , i4 , style = 'pad' , orient = 'col' ); call compare ( s4 ) call disp ( 'X' , i5 ); call compare ( s5 ) call disp ( 'XY' , i6 , style = '=underline' , sep = '' , trim = 'no' ); call compare ( s6 ) ! ! Tests with specified format write ( fmt , '(\"i\",i2)' ) irange + 1 call disp ( i1 , fmt , sep = ',' ); call compare ( s1 ) call disp ( 'AB' , i2 , 'i3' , style = 'pad' , sep = ',  ' ); call compare ( s2 ) call disp ( 'a=' , i3 , 'i3' , sep = ',' ); call compare ( s3a ) call disp ( 'Longtitle' , i4 , 'i2' , style = 'above' ); call compare ( s4 ) call disp ( 'Longtitle' , i4 , 'i2' , style = 'above' , orient = 'col' ); call compare ( s4 ) call disp ( 'Longtitle' , i4 , 'i2' , style = 'pad' , orient = 'row' , sep = ';' ); call compare ( s4a ) call disp ( 'X' , i5 , 'i1' ); call compare ( s5 ) call disp ( 'XY' , i6 , 'i3' , style = '=underline' , sep = '' ); call compare ( s6 ) ! ! Test 4 byte numbers if ( irange >= 4 ) then k500 = 500 k5000 = 5000 i7 = ( / 5 , k5000 / ) i8 = k500 call disp_set ( orient = 'row' ) ! Without format: call disp ( 'ab=' , i7 ); call compare ( s7 ) call disp ( 'abc' , i8 , style = 'pad' ); call compare ( s8 ) ! With format: call disp ( 'ab=' , i7 , 'i4' ); call compare ( s7a ) call disp ( 'abc' , i8 , 'i0' , style = 'above' ); call compare ( s8 ) endif call disp_set_factory end subroutine test_integer !=================================================================================================================================== subroutine test_real ! Check that disp works with reals real ( srk ) :: r1 ( 2 , 2 ) = reshape (( / 2.146_srk , - 1.231_srk , 0.008_srk , 2 0.33_srk / ), ( / 2 , 2 / )) real ( srk ) :: r2 ( 1 , 2 ) = reshape (( / 1 2.0_srk , - 123 4.5678_srk / ), ( / 1 , 2 / )) real ( srk ) :: r3 ( 2 , 1 ) real ( srk ) :: r4 ( 1 , 1 ) = reshape (( / 0.0_srk / ), ( / 1 , 1 / )) real ( srk ) :: r5 = 0.0_srk integer :: rrng ! character ( 3 ) rrangec character ( 6 ) r3_2chr ! character ( 12 ) :: s1 ( 2 ), f1 ( 2 ) character ( 13 ) :: f3 ( 2 ) character ( 15 ) :: f2 ( 2 ) character ( 16 ) :: s3 ( 2 ) character ( 17 ) :: s2 ( 2 ), s3a ( 2 ) character ( 9 ) :: s4 ( 3 ), f4 ( 3 ) character ( 18 ) :: prc ! call assert_init ( 'TEST_REAL' ) prc = '' if ( srk == kind ( 0.0 )) prc = ', single precision' if ( srk == kind ( 0 d0 )) prc = ', double precision' call msg1 ( '  (kind = ' // tostring ( srk ) // trim ( prc ) // ')' ) s1 ( 1 ) = ' 2.15   0.01' s1 ( 2 ) = '-1.23  20.33' f1 = s1 ! s2 ( 1 ) = '--------AB-------' s2 ( 2 ) = '   12.00,-1234.57' f2 ( 1 ) = '-------AB------' f2 ( 2 ) = '   12.0,-1234.6' ! ! A number close to the largest possible real ! (r3 could for example be [1.2e21, -2e37] for single precision and [1.2e21, -2e307] for double) rrng = min ( 999 , range ( 0.0_srk )) ! test not designed for numbers >= 10**1000. write ( rrangec , '(i3.3)' ) rrng s3 ( 1 ) = 'A =  1.20000E+21' s3a ( 1 ) = 'A =  1.20000E+021' s3 ( 2 ) = '    -2.00000E+' // rrangec ( 2 : 3 ) s3a ( 2 ) = '    -2.00000E+' // rrangec f3 ( 1 ) = 'A =  1.2E+021' f3 ( 2 ) = '    -2.0E+' // rrangec r3 ( 1 , 1 ) = 1.2e21 r3_2chr = '-2e' // rrangec read ( r3_2chr , * ) r3 ( 2 , 1 ) ! s4 ( 1 ) = 'Longtitle' s4 ( 2 ) = '---------' s4 ( 3 ) = ' 0.00000 ' f4 ( 1 ) = 'Longtitle' f4 ( 2 ) = '*********' f4 ( 3 ) = '   0.    ' ! ! Test calls without format (r2(1,:) tests vector): call disp_set ( unit = 8 , style = 'PAD' , sep = ',' ) call disp ( r1 , digmax = 4 , style = 'LEFT' , sep = '  ' ); call compare ( s1 , 'ok-1' ) call disp ( 'AB' , r2 , trim = 'no' ); call compare ( s2 , 'ok-2' ) call disp ( 'AB' , r2 ( 1 ,:), trim = 'no' , orient = 'row' ); call compare ( s2 , 'ok-3' ) call disp ( 'A = ' , r3 , style = 'left' ); if ( rrng <= 99 ) call compare ( s3 , 'ok-4' ) if ( rrng > 99 ) call compare ( s3a , 'ok-4' ) call disp ( 'Longtitle' , r4 , style = 'underline' ); call compare ( s4 , 'ok-6' ) call disp ( 'Longtitle' , r5 , style = 'underline' ); call compare ( s4 , 'ok-7' ) ! Test calls with format: call disp ( r1 , 'f5.2' , style = 'LEFT' , sep = '  ' ); call compare ( f1 , 'ok-8' ) call disp ( 'AB' , r2 , 'f7.1' ); call compare ( f2 , 'ok-9' ) call disp ( 'AB' , r2 ( 1 ,:), 'f7.1' , orient = 'row' ); call compare ( f2 , 'ok-10' ) call disp ( 'A = ' , r3 , 'es9.1e3' , style = 'left' ); call compare ( f3 , 'ok-11' ) call disp ( 'Longtitle' , r4 , 'f2.0' , style = '*underline' ); call compare ( f4 , 'ok-12' ) call disp_set_factory end subroutine test_real !=================================================================================================================================== subroutine test_numbering integer :: i real ( srk ) :: r1 ( 2 , 2 ) = reshape (( / 2.146_srk , - 1.231_srk , 0._srk , 0.33_srk / ), ( / 2 , 2 / )) integer ( sik ) :: i2 ( 2 ) = ( / 0 , 0 / ), i3 ( 11 ) = ( / ( 0 , i = 1 , 11 ) / ), i4 ( 1 , 2 ) = reshape (( / 0 , 0 / ), ( / 1 , 2 / )) character ( 15 ) :: s1a ( 3 ), s1b ( 3 ), s1c ( 3 ), s1d ( 3 ), s1e ( 3 ), s1f ( 4 ) character ( 20 ) :: s1g ( 3 ) character ( 9 ) :: s2a ( 2 ), s2b ( 2 ), s2c ( 2 ), s2d ( 2 ), s2e ( 3 ), s4 ( 2 ) character ( 42 ) :: s3c ( 2 ) s1a = ( / '      1     2 ' ,& & '1   2.15  0.00' ,& & '2  -1.23  0.33' / ) s1b = ( / '     10    11 ' ,& & '1   2.15  0.00' ,& & '2  -1.23  0.33' / ) s1c = ( / '   10001  10002' ,& & '1    2.1    0.0' ,& & '2   -1.2    0.3' / ) s1d = ( / '    10   11 ' ,& & '1, 2.15,0.00' ,& & '2,-1.23,0.33' / ) s1e = ( / '    10    11 ' ,& & '1, 2.15, 0.00' ,& & '2,-1.23, 0.33' / ) s1f = ( / '------s1f-----' ,& & '      1     2 ' ,& & '1   2.15  0.00' ,& & '2  -1.23  0.33' / ) s1g = ( / '            1     2 ' ,& & 's1g = 1   2.15  0.00' ,& & '      2  -1.23  0.33' / ) ! s2a = ( / '1  2' ,& & '0  0' / ) s2b = ( / '-2  -1' ,& & ' 0   0' / ) s2c = ( / '1  0' ,& & '2  0' / ) s2d = ( / 'XX = 1  0' ,& & '     2  0' / ) s2e = ( / '-XX-' ,& & '1  0' ,& & '2  0' / ) s3c = ( / '-10  -9  -8  -7  -6  -5  -4  -3  -2  -1  0' ,& & '  0   0   0   0   0   0   0   0   0   0  0' / ) s4 = ( / '   1  2' ,& & '1  0  0' / ) ! call assert_init ( 'TEST_NUMBERING' ) call disp_set ( unit = 8 ) call disp ( r1 , 'F0.2' , style = 'number' ) ; call compare ( s1a ) call disp ( r1 , 'F0.2' , style = 'number' , lbound = ( / 1 , 10 / )) ; call compare ( s1b ) call disp ( r1 , 'F0.2' , lbound = ( / 1 , 10 / )) ; call compare ( s1b ) call disp ( r1 , 'F0.1' , lbound = ( / 1 , 10001 / )) ; call compare ( s1c ) call disp ( r1 , 'F0.2' , sep = ',' , lbound = ( / 1 , 10 / )) ; call compare ( s1d ) call disp ( r1 , 'F5.2' , sep = ',' , lbound = ( / 1 , 10 / )) ; call compare ( s1e ) call disp ( 's1f' , r1 , 'F0.2' , style = 'pad & number' ) ; call compare ( s1f ) call disp ( 's1g = ' , r1 , 'F0.2' , style = 'number' ) ; call compare ( s1g ) call disp ( i2 , style = 'number' , orient = 'row' ) ; call compare ( s2a ) call disp ( i2 , lbound = ( / 1 / ), orient = 'row' ) ; call compare ( s2a ) call disp ( i2 , lbound = ( /- 2 / ), orient = 'row' ) ; call compare ( s2b ) call disp ( i2 , style = 'number' ) ; call compare ( s2c ) call disp ( 'XX = ' , i2 , style = 'number' ) ; call compare ( s2d ) call disp ( 'XX' , i2 , style = 'pad & number' ) ; call compare ( s2e ) call disp ( i3 , lbound = ( /- 10 / ), orient = 'row' ) ; call compare ( s3c ) call disp ( i4 , style = 'number' ) ; call compare ( s4 ) end subroutine test_numbering !=================================================================================================================================== subroutine test_advance_double call assert_init ( 'TEST_ADVANCE_DOUBLE' ) call disp_set ( unit = 8 ) call disp ( 5 , advance = 'double' ) call disp ( 6 ) call compare (( / '5' , ' ' , '6' / )) call disp_set ( advance = 'double' ) call disp ( 7 , advance = 'no' ) call disp ( 8 ) call disp ( 9 ) call compare (( / '7   8' , '     ' , '9    ' , '     ' / )) call disp_set_factory end subroutine test_advance_double !=================================================================================================================================== subroutine test_advance_no call assert_init ( 'TEST_ADVANCE_NO' ) call disp_set ( unit = 8 ) call disp ( 1 , advance = 'no' ) call disp (( / 2 , 3 / ), advance = 'yes' ) call compare (( / '1   2' , '    3' / )) call disp_set_factory end subroutine test_advance_no !=================================================================================================================================== subroutine test_zeroas ! Test various features of using zeroas real ( srk ) :: d1 ( 3 , 2 ) = reshape (( / 2.146_srk , - 1.231_srk , 1._srk , 0._srk , 2 0.33_srk , 0._srk / ), ( / 3 , 2 / )) real ( srk ) :: d2 ( 2 ) = ( / 0._srk , 0._srk / ) real ( srk ) :: d3 ( 2 ) = ( / 1 2e20_srk , 0._srk / ) real ( srk ) :: d4 = 0._srk real ( srk ) :: r1 ( 3 , 2 ) = reshape (( / 2.146_srk , - 1.231_srk , 1._srk , 0._srk , 2 0.33_srk , 0._srk / ), ( / 3 , 2 / )) real ( srk ) :: r2 ( 2 ) = ( / 0._srk , 0._srk / ) integer ( sik ) :: i1 ( 4 ) = ( / 1 , 0 , 11 , 0 / ) integer ( sik ) :: i2 ( 2 , 2 ) = reshape (( / 0 , 0 , 11 , 12 / ), ( / 2 , 2 / )) character ( 12 ) :: s1a ( 3 ), s1b ( 3 ), s1c ( 3 ), s1d ( 3 ), s1e ( 3 ), s1f ( 3 ) character ( 3 ) :: s2 ( 1 ) character ( 16 ) :: s3 ( 2 ), s3a ( 2 ) character ( 9 ) :: s4 ( 2 ) character ( 2 ) :: s5 ( 4 ) character ( 5 ) :: s6 ( 2 ), s8 ( 2 ) character ( 12 ) :: s7 ( 3 ) ! s1a = ( / ' 2.15      *' ,& & '-1.23  20.33' ,& & ' 1.00      *' / ) s1b = ( / ' 2.15   0.  ' ,& & '-1.23  20.33' ,& & ' 1.00   0.  ' / ) s1c = ( / ' 2.15   000.' ,& & '-1.23  20.33' ,& & ' 1.00   000.' / ) s1d = ( / ' 2.15   .000' ,& & '-1.23  20.33' ,& & ' 1.00   .000' / ) s1e = ( / ' 2.1  zero  ' ,& & '-1.2  20.3  ' ,& & ' 1.0  zero  ' / ) s1f = ( / ' 2.1  zeroas' ,& & '-1.2    20.3' ,& & ' 1.0  zeroas' / ) ! s2 = '0,0' ! s3 ( 1 ) = 'A = 1.20000E+21' s3 ( 2 ) = '              0' ! s3a ( 1 ) = 'A = 1.20000+021' s3a ( 2 ) = '              0' ! s4 ( 1 ) = 'Longtitle' s4 ( 2 ) = '    0    ' ! s5 = ( / ' 1' , '  ' , '11' , '  ' / ) ! s6 = ( / '.  11' , '.  12' / ) ! s7 = ( / '   999  1000' , '1    .    11' , '2    .    12' / ) ! s8 = ( / '0  11' , '0  12' / ) ! call assert_init ( 'TEST_ZEROAS' ) call disp_set ( unit = 8 , style = 'PAD' , zeroas = '0' ) call disp ( d1 , digmax = 4 , zeroas = '*' ); call compare ( s1a ) call disp ( d1 , digmax = 4 , zeroas = '0.' ); call compare ( s1b ) call disp ( d1 , digmax = 4 , zeroas = '000.' ); call compare ( s1c ) call disp ( d1 , digmax = 4 , zeroas = '.000' ); call compare ( s1d ) call disp ( d1 , 'f4.1' , zeroas = 'zeroas' ); call compare ( s1e ) call disp ( d1 , digmax = 3 , zeroas = 'zeroas' ); call compare ( s1f ) call disp ( d2 , sep = ',' , orient = 'row' ); call compare ( s2 ) call disp ( 'A = ' , d3 , style = 'left' ); call compare ( s3 , 'zas' , s3a ) call disp ( 'Longtitle' , d4 ); call compare ( s4 ) call disp ( r1 , digmax = 4 , zeroas = '*' ); call compare ( s1a ) call disp ( r1 , digmax = 4 , zeroas = '0.' ); call compare ( s1b ) call disp ( r2 , sep = ',' , orient = 'row' ); call compare ( s2 ) call disp ( i1 , zeroas = ' ' ); call compare ( s5 ) call disp ( i2 , zeroas = '.' ); call compare ( s6 ) call disp ( i2 , zeroas = '.' , lbound = ( / 1 , 999 / )); call compare ( s7 ) call disp ( i2 , zeroas = '' ); call compare ( s8 ) call disp_set_factory end subroutine test_zeroas !=================================================================================================================================== subroutine test_complex ! Test disp with complex data real ( srk ) :: r1 ( 2 , 2 ) = reshape (( / 2.146_srk , - 1.231_srk , 0.008_srk , 2 0.33_srk / ), ( / 2 , 2 / )) real ( srk ) :: r2 ( 2 ) = ( / 1 2.0_srk , - 123 4.5678_srk / ) complex ( srk ) :: c1 ( 2 , 2 ), c2 ( 2 ), c3 character ( 29 ) :: s1 ( 2 ) character ( 31 ) :: s1a ( 2 ), s1b ( 2 ) character ( 36 ) :: s2 ( 2 ) character ( 16 ) :: s3 ( 1 ) ! call assert_init ( 'TEST_COMPLEX' ) s1 ( 1 ) = ' 2.15 + 4.29i   0.01 +  0.02i' s1 ( 2 ) = '-1.23 - 2.46i  20.33 + 40.66i' ! s1a ( 1 ) = ' 2.1460 + 4.3i   0.0080 +  0.0i' s1a ( 2 ) = '-1.2310 - 2.5i  20.3300 + 40.7i' ! s1b ( 1 ) = ' 2.1 + 4.2920i   0.0 +  0.0160i' s1b ( 2 ) = '-1.2 - 2.4620i  20.3 + 40.6600i' ! s2 ( 1 ) = '---------------AB--------------' s2 ( 2 ) = '12.0 + 12.0i, -1234.6 - 1234.6i' ! s3 ( 1 ) = '1.2345 - 2.3457i' ! c1 = cmplx ( r1 , 2 * r1 ) c2 = cmplx ( r2 , r2 ) c3 = ( 1.2345_srk , - 2.34567_srk ) ! call disp_set ( unit = 8 ) call disp ( c1 , 'F0.2' ); call compare ( s1 ) call disp ( c1 , 'F0.4' , fmt_imag = 'F0.1' ); call compare ( s1a ) call disp ( c1 , 'F0.1' , fmt_imag = 'F0.4' ); call compare ( s1b ) call disp_set ( style = 'PAD' , digmax = 5 , sep = ', ' ); call disp ( 'AB' , c2 , orient = 'row' ); call compare ( s2 ) call disp ( c3 ); call compare ( s3 ) call disp_set_factory end subroutine test_complex !=================================================================================================================================== subroutine test_char ! Check that disp works for outputting character strings with explicit or default format character ( 3 ) :: c1 ( 2 , 2 ) = reshape (( / 'ABC' , '   ' , 'A  ' , '  B' / ), ( / 2 , 2 / )) character ( 3 ) :: c2 ( 1 , 2 ) = reshape (( / 'ABC' , 'AB ' / ), ( / 1 , 2 / )) character ( 1 ) :: c3 ( 2 , 1 ) = reshape (( / 'X' , 'Y' / ), ( / 2 , 1 / )) character ( 3 ) :: c4 ( 1 , 1 ) = reshape (( / 'ABC' / ), ( / 1 , 1 / )) character ( 8 ) :: s1 ( 2 ) character ( 9 ) :: s2 ( 2 ) character ( 5 ) :: s3 ( 2 ) character ( 9 ) :: s4 ( 3 ) ! call assert_init ( 'TEST_CHAR' ) s1 = ( / 'ABC  A  ' ,& & '       B' / ) s2 = ( / '--title--' ,& & ' ABC, AB ' / ) s3 = ( / 'A = X' ,& & '    Y' / ) s4 = ( / 'Longtitle' ,& & '*********' ,& & '   ABC   ' / ) call disp_set ( unit = 8 , style = 'PAD' ) ! SPECIFIED FORMAT: call disp ( c1 , 'A' , style = 'left' ); call compare ( s1 ) call disp ( 'title' , c2 , 'A4' , sep = ',' ); call compare ( s2 ) call disp ( 'A = ' , c3 , 'a1' , style = 'left' ); call compare ( s3 ) call disp ( 'Longtitle' , c4 , 'A' , style = '*underline' ); call compare ( s4 ) ! DEFAULT FORMAT: call disp ( c1 , style = 'left' ); call compare ( s1 ) call disp ( 'A = ' , c3 , style = 'left' ); call compare ( s3 ) call disp ( 'Longtitle' , c4 , style = '*underline' ); call compare ( s4 ) call disp_set_factory end subroutine test_char !=================================================================================================================================== subroutine test_logical ! Check that disp works for outputting logicals with explicit or default format logical ( logikind ) :: l1 ( 2 , 2 ) logical ( logikind ) :: l2 ( 1 , 2 ) logical ( logikind ) :: l3 ( 2 , 1 ) logical ( logikind ) :: l4 character ( 5 ), dimension ( 2 ) :: s1 , s2 , s3 , s4 character :: s5 ( 1 ) integer ( selected_int_kind ( 2 )) :: nbytes = 0 l1 = reshape (( / . true ., . true ., . false ., . false . / ), ( / 2 , 2 / )) l2 = reshape (( / . false ., . true . / ), ( / 1 , 2 / )) l3 = reshape (( / . true ., . false . / ), ( / 2 , 1 / )) l4 = . true . nbytes = int ( size ( transfer ( l4 , ( / nbytes / ))), selected_int_kind ( 2 )) ! call assert_init ( 'TEST_LOGICAL' ) call msg1 ( '  (' // tostring ( int ( nbytes )) // ' byte logicals)' ) s1 = ( / ' T, F' ,& & ' T, F' / ) s2 = ( / 'T  F ' ,& & 'T  F ' / ) s3 = ( / 'title' ,& & 'F  T ' / ) s4 = ( / 'A = T' ,& & '    F' / ) s5 = ( / 'T' / ) ! call disp_set ( unit = 8 ) !SPECIFIED FORMAT: call disp ( l1 , 'L2' , sep = ',' ); call compare ( s1 ) call disp ( 'title' , l2 , 'L1' , style = 'pad' ); call compare ( s3 ) call disp ( 'A = ' , l3 , 'L1' ); call compare ( s4 ) !DEFAULT FORMAT: call disp ( l1 ); call compare ( s2 ) call disp ( 'title' , l2 , style = 'pad' ); call compare ( s3 ) call disp ( 'A = ' , l3 ); call compare ( s4 ) call disp ( l4 ); call compare ( s5 ) call disp_set_factory end subroutine test_logical !=================================================================================================================================== subroutine tests_from_manual call assert_init ( 'TESTS_FROM_MANUAL' ) call tests_from_manual_1 call tests_from_manual_2 call tests_from_manual_3 call tests_from_manual_4 call tests_from_manual_5 end subroutine tests_from_manual !=================================================================================================================================== subroutine tests_from_manual_1 ! Test examples in section 1 in the manual integer X ( 3 , 3 ) integer i , j , k , Y ( 3 ) real A ( 4 , 4 ), B ( 4 , 4 ) complex C ( 3 , 3 ) character ( 37 ) Ashouldbe ( 4 ) character ( 36 ) ANshouldbe ( 5 ) character ( 46 ) Bshouldbe ( 4 ) character ( 20 ) XYshouldbe ( 3 ) character ( 55 ) Cshouldbe ( 3 ) call assert_init ( '...section 1' ) A = reshape (( / (( real ( exp ( dble ( i + j - 1 ))) , i = 1 , 4 ), j = 1 , 4 ) / ), ( / 4 , 4 / )) B = reshape (( / (( real ( exp ( dble ( i * j ))), i = 1 , 4 ), j = 1 , 4 ) / ), ( / 4 , 4 / )) X = reshape (( / 7 , 8 , 3 , 4 , 0 , 2 , 1 , 3 , 6 / ), ( / 3 , 3 / ), order = ( / 2 , 1 / )) Y = ( / 11 , 2 , 7 / ) forall ( i = 1 : 3 , k = 1 : 3 ) C ( i , k ) = log ( cmplx ( - i * k )) ** k Ashouldbe = ( / & 'A =  2.72    7.39   20.09    54.60' , & '     7.39   20.09   54.60   148.41' , & '    20.09   54.60  148.41   403.43' , & '    54.60  148.41  403.43  1096.63' / ) ANshouldbe = ( / & '     1       2       3        4  ' , & '1   2.72    7.39   20.09    54.60' , & '2   7.39   20.09   54.60   148.41' , & '3  20.09   54.60  148.41   403.43' , & '4  54.60  148.41  403.43  1096.63' / ) Bshouldbe = ( / & '2.71828E+0  7.38906E+0  2.00855E+1  5.45981E+1' , & '7.38906E+0  5.45981E+1  4.03429E+2  2.98096E+3' , & '2.00855E+1  4.03429E+2  8.10308E+3  1.62755E+5' , & '5.45981E+1  2.98096E+3  1.62755E+5  8.88611E+6' / ) XYshouldbe = ( / & 'X = 7  8  3   Y = 11' , & '    4  0  2        2' , & '    1  3  6        7' / ) Cshouldbe = ( / & 'C = 0.000 + 3.142i  -9.389 +  4.355i  -31.203 - 19.631i' , & '    0.693 + 3.142i  -7.948 +  8.710i  -47.300 -  0.749i' , & '    1.099 + 3.142i  -6.659 + 11.258i  -54.449 + 14.495i' / ) call disp_set ( unit = 8 ) call disp ( 'A = ' , A ) call compare ( Ashouldbe , '1-A' ) call disp ( A , style = 'number' ) call compare ( ANshouldbe , '1-A' ) ! call disp ( B ) call compare ( Bshouldbe , '1-B' ) ! call disp ( 'X = ' , X , ADVANCE = 'no' ) call disp ( 'Y = ' , Y ) call compare ( XYshouldbe , '1-XY' ) ! call disp ( 'C = ' , C , 'F0.3' ) call compare ( Cshouldbe , '1-C' ) ! call disp_set_factory end subroutine tests_from_manual_1 !=================================================================================================================================== subroutine tests_from_manual_2 ! Test examples in section 2 in the manual REAL :: A ( 3 ) = ( / 1.2345 , 2.3456 , 3.4567 / ) CHARACTER ( 29 ) S call assert_init ( '...section 2' ) CALL DISP ( 'A = ' , A , UNIT = 8 , SEP = ', ' , ORIENT = 'ROW' ) rewind ( 8 ) read ( 8 , 1 ) S call msg2 ( S ) call assert ( S == 'A = 1.23450, 2.34560, 3.45670' , '2' ) call reopen_8 1 format ( A ) end subroutine tests_from_manual_2 !=================================================================================================================================== subroutine tests_from_manual_3 ! Test examples in section 3 in the manual real :: Matr ( 2 , 2 ) = reshape ( ( / 1.2 , 5.6 , 4.2 , 1 8.3 / ), ( / 2 , 2 / ) ) real :: z ( 2 , 3 ) = reshape (( / 1 4.28 , 1.42 , 1428571 4.0 , 14142 1.0 , 0.47 , 0.69 / ), ( / 2 , 3 / )) real :: x ( 2 , 2 ), pe ( 2 , 3 ) real :: A ( 0 : 3 , 0 : 3 ), B ( 4 , 4 ) integer xy ( 3 , 3 ), uv ( 3 ), i , j , k character ( 35 ) shouldbe_A ( 5 ) character ( 74 ) shouldbe_D ( 4 ) character ( 57 ) shouldbe_E ( 4 ) character ( 20 ) shouldbe_F ( 3 ) character ( 24 ) shouldbe_I ( 6 ) character ( 63 ) shouldbe_zas ( 4 ) call assert_init ( '...section 3' ) ! SECTION 3.1: call disp_set ( unit = 8 ) call disp ( - 4 4.6 , 'ES11.4E2' ) call disp ( - 4 4.6 , 'F8.4' ) call compare (( / '-4.4600E+01' , '-44.6000   ' / ), '3-A' ) ! CALL DISP ( 'str' , FMT = 'A4' ) CALL DISP ( 'str' , 'A4' ) call compare (( / ' str ' , 'strA4' / ), '3-B' ) ! ! SECTION 3.2: ! ! INTRODUCTION CALL DISP ( 'X=' , ( / 1 2.3 , 1 6.78 / ), DIGMAX = 3 , ORIENT = 'row' ) call compare (( / 'X=12.3  16.8' / ), '3-D' ) ! ! FMT_IMAG CALL DISP (( 1.31 , 2.47 ), 'F0.1' , 'F0.2' ) call compare (( / '1.3 + 2.47i' / ), '3-C' ) ! ! LBOUND forall ( i = 0 : 3 , j = 0 : 3 ) A ( i , j ) = real ( exp ( dble ( i + j - 1 ))) call disp ( A , style = 'number' , lbound = lbound ( A )) shouldbe_A = ( / & '     0       1       2        3  ' , & '0  0.368   1.000   2.718    7.389' , & '1  1.000   2.718   7.389   20.086' , & '2  2.718   7.389  20.086   54.598' , & '3  7.389  20.086  54.598  148.413' / ) call compare ( shouldbe_A ) call disp ( A , lbound = lbound ( A )) call compare ( shouldbe_A ) ! ! SEP CALL DISP ( reshape (( /- 1 , 5 , 5 , 10 / ),( / 2 , 2 / )), SEP = ', ' ) call compare (( / '-1,  5' , ' 5, 10' / ), '3-E' ) ! ! STYLE call disp ( 'a' , ( / 1 , 2 , 3 / ), style = '*underline' , orient = 'row' ) call compare (( / '   a   ' , '*******' , '1  2  3' / )) ! call disp_set ( matsep = '    ' ) call disp ( 'Matr = ' , Matr , digmax = 3 , Style = 'left' , advance = 'no' ) call disp ( 'Matr' , Matr , digmax = 3 , Style = 'pad' , advance = 'no' ) call disp ( 'Matr' , Matr , digmax = 3 , Style = 'underline' , advance = 'no' ) call disp ( Matr , digmax = 3 , Style = 'number' , advance = 'no' ) call disp ( 'Matr' , Matr , digmax = 3 , Style = '_pad & number' , advance = 'yes' ) shouldbe_D = ( / & 'Matr = 1.2   4.2    ---Matr--       Matr          1     2     ____Matr____' , & '       5.6  18.3    1.2   4.2    ---------    1  1.2   4.2        1     2 ' , & '                    5.6  18.3    1.2   4.2    2  5.6  18.3    1  1.2   4.2' , & '                                 5.6  18.3                    2  5.6  18.3' / ) call compare ( shouldbe_D , '3-F' ) ! ! TRIM call disp_set ( style = 'pad' , orient = 'row' , advance = 'no' , sep = ' ' , matsep = '   ' ) shouldbe_E = ( / & '----X----   -------Y------   -----U-----   -------V------' ,& '1  2    3      1    2    3   333 22 4444    333   22 4444' ,& '2 22   34      2   22   34                               ' ,& '3 32 1234      3   32 1234                               ' / ) xy = reshape (( / 1 , 2 , 3 , 2 , 22 , 32 , 3 , 34 , 1234 / ),( / 3 , 3 / )) uv = ( / 333 , 22 , 4444 / ) call disp ( 'X' , xy , trim = 'yes' ) call disp ( 'Y' , xy , trim = 'no' ) call disp ( 'U' , uv , trim = 'yes' ) call disp ( 'V' , uv , trim = 'no' , advance = 'yes' ) call compare ( shouldbe_E , '3-G' ) call disp_set_factory ; ! call disp_set ( style = 'above' , unit = 8 ) forall ( i = 1 : 2 , k = 1 : 3 ) pe ( i , k ) = real ( exp ( dble ( k ) ** i )) call disp ( 'power exponentials' , pe , trim = 'yes' ) shouldbe_F = ( / & ' power exponentials ' ,& '2.72   7.39    20.09' ,& '2.72  54.60  8103.08' / ) call compare ( shouldbe_F , '3-H' ) call disp_set_factory ; call disp_set ( unit = 8 ) ! x = reshape (( / 1.2e5 , 2.3e-3 , - 4.1e-2 , 8.6e1 / ), ( / 2 , 2 / )) call disp_set ( style = 'left' , sep = ' ' ) call disp ( 'X=' , x , 'es7.1e1' , trim = 'yes' ) call compare (( / 'X=1.2E+5 -4.1E-2' , '  2.3E-3  8.6E+1' / ), '3-I' ) call disp ( 'X=' , x , 'es7.1e1' , trim = 'no' ) call compare (( / 'X= 1.2E+5 -4.1E-2' , '   2.3E-3  8.6E+1' / ), '3-J' ) call disp_set_factory ; call disp_set ( unit = 8 ) ! ! ZEROAS forall ( i = 1 : 4 , j = 1 : 4 ) B ( i , j ) = max ( 0. , j - i + 1. ) where ( B > 0 ) B = 1 / B shouldbe_zas = ( / & 'A = 1.000  0.500  0.333  0.250   B = 1.000  0.500  0.333  0.250' , & '        0  1.000  0.500  0.333        .     1.000  0.500  0.333' , & '        0      0  1.000  0.500        .      .     1.000  0.500' , & '        0      0      0  1.000        .      .      .     1.000' / ) call disp ( 'A = ' , B , 'F0.3' , zeroas = '0' , advance = 'no' ) call disp ( 'B = ' , B , 'F0.3' , zeroas = '.' ) call compare ( shouldbe_zas , '3-ZAS' ) call disp_set_factory ; call disp_set ( unit = 8 ) ! ! SECTION 3.3: call disp ( 'TESTING NULL_UNIT -- THIS SHOULD NOT BE DISPLAYED' , unit = - 1 ) call disp ( 'TESTING NULL_UNIT -- THIS SHOULD NOT BE DISPLAYED' , unit = NULL_UNIT ) call assert ( ASTERISK_UNIT == - 3 , 'asterisk_unit' ) call assert ( PUTSTR_UNIT == - 2 , 'putstr_unit' ) call assert ( NULL_UNIT == - 1 , 'null_unit' ) ! ! SECTION 3.5 call disp ( 'F0.2' , z , 'f0.2' , style = 'pad' ) call disp ( \"F13.2, TRIM='yes'\" , z , 'f7.2' , style = 'pad' , trim = 'yes' ) shouldbe_I = ( / & & \"----------F0.2----------\" ,& & \"14.28  14285714.00  0.47\" ,& & \" 1.42    141421.00  0.69\" ,& & \"--F13.2, TRIM='yes'-    \" ,& & \"14.28  *******  0.47    \" ,& & \" 1.42  *******  0.69    \" / ) call compare ( shouldbe_I , '3-I' ) ! call disp_set_factory end subroutine tests_from_manual_3 !=================================================================================================================================== subroutine tests_from_manual_4 ! Test examples in section 4 in the manual type ( disp_settings ) ds real :: x ( 3 ) = ( / 1 2.2 , 9.6 , - 2.0 / ), y ( 3 ) = ( / 1.3 , 1 3.0 , 4.0 / ) integer :: z ( 3 ) = ( / 1 , 3 , 4 / ) character ( 15 ) :: s ( 3 ) = ( / '12.2 |  1.3 | 1' ,& & ' 9.6 | 13.0 | 3' ,& & '-2.0 |  4.0 | 4' / ) call assert_init ( '...section 4' ) call test_disp_set1 call disp_set ( style = 'PAD' , sep = ' ' ) ds = disp_get () call assert ( ds % style == 'PAD' , '4a' ) call assert ( ds % sep == ' ' . and . ds % seplen == 1 , '4b' ) call disp_set_factory call disp_set ( unit = 8 , digmax = 3 ) call disp ( x , advance = 'no' ) call disp ( y , advance = 'no' ) call disp_set ( matsep = ' | ' ) call disp ( z , advance = 'yes' ) call compare ( s , '4c' ) call disp_xy ( reshape ( x ,( / 1 , 3 / )), reshape ( y ,( / 1 , 3 / ))) ds = disp_get () call assert ( ds % sep == ' ' . and . ds % digmax == 3 ) call compare (( / 'x=12.20,9.60,-2.00' , 'y=1.30,13.00,4.00 ' / ), '4d' ) call disp_set_factory end subroutine tests_from_manual_4 !=================================================================================================================================== subroutine disp_xy ( x , y ) ! Utility for tests_from_manual_4 ! use M_display (already \"used\" here, but explicit in manual) real , intent ( in ) :: x (:,:), y (:,:) type ( disp_settings ) ds ds = disp_get () call disp_set ( digmax = 4 , sep = ',' ) call disp ( 'x=' , x ) call disp ( 'y=' , y ) call disp_set ( ds ) end subroutine disp_xy !=================================================================================================================================== subroutine tests_from_manual_5 ! Test examples in section 5 in the manual character ( 50 ) s integer i real ( srk ) sr character ( * ), parameter :: & ! Alternative results: s1 = '1, 256, 6561, 65536, 3.90625+005' , & s2 = '0.707107 + 0.707107i, 0.840896 + 0.840896i' , & s4 = '1.1, 2.2+010, 3.3+020' real :: x = 1.5 ! call assert_init ( '...section 5' ) call disp_set ( unit = 8 ) ! ! SECTIONS 5.1-5.3 call disp ( 'The square of ' // tostring ( x ) // ' is ' // tostring ( x * x )) call compare (( / 'The square of 1.5 is 2.25' / )) CALL TOSTRING_SET ( SEP = '; ' ) s = tostring (( / 1 , 2 / )) ; call scompare ( s , '1; 2' ) call tostring_set_factory ! ! SECTION 5.4 s = tostring ( atan ( 1.0 )) ; call tscompare ( s , ( / 0.785398 / ), '1a' ) !tostring(exp((/-3d0,-1d0,0d0,1d0/))) see (*) below s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 ) ; call scompare ( s , '1, 256, 6561, 65536, 3.90625E+05' , s1 ) s = tostring (( / 1.23456 , 1.2300 , 1.23456e6 / )) ; call tscompare ( s , ( / 1.23456 , 1.23 , 1.23456E+06 / ), '1c' ) s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 , 'f0.1' ) ; call scompare ( s , '1.0, 256.0, 6561.0, 65536.0, 390625.0' ) s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 , 'f6.1' ) ; call scompare ( s , '1.0, 256.0, 6561.0, ******, ******' ) s = tostring (( / 120000 0. , - 1.2e-9 / )) ; call scompare ( s , '1.2E+06, -1.2E-09' ) ! s = tostring ( - 77 ) ; call scompare ( s , '-77' ) s = tostring (( / ( i , i =- 3 , 3 ) / ) ** 11 ) ; call scompare ( s , '-177147, -2048, -1, 0, 1, 2048, 177147' ) s = tostring (( / ( i , i =- 3 , 3 ) / ) ** 11 , 'i7' ) ; call scompare ( s , '-177147, -2048, -1, 0, 1, 2048, 177147' ) s = tostring (( / ( i , i =- 3 , 3 ) / ) ** 11 , 'i4' ) ; call scompare ( s , '****, ****, -1, 0, 1, 2048, ****' ) ! s = tostring (( 1 , 3 ) / ( 4 , 2 )) ; call scompare ( s , '0.5 + 0.5i' ) s = tostring ( cmplx (( /- 1 , - 2 / )) ** 0.25 ) ; call scompare ( s , '0.70711 + 0.70711i, 0.8409 + 0.8409i' , s2 ) ! s = tostring (( / . true ., . false ., . false . / )) ; call scompare ( s , 'T, F, F' ) s = tostring (. true ., 'L2' ) ; call scompare ( s , 'T' ) ! call tostring_set ( sep = ';' ) s = tostring (( / 1 , 2 , 30 / )) ; call scompare ( s , '1;2;30' ) ! call tostring_set ( trimb = 'NO' ) s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 , 'f6.1' ) ; call scompare ( s , '   1.0; 256.0;6561.0;******;******' ) s = tostring (( / 1 , 2 , 30 / ), 'i3' ) ; call scompare ( s , '  1;  2; 30' ) s = tostring (( / ( i , i =- 3 , 3 ) / ) ** 11 , 'i4' ) ; call scompare ( s , '****;****;  -1;   0;   1;2048;****' ) s = tostring (( / 1 , 2 , 30 / ), 'i0' ) ; call scompare ( s , '1;2;30' ) s = tostring (. true ., 'L3' ) ; call scompare ( s , '  T' ) ! call tostring_set ( trimz = 'NONE' , sep = ', ' , trimb = 'YES' ) s = tostring ( real (( / ( i , i = 1 , 4 ) / )) ** 8 ) ; call tscompare ( s , ( / 1. , 25 6. , 656 1. , 6553 6. / ), '1d' ) s = tostring (( / 1.23456 , 1.2300 , 1.23456e6 / )) ; call tscompare ( s , ( / 1.23456 , 1.23 , 1.23456E+06 / ), '1e' ) if ( range ( 0._srk ) >= 103 ) then s = '1.2d103' read ( s , * ) sr s = tostring ( sr , 'ES11.5' ) ; call scompare ( s , '1.20000+103' ) call tostring_set ( trimz = 'ALL' ) s = tostring ( sr ) ; call scompare ( s , '1.2+103' ) s = tostring (( / 1.1_srk , 2.2e10_srk , 3.3e20_srk / )) ; call scompare ( s , '1.1, 2.2E+10, 3.3E+20' , s4 ) s = tostring ( exp (( /- 3._srk , - 1._srk , 0._srk , 1._srk / ))); call tscompare ( s , ( / 4.97871E-02 , 0.36788 , 1. , 2.71828 / ), '1b' ) ! (*) endif ! call tostring_set ( trimz = 'ALL' ) s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 , 'f0.1' ) ; call scompare ( s , '1, 256, 6561, 65536, 390625' ) ! call tostring_set ( rfmt = 'G12.4E2' ) s = tostring ( real (( / ( i , i = 1 , 5 ) / )) ** 8 ) ; call scompare ( s , '1, 256, 6561, 0.6554E+05, 0.3906E+06' ) s = tostring (( / 120000 0. , - 1.2e-9 / )) ; call scompare ( s , '0.12E+07, -0.12E-08' ) ! call disp_set_factory call tostring_set_factory end subroutine tests_from_manual_5 !=================================================================================================================================== subroutine tscompare ( s , vec , msg ) character ( * ), intent ( in ) :: s , msg real , intent ( in ) :: vec (:) real svec ( size ( vec )) integer i read ( s , * ) svec do i = 1 , size ( vec ) call assert ( abs ( vec ( i ) - svec ( i )) / abs ( vec ( i )) < 1e-4 , 'tscompare:' // msg ) enddo end subroutine tscompare !=================================================================================================================================== subroutine test_empty ! Test display of empty vectors / matrices of various dimensions (0 by 0, 0 by 1, 1 by 0, 0 by 2 etc.) character ( 16 ) shouldbe ( 14 ) character ( 20 ) shouldbe_char ( 14 ) call assert_init ( 'TEST_EMPTY' ) shouldbe = ( / & 'v=,v=   ,v,-v-,*' , & 'v,*             ' , & ' ,*             ' , & ' v              ' , & '---             ' , & 'M02= ,M02=   ,* ' , & 'M02,  M02 ,*    ' , & '---,------,     ' , & 'M20=,M20=,*     ' , & '    ,    ,      ' , & 'M20,M20,*       ' , & '---,---,        ' , & '   ,   ,        ' , & '   ,   ,        ' / ) shouldbe_char = ( / & 'v=  ,v=   ,-v,-v-,* ' , & 'v,*                 ' , & ' ,*                 ' , & ' v                  ' , & '---                 ' , & 'M02=     ,M02=   ,* ' , & '  M02 , M02,*       ' , & '------,----,        ' , & 'M20=,M20=,*         ' , & '    ,    ,          ' , & 'M20,M20,*           ' , & '---,---,            ' , & '   ,   ,            ' , & '   ,   ,            ' / ) call disp_set ( unit = 8 , advance = 'no' , matsep = ',' ) call test_empty_int ; call compare ( shouldbe , 'int' ) call test_empty_real ; call compare ( shouldbe , 'real' ) call test_empty_logical ; call compare ( shouldbe , 'logical' ) call test_empty_char ; call compare ( shouldbe_char , 'char' ) call disp_set_factory call assert_init () end subroutine test_empty !=================================================================================================================================== subroutine test_empty_int integer :: ivec ( 0 ), i02mat ( 0 , 2 ), i20mat ( 2 , 0 ) ivec = 0 ; i02mat = 0 ; i20mat = 0 call msg2 ( '...empty integer' ) call disp ( 'v=' , ivec ) call disp ( 'v=' , ivec , 'I3' ) call disp ( 'v' , ivec , style = 'pad' ) call disp ( 'v' , ivec , 'I3' , style = 'pad' ) call disp ( '*' , advance = 'yes' ) call disp ( 'v' , ivec , style = 'pad' , orient = 'row' ) call disp (( / '*' , '*' / ), advance = 'yes' ) call disp ( 'v' , ivec , 'I3' , style = 'underline' , advance = 'yes' ) call disp ( 'M02=' , i02mat , sep = ':' ) call disp ( 'M02=' , i02mat , 'I1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M02' , i02mat , style = 'underline' ) call disp ( 'M02' , i02mat , 'I2' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20=' , i20mat , sep = ':' ) call disp ( 'M20=' , i20mat , 'I1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20' , i20mat , style = 'underline' ) call disp ( 'M20' , i20mat , 'I2' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) end subroutine test_empty_int !=================================================================================================================================== subroutine test_empty_logical logical ( logikind ) :: lvec ( 0 ), l02mat ( 0 , 2 ), l20mat ( 2 , 0 ) lvec = . false .; l02mat = . false .; l20mat = . false . call assert_init ( '...empty logical' ) call disp ( 'v=' , lvec ) call disp ( 'v=' , lvec , 'L3' ) call disp ( 'v' , lvec , style = 'pad' ) call disp ( 'v' , lvec , 'L3' , style = 'pad' ) call disp ( '*' , advance = 'yes' ) call disp ( 'v' , lvec , style = 'pad' , orient = 'row' ) call disp (( / '*' , '*' / ), advance = 'yes' ) call disp ( 'v' , lvec , 'L3' , style = 'underline' , advance = 'yes' ) call disp ( 'M02=' , l02mat , sep = ':' ) call disp ( 'M02=' , l02mat , 'L1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M02' , l02mat , style = 'underline' ) call disp ( 'M02' , l02mat , 'L2' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20=' , l20mat , sep = ':' ) call disp ( 'M20=' , l20mat , 'L1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20' , l20mat , style = 'underline' ) call disp ( 'M20' , l20mat , 'L2' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) end subroutine test_empty_logical !=================================================================================================================================== subroutine test_empty_real real :: rvec ( 0 ), r02mat ( 0 , 2 ), r20mat ( 2 , 0 ) rvec = 0.0 ; r02mat = 0.0 ; r20mat = 0.0 call assert_init ( '...empty real' ) call disp ( 'v=' , rvec ) call disp ( 'v=' , rvec , 'F3.0' ) call disp ( 'v' , rvec , style = 'pad' ) call disp ( 'v' , rvec , 'F3.0' , style = 'pad' ) call disp ( '*' , advance = 'yes' ) call disp ( 'v' , rvec , style = 'pad' , orient = 'row' ) call disp (( / '*' , '*' / ), advance = 'yes' ) call disp ( 'v' , rvec , 'F3.0' , style = 'underline' , advance = 'yes' ) call disp ( 'M02=' , r02mat , sep = ':' ) call disp ( 'M02=' , r02mat , 'F1.0' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M02' , r02mat , style = 'underline' ) call disp ( 'M02' , r02mat , 'F2.0' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20=' , r20mat , sep = ':' ) call disp ( 'M20=' , r20mat , 'F1.0' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20' , r20mat , style = 'underline' ) call disp ( 'M20' , r20mat , 'F2.0' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) end subroutine test_empty_real !=================================================================================================================================== subroutine test_empty_char character ( 2 ) :: cvec ( 0 ), c02mat ( 0 , 2 ), c20mat ( 2 , 0 ) cvec = '' ; c02mat = '' ; c20mat = '' ; call assert_init ( '...empty char' ) call disp ( 'v=' , cvec ) call disp ( 'v=' , cvec , 'A3' ) call disp ( 'v' , cvec , style = 'pad' ) call disp ( 'v' , cvec , 'A3' , style = 'pad' ) call disp ( '*' , advance = 'yes' ) call disp ( 'v' , cvec , style = 'pad' , orient = 'row' ) call disp (( / '*' , '*' / ), advance = 'yes' ) call disp ( 'v' , cvec , 'A3' , style = 'underline' , advance = 'yes' ) call disp ( 'M02=' , c02mat , sep = ':' ) call disp ( 'M02=' , c02mat , 'A1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M02' , c02mat , style = 'underline' ) call disp ( 'M02' , c02mat , 'A1' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20=' , c20mat , sep = ':' ) call disp ( 'M20=' , c20mat , 'A1' , sep = ':' ) call disp ( '*' , advance = 'yes' ) call disp ( 'M20' , c20mat , style = 'underline' ) call disp ( 'M20' , c20mat , 'A2' , style = 'underline' ) call disp ( '*' , advance = 'yes' ) end subroutine test_empty_char !=================================================================================================================================== subroutine test_scalar_string ! Test features with scalar-string (and missing item) character ( 6 ) shouldbe ( 7 ) ! call assert_init ( 'TEST_SCALAR_STRING' ) shouldbe = ( / & 'A     ' , & '      ' , & ' B   C' , & 'T     ' , & '-     ' , & 'D     ' , & 'E=E   ' / ) call disp_set ( unit = 8 ) call disp ( 'A' ) call disp () call disp ( 'B' , fmt = 'A2' , advance = 'no' ) call disp ( 'C' , advance = 'yes' ) call disp ( 'T' , 'D' , style = 'underline' ) call disp ( 'E=' , 'E' , advance = 'no' ) call disp ( advance = 'yes' ) call compare ( shouldbe , 'x' ) call disp_set_factory end subroutine test_scalar_string !=================================================================================================================================== subroutine test_tostring character ( 50 ) s call assert_init ( 'TEST_TOSTRING' ) ! First test: call assert ( len ( tostring ( 1e23 , 'F0.2' )) == 26 . or . len ( tostring ( 1e23 , 'F0.2' )) == 27 ) s = tostring ( 1e23 , 'F0.2' ) call assert ( s ( 1 : 6 ) == '100000' . and . len_trim ( s ) == 27 . or . s ( 1 : 6 ) == '999999' . and . len_trim ( s ) == 26 ) ! Tests when factory defaults are in effect: call test_tostring_factory ! Tests of tostring when tostring_set is used to change defaults: call tostring_set ( sep = '::::' ) ; call scompare ( tostring (( / 1 , 2 , 3 / )), '1::::2::::3' ) call tostring_set ( ifmt = 'i3' ) ; call scompare ( tostring (( / 1 , 2 / )), '1::::2' ) call tostring_set ( trimb = 'NO' ) ; call scompare ( tostring (( / 1 , 2 / )), '  1::::  2' ) call tostring_set ( ifmt = 'i0' ) ; call scompare ( tostring (( / 1 , 2 / )), '1::::2' ) call tostring_set ( sep = '=1234567==' ) ; call scompare ( tostring (( / 1 , 2 / )), '1=1234567=2' ) call tostring_set ( rfmt = 'E7.1E2' ) ; call scompare ( tostring ( 1.0 ), '0.1E+01' ) call tostring_set ( rfmt = '1PE7.1E2' ) ; call scompare ( tostring ( 1.0 ), '1.0E+00' ) call tostring_set ( rfmt = '1PE6.0E2' ) ; call scompare ( tostring ( 1.0 ), '1.E+00' ) call tostring_set ( trimz = 'NONE' ) ; call scompare ( tostring ( 1.0 , 'F4.1' ), ' 1.0' ) call tostring_set ( trimz = 'ALL' ) ; call scompare ( tostring ( 1.0 , 'F4.1' ), ' 1' ) call tostring_set ( ifmt = 'i2' , sep = ',' ) ; call scompare ( tostring (( / 123 , 20 / )), '**,20' ) call tostring_set ( trimb = 'YES' ) ; call scompare ( tostring ( 1.0 , 'F4.1' ), '1' ) call tostring_set ( rfmt = 'F0.3' , ifmt = 'I4' , trimb = 'NO' , trimz = 'NONE' , sep = ';' ) call scompare ( tostring (( / 12345 , 123 / )) , '****; 123' ) call scompare ( tostring (( / 1.1239 , 12 3.45 / )), '1.124;123.450' ) call scompare ( tostring (( / ( 1.0_srk , 0.0_srk ),( 2.1_srk , - 8.7_srk ) / )), '1.000 + 0.000i;2.100 - 8.700i' ) call tostring_set_factory ! Confirm that behavior is back to original: call test_tostring_factory end subroutine test_tostring !=================================================================================================================================== subroutine test_tostring_factory ! Tests of tostring when original defaults are in effect call assert ( len ( tostring ( 5.86 )) == 4 ) call scompare ( tostring ( 5.86 ) , '5.86' ) call scompare ( tostring ( 5.86e10 ) , '5.86E+10' , '5.86+010' ) call scompare ( tostring (( / 1 , 100 , 10000 / )) , '1, 100, 10000' ) call scompare ( tostring (( / 1. , 10 0. , 1000 0. / )) , '1, 100, 10000' ) call scompare ( tostring ( 1 0.8 , 'F8.3' ) , '10.800' ) call scompare ( tostring ( 1 0.8 , 'F   8  .   3' ) , '10.800' ) call scompare ( tostring ( 1 0.8 , 'F2.1' ) , '**' ) call scompare ( tostring ( 1 0.8 , 'U9.2' ) , 'Illegal format' ) call scompare ( tostring ( 1 0.8 , '333' ) , 'Illegal format' ) call scompare ( tostring ( 1 0.8 , 'ES' ) , 'Illegal format' ) call scompare ( tostring ( 1 0.8 , '2F' ) , 'Illegal format' ) call scompare ( tostring ( 1 0.8 , 'SP,1PG10.3' ) , '+10.8' ) call scompare ( tostring ( 1 0.8e9 , 'SP,1PG10.3E2' ) , '+1.08E+10' , '+1.08+010' ) call scompare ( tostring (( 1.23 , - 3.222 )) , '1.23 - 3.222i' ) call scompare ( tostring (( / ( 1 , 1 ),( 2 , 2 ) / )) , '1 + 1i, 2 + 2i' ) call scompare ( tostring (( / ( 1 , 1 ),( 2 , 2 ) / ), 'F4.1' ) , '1.0 + 1.0i, 2.0 + 2.0i' ) end subroutine test_tostring_factory !=================================================================================================================================== subroutine scompare ( s , shouldbe , sb1 , sb2 , sb3 ) ! Utility for test_tostring. Print s to the screen and assert that it is ! matches either shouldbe, sb1, sb2 or sb3. character ( * ), intent ( in ) :: s , shouldbe , sb1 , sb2 , sb3 optional sb1 , sb2 , sb3 call msg2 ( '\"' // trim ( s ) // '\" should be \"' // trim ( shouldbe ) // '\"' ) if ( present ( sb3 )) call assert ( s == shouldbe . or . s == sb1 . or . s == sb2 . or . s == sb3 ) if ( present ( sb2 )) call assert ( s == shouldbe . or . s == sb1 . or . s == sb2 ) if ( present ( sb1 )) call assert ( s == shouldbe . or . s == sb1 ) if (. not . present ( sb1 )) call assert ( s == shouldbe ) end subroutine scompare !=================================================================================================================================== subroutine compare ( sok , message , sok1 ) ! Utility for all the test routines. Print to the screen what the last disp calls ! displayed, and assert that what was displayed matches either sok or sok1. character ( * ), intent ( in ) :: sok (:), sok1 (:), message optional :: message , sok1 character ( 100 ) :: s , mess integer ios1 , i rewind ( 8 ) compare_no = compare_no + 1 if ( present ( message )) then mess = message else write ( mess , '(a,\"-\",i0)' ) trim ( assert_string ), compare_no endif do i = 1 , 9999 read ( 8 , 1 , iostat = ios1 ) s if ( ios1 < 0 ) exit call msg2 ( s ) call assert ( i <= size ( sok ), message ) if ( present ( sok1 )) call assert ( sok ( i ) == s . or . sok1 ( i ) == s , mess ) if (. not . present ( sok1 )) call assert ( sok ( i ) == s , mess ) enddo call assert ( i == size ( sok ) + 1 , mess ) call reopen_8 1 format ( A ) end subroutine compare !=================================================================================================================================== subroutine reopen_8 call close_8 call open_8 end subroutine reopen_8 subroutine open_8 open ( 8 , file = 'testtmp.dat' , status = 'replace' ) end subroutine open_8 subroutine close_8 close ( 8 ) end subroutine close_8 !=================================================================================================================================== subroutine assert_init ( st ) ! Set assert-string (used by subroutine compare) to st, compare_no to zero and display st ! if verbose is true. If st is absent, set assert_string to '' character ( * ), optional , intent ( in ) :: st if ( present ( st )) then assert_string = st call msg2 ( '' ) call msg1 ( st ) else assert_string = '' endif compare_no = 0 end subroutine assert_init !=================================================================================================================================== subroutine assert ( s , msg ) ! Assert that s is true. If not print \"assertion failed\" and msg if it is present logical , intent ( in ) :: s character ( * ), optional , intent ( in ) :: msg if (. not . s ) then if ( present ( msg )) then print '(a, \": assertion failed\")' , trim ( msg ) else print '(\"assertion failed\")' endif stop 2 endif end subroutine assert !=================================================================================================================================== END PROGRAM TEST_M_display","tags":"","url":"sourcefile/test_suite_m_display.f90.html"},{"title":"dispdemo.f90 – M_display","text":"Source Code PROGRAM DISPDEMO ! Example driver for M_display. USE M_display ! USE DISP_R16MOD IMPLICIT NONE INTEGER , PARAMETER :: RK = SELECTED_REAL_KIND ( 6 ), N = 3 REAL ( RK ) :: A ( N , N ), B ( N , N ), X INTEGER I , J , K ( 5 ) CALL DISP_SET ( ADVANCE = 'DOUBLE' ) FORALL ( I = 1 : N , J = 1 : N ) A ( I , J ) = EXP ( REAL ( I + J - 1 , RK )) B ( I , J ) = EXP ( REAL ( I ** J , RK )) END FORALL CALL DISP ( 'A = ' , A ) CALL DISP ( B ) CALL DISP ( A ( 1 : 2 ,:), 'F0.5' ) CALL DISP ( 'MATRIX' , A , STYLE = 'UNDERLINE & NUMBER' , UNIT =- 3 , DIGMAX = 4 ) K = ( /- 3 , 0 , 12 , 14 , 0 / ) CALL DISP ( 'K' , K , STYLE = 'PAD' , ORIENT = 'ROW' , SEP = ' ' , ZEROAS = '.' ) X = 1.5 CALL DISP ( 'The square of ' // TOSTRING ( X ) // ' is ' // TOSTRING ( X * X )) CALL DISP_SET ( MATSEP = ' | ' ) CALL DISP (( / 11 , 12 , 13 / ), ADVANCE = 'NO' ) CALL DISP (( / . TRUE ., . FALSE ., . TRUE . / ), ADVANCE = 'NO' ) CALL DISP (( / 'A' , 'B' , 'C' / )) END PROGRAM DISPDEMO ! ! A =  2.718   7.389   20.086 !      7.389  20.086   54.598 !     20.086  54.598  148.413 ! ! 2.71828E+00  2.71828E+00  2.71828E+00 ! 7.38906E+00  5.45982E+01  2.98096E+03 ! 2.00855E+01  8.10308E+03  5.32048E+11 ! ! 2.71828   7.38906  20.08554 ! 7.38906  20.08554  54.59815 ! !        MATRIX ! -------------------- !      1     2      3 ! 1   2.7   7.4   20.1 ! 2   7.4  20.1   54.6 ! 3  20.1  54.6  148.4 ! ! ------K----- ! -3 . 12 14 . ! ! The square of 1.5 is 2.25 ! ! 11 | T | A ! 12 | F | B ! 13 | T | C !","tags":"","url":"sourcefile/dispdemo.f90.html"},{"title":"test_naninf_ieee.f90 – M_display","text":"Source Code PROGRAM TEST_NANINF ! PROGRAM TO TEST DISPLAY OF NOT-A-NUMBER-S AND INFINITIES BY M_display ! (Appropriate for compilers that support IEEE-arithmetic as described in the Fortran 2003 standard) USE , INTRINSIC :: IEEE_ARITHMETIC USE TEST_NANINF_MOD ! USE DISP_R16MOD ! uncomment this line if testing of disp_r16mod (quad precision) is required ! ! Copyright (c) 2008, Kristj n J nasson, Dept. of Computer Science, University of ! Iceland (jonasson@hi.is). This software is free. For details see the file README. implicit none real ( srk ) nan , inf , minf nan = ieee_value ( 0._srk , ieee_quiet_nan ) inf = ieee_value ( 0._srk , ieee_positive_inf ) minf = ieee_value ( 0._srk , ieee_negative_inf ) call test_ni ( nan , inf , minf ) END PROGRAM TEST_NANINF","tags":"","url":"sourcefile/test_naninf_ieee.f90.html"}]}